# Copyright (c) 2019 Andrew Marx. All rights reserved.
# Licensed under GPLv3.0. See LICENSE file in the project root for details..

#' @include samc-class.R
NULL


#' Check landscape data
#'
#' Check that landscape inputs have valid values and matching properties.
#'
#' This function is used to ensure that landscape inputs (resistance, absorption,
#' fidelity, and occupancy) have valid values and the same properties. This includes
#' checking the CRS (if using RasterLayer inputs), dimensions, and locations of
#' cells with NA data. It can be used to directly compare two matrices or two
#' RasterLayers, or it can be used to check a \code{\link{samc-class}} object
#' against a matrix or RasterLayer.
#'
#' The function returns \code{TRUE} if the inputs have matching properties. Otherwise,
#' it will stop execution and print the error message generated by the
#' compareRaster() function from the raster package. This error will provide
#' some details about the difference between the two inputs.
#'
#' Note that the package assumes the different landscape inputs will be the same
#' type, either matrices or RasterLayers. Mixing RasterLayer data and matrix
#' data is not supported.
#'
#' @param a A \code{\link{samc-class}}, \code{\link{matrix}}, or \code{\link[raster]{RasterLayer-class}} object
#' @param b A \code{\link{matrix}} or \code{\link[raster]{RasterLayer-class}} object
#
#' @return See \emph{Details} section.
#'
#' @example inst/examples/example.R
#'
#' @export

setGeneric(
  "check",
  function(a, b) {
    standardGeneric("check")
  })



# TODO merge
#' @rdname check
setMethod(
  "check",
  signature(a = "Raster", b = "missing"),
  function(a){

    n <- raster::nlayers(a)

    if (n == 0) {
      stop("No raster layers found", call. = FALSE)
    }

    r1 <- a[[1]]

    if (sum(is.infinite(r1[]), na.rm = TRUE) > 0) {
      stop("Data contains Inf or -Inf element", call. = FALSE)
    } else if (sum(is.nan(r1[]), na.rm = TRUE) > 0) {
      stop("Data contains NaN elements", call. = FALSE)
    }

    if (n > 1) {
      r1[] <- is.finite(r1[])

      for (i in 2:n) {
        r2 <- a[[i]]

        if (sum(is.infinite(r2[]), na.rm = TRUE) > 0) {
          stop("Data contains Inf or -Inf element", call. = FALSE)
        } else if (sum(is.nan(r2[]), na.rm = TRUE) > 0) {
          stop("Data contains NaN elements", call. = FALSE)
        }

        r2[] <- is.finite(r2[])

        tryCatch(
          {
            raster::compareRaster(r1, r2, values = TRUE)
          },
          error = function(e) {
            if(grepl("not all objects have the same values", e$message)) {
              msg = "NA mismatch"
            } else {
              msg = e$message
            }
            stop(msg, " in input data", call. = FALSE)
          }
        )
      }
    }

    return(TRUE)
  })

#' @rdname check
setMethod(
  "check",
  signature(a = "SpatRaster", b = "missing"),
  function(a){

    n <- terra::nlyr(a)

    if (n == 0) {
      stop("No raster layers found", call. = FALSE)
    }

    r1 <- a[[1]]

    if (sum(is.infinite(r1[]), na.rm = TRUE) > 0) {
      stop("Data contains Inf or -Inf element", call. = FALSE)
    } else if (sum(is.nan(r1[]), na.rm = TRUE) > 0) {
      stop("Data contains NaN elements", call. = FALSE)
    }

    if (n > 1) {
      r1[] <- is.finite(r1[])

      for (i in 2:n) {
        r2 <- a[[i]]

        if (sum(is.infinite(r2[]), na.rm = TRUE) > 0) {
          stop("Data contains Inf or -Inf element", call. = FALSE)
        } else if (sum(is.nan(r2[]), na.rm = TRUE) > 0) {
          stop("Data contains NaN elements", call. = FALSE)
        }

        r2[] <- is.finite(r2[])

        tryCatch(
          {
            terra::compareGeom(r1, r2)
          },
          error = function(e) {
              msg = e$message
            stop(msg, " in input data", call. = FALSE)
          }
        )

        if (!all.equal(terra::values(r1, mat = FALSE), terra::values(r2, mat = FALSE))) {
          stop("NA mismatch in input data", call. = FALSE)
        }
      }
    }

    return(TRUE)
  })



#' @rdname check
setMethod(
  "check",
  signature(a = "matrix", b = "missing"),
  function(a){
    a <- .rasterize(a)

    check(a)
  })



# TODO: merge
#' @rdname check
setMethod(
  "check",
  signature(a = "SpatRaster", b = "SpatRaster"),
  function(a, b){
    check(c(a, b))
  })

#' @rdname check
setMethod(
  "check",
  signature(a = "Raster", b = "Raster"),
  function(a, b){
    check(raster::stack(a, b))
  })



#' @rdname check
setMethod(
  "check",
  signature(a = "matrix", b = "matrix"),
  function(a, b){
    a <- .rasterize(a)
    b <- .rasterize(b)

    check(a, b)
  })



# TODO merge
#' @rdname check
setMethod(
  "check",
  signature(a = "samc", b = "Raster"),
  function(a, b){
    if (a@source != "map") stop("Parameters do not apply to a samc-class object created from a ", a@source, call. = FALSE)

    a <- a@map
    a[!a[]] <- NA

    check(a, b)
  })

#' @rdname check
setMethod(
  "check",
  signature(a = "samc", b = "SpatRaster"),
  function(a, b){
    if (a@source != "map") stop("Parameters do not apply to a samc-class object created from a ", a@source, call. = FALSE)

    a <- a@map
    a[!a[]] <- NA

    check(a, b)
  })




#' @rdname check
setMethod(
  "check",
  signature(a = "samc", b = "matrix"),
  function(a, b){
    b <- .rasterize(b)

    check(a, b)
  })
