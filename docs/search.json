[{"path":"/LICENSE.html","id":null,"dir":"","previous_headings":"","what":"GNU Affero General Public License","title":"GNU Affero General Public License","text":"Version 3, 19 November 2007 Copyright (C) 2007 Free Software Foundation, Inc. <https://fsf.org/> Everyone permitted copy distribute verbatim copies license document, changing allowed.","code":""},{"path":"/LICENSE.html","id":"preamble","dir":"","previous_headings":"","what":"Preamble","title":"GNU Affero General Public License","text":"GNU Affero General Public License free, copyleft license software kinds works, specifically designed ensure cooperation community case network server software. licenses software practical works designed take away freedom share change works. contrast, General Public Licenses intended guarantee freedom share change versions program–make sure remains free software users. speak free software, referring freedom, price. General Public Licenses designed make sure freedom distribute copies free software (charge wish), receive source code can get want , can change software use pieces new free programs, know can things. Developers use General Public Licenses protect rights two steps: (1) assert copyright software, (2) offer License gives legal permission copy, distribute /modify software. secondary benefit defending users’ freedom improvements made alternate versions program, receive widespread use, become available developers incorporate. Many developers free software heartened encouraged resulting cooperation. However, case software used network servers, result may fail come . GNU General Public License permits making modified version letting public access server without ever releasing source code public. GNU Affero General Public License designed specifically ensure , cases, modified source code becomes available community. requires operator network server provide source code modified version running users server. Therefore, public use modified version, publicly accessible server, gives public access source code modified version. older license, called Affero General Public License published Affero, designed accomplish similar goals. different license, version Affero GPL, Affero released new version Affero GPL permits relicensing license. precise terms conditions copying, distribution modification follow.","code":""},{"path":[]},{"path":"/LICENSE.html","id":"id_0-definitions","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"0. Definitions.","title":"GNU Affero General Public License","text":"“License” refers version 3 GNU Affero General Public License. “Copyright” also means copyright-like laws apply kinds works, semiconductor masks. “Program” refers copyrightable work licensed License. licensee addressed “”. “Licensees” “recipients” may individuals organizations. “modify” work means copy adapt part work fashion requiring copyright permission, making exact copy. resulting work called “modified version” earlier work work “based ” earlier work. “covered work” means either unmodified Program work based Program. “propagate” work means anything , without permission, make directly secondarily liable infringement applicable copyright law, except executing computer modifying private copy. Propagation includes copying, distribution (without modification), making available public, countries activities well. “convey” work means kind propagation enables parties make receive copies. Mere interaction user computer network, transfer copy, conveying. interactive user interface displays “Appropriate Legal Notices” extent includes convenient prominently visible feature (1) displays appropriate copyright notice, (2) tells user warranty work (except extent warranties provided), licensees may convey work License, view copy License. interface presents list user commands options, menu, prominent item list meets criterion.","code":""},{"path":"/LICENSE.html","id":"id_1-source-code","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"1. Source Code.","title":"GNU Affero General Public License","text":"“source code” work means preferred form work making modifications . “Object code” means non-source form work. “Standard Interface” means interface either official standard defined recognized standards body, , case interfaces specified particular programming language, one widely used among developers working language. “System Libraries” executable work include anything, work whole, () included normal form packaging Major Component, part Major Component, (b) serves enable use work Major Component, implement Standard Interface implementation available public source code form. “Major Component”, context, means major essential component (kernel, window system, ) specific operating system () executable work runs, compiler used produce work, object code interpreter used run . “Corresponding Source” work object code form means source code needed generate, install, (executable work) run object code modify work, including scripts control activities. However, include work’s System Libraries, general-purpose tools generally available free programs used unmodified performing activities part work. example, Corresponding Source includes interface definition files associated source files work, source code shared libraries dynamically linked subprograms work specifically designed require, intimate data communication control flow subprograms parts work. Corresponding Source need include anything users can regenerate automatically parts Corresponding Source. Corresponding Source work source code form work.","code":""},{"path":"/LICENSE.html","id":"id_2-basic-permissions","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"2. Basic Permissions.","title":"GNU Affero General Public License","text":"rights granted License granted term copyright Program, irrevocable provided stated conditions met. License explicitly affirms unlimited permission run unmodified Program. output running covered work covered License output, given content, constitutes covered work. License acknowledges rights fair use equivalent, provided copyright law. may make, run propagate covered works convey, without conditions long license otherwise remains force. may convey covered works others sole purpose make modifications exclusively , provide facilities running works, provided comply terms License conveying material control copyright. thus making running covered works must exclusively behalf, direction control, terms prohibit making copies copyrighted material outside relationship . Conveying circumstances permitted solely conditions stated . Sublicensing allowed; section 10 makes unnecessary.","code":""},{"path":"/LICENSE.html","id":"id_3-protecting-users-legal-rights-from-anti-circumvention-law","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"3. Protecting Users’ Legal Rights From Anti-Circumvention Law.","title":"GNU Affero General Public License","text":"covered work shall deemed part effective technological measure applicable law fulfilling obligations article 11 WIPO copyright treaty adopted 20 December 1996, similar laws prohibiting restricting circumvention measures. convey covered work, waive legal power forbid circumvention technological measures extent circumvention effected exercising rights License respect covered work, disclaim intention limit operation modification work means enforcing, work’s users, third parties’ legal rights forbid circumvention technological measures.","code":""},{"path":"/LICENSE.html","id":"id_4-conveying-verbatim-copies","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"4. Conveying Verbatim Copies.","title":"GNU Affero General Public License","text":"may convey verbatim copies Program’s source code receive , medium, provided conspicuously appropriately publish copy appropriate copyright notice; keep intact notices stating License non-permissive terms added accord section 7 apply code; keep intact notices absence warranty; give recipients copy License along Program. may charge price price copy convey, may offer support warranty protection fee.","code":""},{"path":"/LICENSE.html","id":"id_5-conveying-modified-source-versions","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"5. Conveying Modified Source Versions.","title":"GNU Affero General Public License","text":"may convey work based Program, modifications produce Program, form source code terms section 4, provided also meet conditions: work must carry prominent notices stating modified , giving relevant date. work must carry prominent notices stating released License conditions added section 7. requirement modifies requirement section 4 “keep intact notices”. must license entire work, whole, License anyone comes possession copy. License therefore apply, along applicable section 7 additional terms, whole work, parts, regardless packaged. License gives permission license work way, invalidate permission separately received . work interactive user interfaces, must display Appropriate Legal Notices; however, Program interactive interfaces display Appropriate Legal Notices, work need make . compilation covered work separate independent works, nature extensions covered work, combined form larger program, volume storage distribution medium, called “aggregate” compilation resulting copyright used limit access legal rights compilation’s users beyond individual works permit. Inclusion covered work aggregate cause License apply parts aggregate.","code":""},{"path":"/LICENSE.html","id":"id_6-conveying-non-source-forms","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"6. Conveying Non-Source Forms.","title":"GNU Affero General Public License","text":"may convey covered work object code form terms sections 4 5, provided also convey machine-readable Corresponding Source terms License, one ways: Convey object code , embodied , physical product (including physical distribution medium), accompanied Corresponding Source fixed durable physical medium customarily used software interchange. Convey object code , embodied , physical product (including physical distribution medium), accompanied written offer, valid least three years valid long offer spare parts customer support product model, give anyone possesses object code either (1) copy Corresponding Source software product covered License, durable physical medium customarily used software interchange, price reasonable cost physically performing conveying source, (2) access copy Corresponding Source network server charge. Convey individual copies object code copy written offer provide Corresponding Source. alternative allowed occasionally noncommercially, received object code offer, accord subsection 6b. Convey object code offering access designated place (gratis charge), offer equivalent access Corresponding Source way place charge. need require recipients copy Corresponding Source along object code. place copy object code network server, Corresponding Source may different server (operated third party) supports equivalent copying facilities, provided maintain clear directions next object code saying find Corresponding Source. Regardless server hosts Corresponding Source, remain obligated ensure available long needed satisfy requirements. Convey object code using peer--peer transmission, provided inform peers object code Corresponding Source work offered general public charge subsection 6d. separable portion object code, whose source code excluded Corresponding Source System Library, need included conveying object code work. “User Product” either (1) “consumer product”, means tangible personal property normally used personal, family, household purposes, (2) anything designed sold incorporation dwelling. determining whether product consumer product, doubtful cases shall resolved favor coverage. particular product received particular user, “normally used” refers typical common use class product, regardless status particular user way particular user actually uses, expects expected use, product. product consumer product regardless whether product substantial commercial, industrial non-consumer uses, unless uses represent significant mode use product. “Installation Information” User Product means methods, procedures, authorization keys, information required install execute modified versions covered work User Product modified version Corresponding Source. information must suffice ensure continued functioning modified object code case prevented interfered solely modification made. convey object code work section , , specifically use , User Product, conveying occurs part transaction right possession use User Product transferred recipient perpetuity fixed term (regardless transaction characterized), Corresponding Source conveyed section must accompanied Installation Information. requirement apply neither third party retains ability install modified object code User Product (example, work installed ROM). requirement provide Installation Information include requirement continue provide support service, warranty, updates work modified installed recipient, User Product modified installed. Access network may denied modification materially adversely affects operation network violates rules protocols communication across network. Corresponding Source conveyed, Installation Information provided, accord section must format publicly documented (implementation available public source code form), must require special password key unpacking, reading copying.","code":""},{"path":"/LICENSE.html","id":"id_7-additional-terms","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"7. Additional Terms.","title":"GNU Affero General Public License","text":"“Additional permissions” terms supplement terms License making exceptions one conditions. Additional permissions applicable entire Program shall treated though included License, extent valid applicable law. additional permissions apply part Program, part may used separately permissions, entire Program remains governed License without regard additional permissions. convey copy covered work, may option remove additional permissions copy, part . (Additional permissions may written require removal certain cases modify work.) may place additional permissions material, added covered work, can give appropriate copyright permission. Notwithstanding provision License, material add covered work, may (authorized copyright holders material) supplement terms License terms: Disclaiming warranty limiting liability differently terms sections 15 16 License; Requiring preservation specified reasonable legal notices author attributions material Appropriate Legal Notices displayed works containing ; Prohibiting misrepresentation origin material, requiring modified versions material marked reasonable ways different original version; Limiting use publicity purposes names licensors authors material; Declining grant rights trademark law use trade names, trademarks, service marks; Requiring indemnification licensors authors material anyone conveys material (modified versions ) contractual assumptions liability recipient, liability contractual assumptions directly impose licensors authors. non-permissive additional terms considered “restrictions” within meaning section 10. Program received , part , contains notice stating governed License along term restriction, may remove term. license document contains restriction permits relicensing conveying License, may add covered work material governed terms license document, provided restriction survive relicensing conveying. add terms covered work accord section, must place, relevant source files, statement additional terms apply files, notice indicating find applicable terms. Additional terms, permissive non-permissive, may stated form separately written license, stated exceptions; requirements apply either way.","code":""},{"path":"/LICENSE.html","id":"id_8-termination","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"8. Termination.","title":"GNU Affero General Public License","text":"may propagate modify covered work except expressly provided License. attempt otherwise propagate modify void, automatically terminate rights License (including patent licenses granted third paragraph section 11). However, cease violation License, license particular copyright holder reinstated () provisionally, unless copyright holder explicitly finally terminates license, (b) permanently, copyright holder fails notify violation reasonable means prior 60 days cessation. Moreover, license particular copyright holder reinstated permanently copyright holder notifies violation reasonable means, first time received notice violation License (work) copyright holder, cure violation prior 30 days receipt notice. Termination rights section terminate licenses parties received copies rights License. rights terminated permanently reinstated, qualify receive new licenses material section 10.","code":""},{"path":"/LICENSE.html","id":"id_9-acceptance-not-required-for-having-copies","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"9. Acceptance Not Required for Having Copies.","title":"GNU Affero General Public License","text":"required accept License order receive run copy Program. Ancillary propagation covered work occurring solely consequence using peer--peer transmission receive copy likewise require acceptance. However, nothing License grants permission propagate modify covered work. actions infringe copyright accept License. Therefore, modifying propagating covered work, indicate acceptance License .","code":""},{"path":"/LICENSE.html","id":"id_10-automatic-licensing-of-downstream-recipients","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"10. Automatic Licensing of Downstream Recipients.","title":"GNU Affero General Public License","text":"time convey covered work, recipient automatically receives license original licensors, run, modify propagate work, subject License. responsible enforcing compliance third parties License. “entity transaction” transaction transferring control organization, substantially assets one, subdividing organization, merging organizations. propagation covered work results entity transaction, party transaction receives copy work also receives whatever licenses work party’s predecessor interest give previous paragraph, plus right possession Corresponding Source work predecessor interest, predecessor can get reasonable efforts. may impose restrictions exercise rights granted affirmed License. example, may impose license fee, royalty, charge exercise rights granted License, may initiate litigation (including cross-claim counterclaim lawsuit) alleging patent claim infringed making, using, selling, offering sale, importing Program portion .","code":""},{"path":"/LICENSE.html","id":"id_11-patents","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"11. Patents.","title":"GNU Affero General Public License","text":"“contributor” copyright holder authorizes use License Program work Program based. work thus licensed called contributor’s “contributor version”. contributor’s “essential patent claims” patent claims owned controlled contributor, whether already acquired hereafter acquired, infringed manner, permitted License, making, using, selling contributor version, include claims infringed consequence modification contributor version. purposes definition, “control” includes right grant patent sublicenses manner consistent requirements License. contributor grants non-exclusive, worldwide, royalty-free patent license contributor’s essential patent claims, make, use, sell, offer sale, import otherwise run, modify propagate contents contributor version. following three paragraphs, “patent license” express agreement commitment, however denominated, enforce patent (express permission practice patent covenant sue patent infringement). “grant” patent license party means make agreement commitment enforce patent party. convey covered work, knowingly relying patent license, Corresponding Source work available anyone copy, free charge terms License, publicly available network server readily accessible means, must either (1) cause Corresponding Source available, (2) arrange deprive benefit patent license particular work, (3) arrange, manner consistent requirements License, extend patent license downstream recipients. “Knowingly relying” means actual knowledge , patent license, conveying covered work country, recipient’s use covered work country, infringe one identifiable patents country reason believe valid. , pursuant connection single transaction arrangement, convey, propagate procuring conveyance , covered work, grant patent license parties receiving covered work authorizing use, propagate, modify convey specific copy covered work, patent license grant automatically extended recipients covered work works based . patent license “discriminatory” include within scope coverage, prohibits exercise , conditioned non-exercise one rights specifically granted License. may convey covered work party arrangement third party business distributing software, make payment third party based extent activity conveying work, third party grants, parties receive covered work , discriminatory patent license () connection copies covered work conveyed (copies made copies), (b) primarily connection specific products compilations contain covered work, unless entered arrangement, patent license granted, prior 28 March 2007. Nothing License shall construed excluding limiting implied license defenses infringement may otherwise available applicable patent law.","code":""},{"path":"/LICENSE.html","id":"id_12-no-surrender-of-others-freedom","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"12. No Surrender of Others’ Freedom.","title":"GNU Affero General Public License","text":"conditions imposed (whether court order, agreement otherwise) contradict conditions License, excuse conditions License. convey covered work satisfy simultaneously obligations License pertinent obligations, consequence may convey . example, agree terms obligate collect royalty conveying convey Program, way satisfy terms License refrain entirely conveying Program.","code":""},{"path":"/LICENSE.html","id":"id_13-remote-network-interaction-use-with-the-gnu-general-public-license","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"13. Remote Network Interaction; Use with the GNU General Public License.","title":"GNU Affero General Public License","text":"Notwithstanding provision License, modify Program, modified version must prominently offer users interacting remotely computer network (version supports interaction) opportunity receive Corresponding Source version providing access Corresponding Source network server charge, standard customary means facilitating copying software. Corresponding Source shall include Corresponding Source work covered version 3 GNU General Public License incorporated pursuant following paragraph. Notwithstanding provision License, permission link combine covered work work licensed version 3 GNU General Public License single combined work, convey resulting work. terms License continue apply part covered work, work combined remain governed version 3 GNU General Public License.","code":""},{"path":"/LICENSE.html","id":"id_14-revised-versions-of-this-license","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"14. Revised Versions of this License.","title":"GNU Affero General Public License","text":"Free Software Foundation may publish revised /new versions GNU Affero General Public License time time. new versions similar spirit present version, may differ detail address new problems concerns. version given distinguishing version number. Program specifies certain numbered version GNU Affero General Public License “later version” applies , option following terms conditions either numbered version later version published Free Software Foundation. Program specify version number GNU Affero General Public License, may choose version ever published Free Software Foundation. Program specifies proxy can decide future versions GNU Affero General Public License can used, proxy’s public statement acceptance version permanently authorizes choose version Program. Later license versions may give additional different permissions. However, additional obligations imposed author copyright holder result choosing follow later version.","code":""},{"path":"/LICENSE.html","id":"id_15-disclaimer-of-warranty","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"15. Disclaimer of Warranty.","title":"GNU Affero General Public License","text":"WARRANTY PROGRAM, EXTENT PERMITTED APPLICABLE LAW. EXCEPT OTHERWISE STATED WRITING COPYRIGHT HOLDERS /PARTIES PROVIDE PROGRAM “” WITHOUT WARRANTY KIND, EITHER EXPRESSED IMPLIED, INCLUDING, LIMITED , IMPLIED WARRANTIES MERCHANTABILITY FITNESS PARTICULAR PURPOSE. ENTIRE RISK QUALITY PERFORMANCE PROGRAM . PROGRAM PROVE DEFECTIVE, ASSUME COST NECESSARY SERVICING, REPAIR CORRECTION.","code":""},{"path":"/LICENSE.html","id":"id_16-limitation-of-liability","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"16. Limitation of Liability.","title":"GNU Affero General Public License","text":"EVENT UNLESS REQUIRED APPLICABLE LAW AGREED WRITING COPYRIGHT HOLDER, PARTY MODIFIES /CONVEYS PROGRAM PERMITTED , LIABLE DAMAGES, INCLUDING GENERAL, SPECIAL, INCIDENTAL CONSEQUENTIAL DAMAGES ARISING USE INABILITY USE PROGRAM (INCLUDING LIMITED LOSS DATA DATA RENDERED INACCURATE LOSSES SUSTAINED THIRD PARTIES FAILURE PROGRAM OPERATE PROGRAMS), EVEN HOLDER PARTY ADVISED POSSIBILITY DAMAGES.","code":""},{"path":"/LICENSE.html","id":"id_17-interpretation-of-sections-15-and-16","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"17. Interpretation of Sections 15 and 16.","title":"GNU Affero General Public License","text":"disclaimer warranty limitation liability provided given local legal effect according terms, reviewing courts shall apply local law closely approximates absolute waiver civil liability connection Program, unless warranty assumption liability accompanies copy Program return fee. END TERMS CONDITIONS","code":""},{"path":"/LICENSE.html","id":"how-to-apply-these-terms-to-your-new-programs","dir":"","previous_headings":"","what":"How to Apply These Terms to Your New Programs","title":"GNU Affero General Public License","text":"develop new program, want greatest possible use public, best way achieve make free software everyone can redistribute change terms. , attach following notices program. safest attach start source file effectively state exclusion warranty; file least “copyright” line pointer full notice found. Also add information contact electronic paper mail. software can interact users remotely computer network, also make sure provides way users get source. example, program web application, interface display “Source” link leads users archive code. many ways offer source, different solutions better different programs; see section 13 specific requirements. also get employer (work programmer) school, , sign “copyright disclaimer” program, necessary. information , apply follow GNU AGPL, see https://www.gnu.org/licenses/.","code":"<one line to give the program's name and a brief idea of what it does.>     Copyright (C) <year>  <name of author>      This program is free software: you can redistribute it and/or modify     it under the terms of the GNU Affero General Public License as     published by the Free Software Foundation, either version 3 of the     License, or (at your option) any later version.      This program is distributed in the hope that it will be useful,     but WITHOUT ANY WARRANTY; without even the implied warranty of     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the     GNU Affero General Public License for more details.      You should have received a copy of the GNU Affero General Public License     along with this program.  If not, see <https://www.gnu.org/licenses/>."},{"path":"/articles/article-circuit-theory.html","id":"background","dir":"Articles","previous_headings":"","what":"Background","title":"Circuit Theory","text":"document describes relationship samc package circuit theory, presented article published Methods Ecology Evolution (2022; DOI: 10.1111/2041-210X.13975) workshop 2021 International Association Landscape Ecology - North American annual meeting: IALE-NA 2021 Workshops. Circuit theory (McRae et al. 2008) widely used tool ecology conservation modeling landscape connectivity. can used calculate several different metrics, including: Commute time resistance distance Net flow one node another Probability reaching nodes SAMC circuit theory use Markov chain theory model movement based variations landscape coded resistance values. However, SAMC extends capabilities utilizing absorbing Markov chains, allow model variety short- long-term metrics. SAMC also allows explicitly incorporating multiple absorption states model. states can represent effect might permanently stop movement landscape, : Natural death Predation probability Disease risk Human removal Non-mortality causes (e.g., permanent settlement)","code":""},{"path":"/articles/article-circuit-theory.html","id":"code-setup","dir":"Articles","previous_headings":"","what":"Code Setup","title":"Circuit Theory","text":"section loading packages creating objects used examples. resistance data two low-resistance routes source destinations. absorption data background absorption, narrow strip strong absorption runs across map, across left route. example data used IALE workshop, absorption data used describe hypothetical highway safe crossing area left route.","code":"library(\"terra\") library(\"raster\") library(\"gdistance\") library(\"samc\") library(\"viridisLite\")  # Create a landscape with two paths around an obstacle # This is the same  res_data = matrix(c(20,   20,   20,   10,   10,    5,    5,   10,   10,    10,                     20,   20,   10,   10,   10,    1,    1,    1,    1,    10,                     10,   10,   10,    1,    1,    1,    1,    1,    1,     5,                     10,   10,    1,    1,   20,    1,    1,    1,   10,    10,                      5,    1,    1,   20,   20,   20,    1,    1,    1,     5,                     10,    1,   20,   20,   20,   20,   20,    1,    1,     2,                     10,    1,   20,   20,   20,   20,    2,    2,    1,     1,                     20,    1,    1,   10,   10,   10,    2,    1,    1,     1,                     20,    1,    1,    1,    1,    1,    1,    1,    2,     2,                     10,   10,   10,   10,    1,    1,    5,    5,    5,     5),                   nrow = 10, byrow = TRUE) abs_data = res_data * 0 # Create a baseline mortality or absorption level. To experiment with background mortality rates, add a small number to this (e.g., `+ 0.0001`) abs_data[6, c(1, 4:10)] = 0.1 # Create a \"highway\" with high absorption and a safe crossing point abs_data[is.na(res_data)] = NA  res_data = samc::rasterize(res_data) abs_data = samc::rasterize(abs_data)  plot(res_data, main = \"Example Resistance Data\", xlab = \"x\", ylab = \"y\", col = viridis(256)) plot(abs_data, main = \"Example Absorption Data\", xlab = \"x\", ylab = \"y\", col = viridis(256))  rw_model = list(fun = function(x) 1/mean(x), dir = 8, sym = TRUE)  samc_obj = samc(res_data, abs_data, model = rw_model)  origin_coords = matrix(c(2, 2), ncol = 2) dest_coords = matrix(c(9, 9), ncol = 2)  origin_cell = locate(samc_obj, origin_coords) dest_cell = locate(samc_obj, dest_coords)  gdist = transition(raster::raster(res_data), rw_model$fun, rw_model$dir) gdist = geoCorrection(gdist)"},{"path":"/articles/article-circuit-theory.html","id":"commute-time-and-hitting-time","dir":"Articles","previous_headings":"","what":"Commute Time and Hitting Time","title":"Circuit Theory","text":"Commute time (sometimes referred commute distance), expected length time, number steps, takes go one node another back graph using random walk. circuit theory, commute time proportional resistance distance two nodes (Chandra et al., 1997). measure bidirectional; sum going one node another back. Let us refer commute time CC CijC_{ij} commute time node ii node jj back node ii. Hitting time, first passage time, expected time, number steps, takes go one node another using random walk. measure unidirectional; accounts going one node another, back. hitting times may equal different directions two nodes depending situation. Let us refer hitting time using HH, HijH_{ij} hitting time node ii node jj, HjiH_{ji} hitting time node jj node ii. HijH_{ij} HijH_{ij} may may equal. Given definitions, sum two hitting times two nodes commute time two nodes. , Cij=Hij+HjiC_{ij}=H_{ij}+H_{ji}. Circuit theory can used calculate commute time two points via tools like Circuitscape (indirectly resistance outputs) gdistance R package (directly commuteDistance() function). SAMC, can calculated adding hitting times directions. two ways hitting times can calculated SAMC. first (limited) approach calculating hitting times via SAMC survival() metric. requires creating two samc objects (one direction two nodes). , non-zero absorption value needs destination node (ii jj, depending direction). long absorption occurs destination node absorption probability 1, survival() function calculate first passage time node. Applying survival() function samc objects summing results provide commute time. approach limited broadly allow variation absorption; graphs absorption occurring outside destination nodes (ii jj) require alternative approach.  key things note . First, two commute distance results slightly different. SAMC calculating time reach destination plus one additional time step absorption. circuit theory, two transitions considered separately; , reaching destination equivalent going ground state (absorption). occurs twice (direction), causes SAMC commute distance 2 time steps higher gdistance calculates. second thing note two hitting times produced SAMC also slightly different. words, movement one direction two points equivalent movement direction. extra information total commute distance can useful real-world scenario. example, gene flow two populations may different directions. case, hitting times, rather commute distance, may result better models comparing gene flow landscape connectivity. second flexible approach SAMC cond_passage() function, directly calculates “conditional” first passage time graphs absorption can occur anywhere. “conditional” considers possible paths graph destination node reached. words, absorption possible anywhere, scenarios destination never reached, scenarios excluded calculation work. cond_passage() can used way described survival() metric previously, case equivalent result commute distance circuit theory obtained. Unlike survival() function, result cond_passage() include extra absorption time step; calculates time reach destination. importantly, just special case demonstrate relationship circuit theory SAMC. generic scenarios, single normal samc object required calculating hitting times: case, resulting commute distance much lower absorption occurs throughout landscape. simplified scenario, lack absorption (except destination) means possible movement paths eventually reach destination. contrast, landscape absorption, now scenarios movement paths absorbed reaching destination. Since removed paths tended longer, removal caused overall commute time decrease. think , consider landscape without absorption. scenario, individuals continuously move around forever. leads infinitely long paths. absorption incorporated landscape, probability infinitely long paths occurring decreases. overall probability absorption landscape increases, overall probability infinitely long paths occurring decrease. happens switch circuit theory model single ground node (effectively single absorption point) SAMC model allows absorption anywhere; probability individuals existing indefinitely landscape decrease, ideally, model realistic scenario. Consider context dispersal gene flow; realistically, individual dispersing one population might never make another population. example, might die along way. result, contribute gene flow two populations case. SAMC provides mechanism account possibility via cond_passage() function incorporation absorption broadly.","code":"# Absorption only at the origin i abs_data_i = res_data * 0 abs_data_i[cellFromXY(res_data, origin_coords)] = 1 plot(abs_data_i, main = \"Source Absorption Map\", col = viridis(256))   # Absorption only at the destination j abs_data_j = res_data * 0 abs_data_j[cellFromXY(res_data, dest_coords)] = 1 plot(abs_data_j, main = \"Destination Absorption Map\", col = viridis(256)) # Create samc objects for each direction samc_ij = samc(res_data, abs_data_j, model = rw_model) samc_ji = samc(res_data, abs_data_i, model = rw_model)  # Calculate commute distance with samc hitting_ij = survival(samc_ij, abs_data_i) # Reusing the other abs layer as an occupancy input hitting_ji = survival(samc_ji, abs_data_j) # Reusing the other abs layer as an occupancy input  hitting_ij #> [1] 210.222 hitting_ji #> [1] 293.0998 hitting_ij + hitting_ji #> [1] 503.3218  # Calculate commute distance with gdistance commuteDistance(gdist, rbind(origin_coords, dest_coords)) #>          1 #> 2 501.3218 hitting_ij_cp = cond_passage(samc_ij, origin = origin_cell, dest = dest_cell) hitting_ji_cp = cond_passage(samc_ji, origin = dest_cell, dest = origin_cell)  hitting_ij_cp #> [1] 209.222 hitting_ji_cp #> [1] 292.0998 hitting_ij_cp + hitting_ji_cp #> [1] 501.3218 # Calculate hitting times and commute distance for the original absorption data reg_hitting_ij = cond_passage(samc_obj, origin = origin_cell, dest = dest_cell) reg_hitting_ji = cond_passage(samc_obj, origin = dest_cell, dest = origin_cell)  reg_hitting_ij #> [1] 128.2726 reg_hitting_ji #> [1] 127.6531 reg_hitting_ij + reg_hitting_ji #> [1] 255.9258"},{"path":"/articles/article-circuit-theory.html","id":"net-and-total-movement-flow","dir":"Articles","previous_headings":"","what":"Net and Total Movement Flow","title":"Circuit Theory","text":"One application circuit theory construction current maps describe net movement one node another. essential distinction net total movement flow ; net movement difference movement flows opposite directions, whereas total movement sum movement flows opposite directions. “current” flow maps commonly used identify movement corridors pinch points may occur landscapes. Current maps produced Circuitscape model net flow, gdistance package can model passage() function. samc package can calculate total movement directly using visitation() metric net movement flow using visitation_net() function. get equivalent results gdistance SAMC, must disregard absorption outside destination.  commute distance, SAMC limited calculating total net movement flows landscapes without absorption. visitation() visitation_net() perfectly valid original samc object broader landscape absorption. example combine destination absorption point absorbing barrier:  Incorporating absorption broadly reduced net movement flow start end points now destination guaranteed reached, leading dramatic drop net movement destination cell. can subtract non-absorption model absorption model see much net movement flow decreased.  Overall, see net flow increased bottom half decreased top half. Intuitively, net flow top half reduced barrier absorbing flow coming . increase net flow bottom half may less intuitive, occurs movement originally reached top half now partially absorbed directions. since less movement top half bottom half, means net flow bottom half less affected return flow. also see movement flow right path becomes significantly restricted absorption barrier, making left path relatively important movement flow start end. Yet, despite opening barrier, still see noticeable drop flow left path. Finally, can see substantial decrease net movement flow reaching destination. can look values directly see reduction 98%:","code":"# Total movement flow with gdistance total_gdist = passage(gdist, origin_coords, dest_coords, theta = 0, totalNet = \"total\") total_gdist_ras = rast(total_gdist) plot(total_gdist_ras, main = \"Total Movement Flow (gdistance)\", col = viridis(256))  # Equivalent total movement flow with SAMC total_samc = visitation(samc_ij, origin = origin_cell) total_samc_ras = map(samc_ij, total_samc) plot(total_samc_ras, main = \"Total Movement Flow (samc)\", col = viridis(256))  # Verify that they have the same values all.equal(as.vector(total_gdist_ras), as.vector(total_samc_ras)) #> [1] TRUE    # Net movement flow with gdistance net_gdist = passage(gdist, origin_coords, dest_coords, theta = 0, totalNet = \"net\") net_gdist_ras = rast(net_gdist) plot(net_gdist_ras, main = \"Net Movement Flow (gdistance)\", col = viridis(256))  # Equivalent net movement flow with SAMC net_samc = visitation_net(samc_ij, origin = origin_cell) net_samc_ras = map(samc_ij, net_samc) plot(net_samc_ras,  main = \"Net Movement Flow (samc)\", col = viridis(256))  # Verify that they have the same values all.equal(as.vector(net_gdist_ras), as.vector(net_samc_ras)) #> [1] TRUE comb_abs = abs_data_j + abs_data plot(comb_abs,  main = \"Combined absorption\", col = viridis(256)) samc_comb = samc(res_data, comb_abs, model = rw_model)   comb_net = visitation_net(samc_comb, origin = origin_cell) comb_net_res = map(samc_comb, comb_net) plot(comb_net_res,  main = \"Net Movement Flow (samc with combined absorption)\", col = viridis(256)) comb_net_diff = comb_net_res - net_gdist_ras  plot(comb_net_diff, main = \"Effect of Combined Absorption on Net Movement Flow\", col = viridis(256))  # Bin for easier interpretation comb_net_diff_binned = classify(comb_net_diff, rcl = c(-1, -0.1, -0.01, 0, 0.01, 0.1, 1), right = FALSE) plot(comb_net_diff_binned, main = \"Effect of Combined Absorption on Net Movement Flow (Binned)\", col = viridis(256)) net_samc_ras[dest_cell] # Net movement flow at destination w/o absorption #>   lyr.1 #> 1     1 comb_net[dest_cell] # With absorption #> [1] 0.4571945"},{"path":"/articles/article-computation-methods.html","id":"background","dir":"Articles","previous_headings":"","what":"Background","title":"Computation Methods","text":"multiple approaches calculating results samc metrics. Initially, package provided one, two others added since, original remaining default. approaches tradeoffs speed, memory usage, supported features, means “best” one depends user’s data, goals, computing resources.","code":""},{"path":[]},{"path":"/articles/article-computation-methods.html","id":"linear-algebra-solvers","dir":"Articles","previous_headings":"Methods","what":"Linear Algebra Solvers","title":"Computation Methods","text":"Linear algebra solvers take transition matrix calculate results metrics system linear equations. Currently, samc package supports two different linear algebra solvers. solvers affect behavior long-term metrics; short-term metrics calculated directly using linear algebra loop, use solvers. Additionally, base data requirements different solvers , samc object can switched one without recreating transition matrix.","code":""},{"path":"/articles/article-computation-methods.html","id":"direct-solver","dir":"Articles","previous_headings":"Methods > Linear Algebra Solvers","what":"Direct Solver","title":"Computation Methods","text":"Strengths: Supports metrics models Intermediate speed initial long-term metric calculations Caching behavior makes reruns long-term metric calculations different inputs nearly instantaneous. Weaknesses: Extremely high memory consumption long-term metric calculations Difficult parallelize main benefit direct linear algebra behavior caching behavior makes fast repeated runs long-term metrics. However, downside memory-constrained approach calculating metrics. direct solver used default can manually specified creation samc object: can also set samc object created long long samc object built transition matrix:","code":"samc(..., options = list(method = \"direct\")) samc_obj$method = \"direct\""},{"path":"/articles/article-computation-methods.html","id":"iterative-solver","dir":"Articles","previous_headings":"Methods > Linear Algebra Solvers","what":"Iterative Solver","title":"Computation Methods","text":"Strengths: Supports metrics models Moderately memory-efficient long-term metric calculations Potentially future parallelization extensive code rewrites Weaknesses: Generally slow long-term metric calculations Little benefit caching behavior Technically produces approximate result, difference noticeable (within machine precision) main benefit iterative linear algebra solver can used metric memory efficient. downside generally slowest option real-world data. iterative solver can manually specified creation samc object: can also set samc object created long long samc object built transition matrix:","code":"samc(..., options = list(method = \"iter\")) samc_obj$method = \"iter\""},{"path":"/articles/article-computation-methods.html","id":"convolution","dir":"Articles","previous_headings":"Methods","what":"Convolution","title":"Computation Methods","text":"Strengths: fast samc object creation memory efficient short- long-term metric calculations fast short-term metric calculations Easily scalable multiple computational cores Potential different computational kernels future Weaknesses: supported metrics NA values supported map inputs define custom transition functions supported correlated random-walk (addressable future) calculate long-term metrics directly convolution method entirely different approach using linear algebra solvers. convolution algorithm use transition matrix, instead calculates result using moving window across data. Creation samc object convolution method significantly faster somewhat memory efficient result. However, switched different method creation like linear algebra solvers. convolution algorithm can calculate results metrics one time step iteration time, calculating long-term metrics requires running algorithm long enough results converge total absorption. can either really fast slow, depending data distribution raster inputs. convolution algorithm benefit parallelization currently significant diminishing returns two threads. calculating metrics, algorithm memory efficient, potentially making best () choice datasets large enough memory-constrained. Additionally, short-term metrics goal analyses specific number time steps, calculations moderately faster linear algebra approach. use convolution method, must specified creation samc object: switched methods creating samc object.","code":"samc(..., options = list(method = \"conv\"))"},{"path":"/articles/article-computation-methods.html","id":"compatibility-tables","dir":"Articles","previous_headings":"","what":"Compatibility Tables","title":"Computation Methods","text":"1^1 See limitations convolution random walk. 1^1 Short-term metrics use linear algebra solvers. Instead, calculate results directly loop. regardless whether direct iterative solver used. necessarily performance characteristics long-term metrics. 2^2 number iterations steps convergence long-term metrics convolution method depends input data. hard limit 1,000,000 iterations implemented, reached, warning issued indicate results may fully converged.","code":""},{"path":"/articles/article-models.html","id":"background","dir":"Articles","previous_headings":"","what":"Background","title":"Models","text":"samc package currently supports random-walk (RW) model. random-walk default model always used package. Version 3 made breaking changes samc() function setup structure specifying different models, plans correlated random-walk model future.","code":""},{"path":"/articles/article-models.html","id":"models","dir":"Articles","previous_headings":"","what":"Models","title":"Models","text":"Models samc package defined list various components depending context:","code":"list(name, fun, dir, sym)"},{"path":"/articles/article-models.html","id":"random-walk","dir":"Articles","previous_headings":"Models","what":"Random-Walk","title":"Models","text":"basic random-walk default model used package uses following properties: name: can omitted set \"RW\" fun: function calculating transition probabilities data input. convolution algorithm allow custom functions, omitted context. dir can either 4 8 sym can either TRUE FALSE, used optimization calculating transition probabilities.","code":""},{"path":"/articles/article-models.html","id":"examples","dir":"Articles","previous_headings":"","what":"Examples","title":"Models","text":"","code":"library(\"terra\") library(\"samc\") library(\"viridisLite\")  res_data <- samc::rasterize(example_toy_res) abs_data <- samc::rasterize(example_toy_res * 0 + 0.05)  plot(res_data, main = \"Resistance\")  rw_model <- list(fun = \"1/mean(x)\", dir = 8, sym = TRUE)  samc_rw <- samc(res_data, abs_data, model = rw_model)  origin = 85 # Centered near the bottom dir = 1 # Up and left  vis_rw <- as.vector(visitation(samc_rw, origin = origin))  # The RW results plot(map(samc_rw, vis_rw), col = viridis(1024), main = \"RW\")"},{"path":"/articles/code-snippets.html","id":"introduction","dir":"Articles","previous_headings":"","what":"Introduction","title":"Code Snippets","text":"page home code isn’t suitable inclusion samc package dedicated vignettes, users may find beneficial nonetheless. included may eventually integrated package. Code thoroughly tested package may work situations versions package.","code":""},{"path":"/articles/code-snippets.html","id":"reshaping-output-from-pairwise","dir":"Articles","previous_headings":"","what":"Reshaping output from pairwise()","title":"Code Snippets","text":"","code":"# df will be a \"long\" format data.frame with columns \"origin\", \"dest\", and \"result\" df <- pairwise(...)  # Use reshape2 to convert to a pairwise matrix reshape2::acast(df, origin ~ dest, value.var = \"result\")"},{"path":"/articles/data-disconnected.html","id":"rasters","dir":"Articles","previous_headings":"","what":"Rasters","title":"Disconnected Data","text":"Imagine raster 2 islands, water separating islands raster represented NA’s. two islands disconnected result \"Warning: Input contains disconnected regions. work cond_passage() metric.\". warning isn’t issue don’t need cond_passage() function. Now, island (aka region) must least one pixel non-zero absorbing value. math algorithms don’t work without . region least one non-zero absorbing value, samc() function result Error: disconnected regions must least one non-zero absorption value Now tricky part; island/region can small single pixel. , ’re careful raster, might small, isolated patches small pixel floating around somewhere. ’re using just 4 directions transition function, even immediately diagonal another patch. easiest way spot pick one rasters set non-NA values value, like 1. turn NA’s different value, like 0. plot . Code: raster particularly large, might need save high-res image spot solo pixels external picture editor viewer.","code":"raster[!is.na(raster[])) <- 1  raster[is.na(raster[])) <- 0 plot(raster)"},{"path":"/articles/example-coinflip.html","id":"introduction","dir":"Articles","previous_headings":"","what":"Introduction","title":"Coin Flip","text":"example write-answer gave coin flip question StackExchange. Essentially, question : given series coin flips, many coin flips take (average) get sequence Heads−Tails−HeadsHeads-Tails-Heads. ’s possible model scenario using absorbing Markov chains. Metrics within package can used answer posed question, well explore questions may interest. complete code example available Github.","code":""},{"path":"/articles/example-coinflip.html","id":"libraries","dir":"Articles","previous_headings":"","what":"Libraries","title":"Coin Flip","text":"","code":"library(samc)"},{"path":"/articles/example-coinflip.html","id":"setup","dir":"Articles","previous_headings":"","what":"Setup","title":"Coin Flip","text":"first step create PP matrix representing possible states. key define HTHHTH absorbing state. words, model reaches state, complete.  First, coin flip probabilities defined using variables, allows us easily change matrix simulate biased coin want. last row column matrix represents HTHHTH, absorbing state. Notice last row makes HTHHTH can transition , never different state. construction explained Overview background. remaining rows/columns represent remaining possible combinations 3 coin flips. Technically, model assumes starting point includes sequence 3 previous flips. However, decide use TTTTTT initial starting point, take least 3 flips get target sequence, different starting empty sequence flips. Contrast sequence HHTHHT, requires one HH flip HTHHTH sequence occur. Finally, notice rows sum 1, required PP matrix. makes sense row represents transition probabilities state. state 100% probability something, whether ’s changing different transient state, absorbing state, back current state. original question, ’s possible collapse states simplify matrix considering last two coin flips instead three. example, HTTHTT also require minimum 3 flips reach (like TTTTTT, last two flips), also used starting point answer original question. However, current construction simplifies interpretation little allows different questions asked model.","code":"# Coin flip probabilities p <- 0.5    # Probability of heads q <- 1 - p  # Probability of tails  p_mat <- matrix(c(0, 0, 0, 0, 0, 0, q, p,                   q, p, 0, 0, 0, 0, 0, 0,                   0, 0, 0, 0, 0, 0, q, p,                   q, p, 0, 0, 0, 0, 0, 0,                   0, 0, 0, 0, q, p, 0, 0,                   0, 0, q, p, 0, 0, 0, 0,                   0, 0, 0, 0, q, p, 0, 0,                   0, 0, 0, 0, 0, 0, 0, 1),                 8, byrow = TRUE)  rownames(p_mat) <- c(\"HHT\", \"HHH\", \"THT\", \"THH\", \"TTT\", \"TTH\", \"HTT\", \"HTH\") colnames(p_mat) <- rownames(p_mat)  # A samc object is the core of the package samc_obj <- samc(p_mat) #> [1] \"Warning: Some checks for manually created P matrices are still missing:\" #> [1] \"1) Discontinuous data will not work with the cond_passage() function.\" #> [1] \"2) Every disconnected region of the graph must have at least one non-zero absorption value.\""},{"path":"/articles/example-coinflip.html","id":"metrics","dir":"Articles","previous_headings":"","what":"Metrics","title":"Coin Flip","text":"answer original question many coin flips take, average, see HTHHTH, need calculate expected time absorption. samc package, accomplished using survival() function. fifth element represents TTTTTT seventh element represents HTTHTT, starting points progress toward result. value 10, indicates take average 10 coin flips fair coin see sequence HTHHTH. remaining elements give us insight expected already made coin flips progress toward goal. example, first third elements represent, HHTHHT THTTHT, one flip away HTHHTH. result, lowest expected averages completion, intuitively make sense. still relatively high 6 flips expected. Even though 50% probability completing sequence single flip, failure put us back HTTHTT state, average 10 steps away. aspects model can explored using package. example, visitation() metric calculates many times state expected visited absorption. context coin flip model, means can calculate many times expect sequence occur hitting HTHHTH. case, specify starting sequence HHTHHT, one flip away HTHHTH (absorption). example interpretation, starting point, expect sequence HHTHHT occur one half times, average, hitting HTHHTH sequence. ’s interesting mathematically sum visitation values expected remaining flips hitting HTHHTH. Ultimately, visitation() metric produces matrix possible combinations states specifying origin point simply gives us single row matrix. ’s possible get individual columns, well entire matrix (requires disabling safety measure place larger problems). third relevant metric dispersal(). Rather expected number times expect coin flip sequence occur, calculates probability sequence occurring hitting target sequence HTHHTH. short-term variant can used specify limit number flips make. case, ’re trying find probability TTTTTT occurring within 5 flips. results show probability every possible starting sequencing. example, seventh element, HTTHTT one flip away highest probability 0.59375.","code":"# Given the last 3 flips, how many more flips until we hit HTH (absorption)? survival(samc_obj) #> [1]  6  8  6  8 10  8 10 # Given a starting point (in this case, a sequence of 3 flips), how many times # would we expect the different combinations of 3 flips to occur before absorption? visitation(samc_obj, origin = \"HHT\") #> [1] 1.5 0.5 0.5 0.5 1.0 1.0 1.0  sum(visitation(samc_obj, origin = \"HHT\")) # Compare to survival() result #> [1] 6 # Instead of a start point, we can look at an endpoint and how often we expect # it to occur for each of the possible starting points visitation(samc_obj, dest = \"THT\") #> [1] 0.5 0.5 1.5 0.5 1.0 1.0 1.0  # These results are just rows/cols of a larger matrix. We can get the entire matrix # of the start/end possibilities but first, we have to disable some safety measures # in place because this package is designed to work with extremely large P matrices # (millions of rows/cols) where these types of results will consume too much RAM and # crash R samc_obj$override <- TRUE visitation(samc_obj) #>      [,1] [,2] [,3] [,4] [,5] [,6] [,7] #> [1,]  1.5  0.5  0.5  0.5    1    1    1 #> [2,]  1.5  2.5  0.5  0.5    1    1    1 #> [3,]  0.5  0.5  1.5  0.5    1    1    1 #> [4,]  1.5  1.5  0.5  1.5    1    1    1 #> [5,]  1.0  1.0  1.0  1.0    3    2    1 #> [6,]  1.0  1.0  1.0  1.0    1    2    1 #> [7,]  1.0  1.0  1.0  1.0    2    2    2  rowSums(visitation(samc_obj)) # equivalent to survival() above #> [1]  6  8  6  8 10  8 10 dispersal(samc_obj, dest = \"TTT\", time = 5) #> [1] 0.28125 0.21875 0.28125 0.21875 0.00000 0.21875 0.59375"},{"path":"/articles/example-maze-part1.html","id":"introduction","dir":"Articles","previous_headings":"","what":"Introduction","title":"Maze Part 1","text":"example shows use interpret different absorbing Markov chain metrics perfect maze. perfect maze maze loops, every point reachable, single path two points. motivation type example fun interesting simple properties make easy visually numerically interpret results different metrics available package. complete code series available GitHub.","code":""},{"path":"/articles/example-maze-part1.html","id":"libraries","dir":"Articles","previous_headings":"","what":"Libraries","title":"Maze Part 1","text":"","code":"library(raster) library(terra) library(gdistance) library(samc) library(viridisLite)"},{"path":"/articles/example-maze-part1.html","id":"setup","dir":"Articles","previous_headings":"","what":"Setup","title":"Maze Part 1","text":"Create function reduce redundant plotting code make examples easier read: Create simple color palette one two colors needed figure: Setup resistance map representing maze use gdistance package get information solution (shortest path). Assume start top left finish bottom right:  Create absorption map finish point source absorption. absorption value 1.0, means point entered, left another cell maze:  Given nature calculations performed package, ’s sometimes possible floating point precision issues arise equality comparisons two decimal values don’t yield expected results. ’s unfortunate limitation computer hardware functions like .equal() exist base R. Unfortunately, isn’t base function available specific comparisons want perform, manually . , need tolerance value use default tolerance used .equal():","code":"plot_maze <- function(map, title, colors) {   # start = 1 (top left), finish = last element (bottom right)   sf <- terra::xyFromCell(map, c(1, ncell(map)))    plot(map, main = title, col = colors, axes = FALSE, asp = 1)   plot(as.polygons(map, dissolve = FALSE), border = 'black', lwd = 1, add = TRUE)   points(sf, pch = c('S', 'F'), cex = 1, font = 2) } # A simple color palette with 2 colors vir_col <- viridis(3)[2:3] maze_res <- samc::example_maze  maze_res <- samc::rasterize(maze_res) maze_res[maze_res==0] <- NA # 0 makes the formatting cleaner above, but NA is needed for true barriers  # Get info about the shortest path through the maze using gdistance lcd <- (function() {   points <- xyFromCell(maze_res, c(1, 400))    tr <- transition(raster(maze_res), function(x) 1/mean(x), 4)   tr <- geoCorrection(tr)    list(dist = gdistance::costDistance(tr, points),        path = shortestPath(tr, points[1, ], points[2, ], output=\"SpatialLines\")) })()  # Basic maze layout plot_maze(maze_res, \"Resistance\", vir_col[1]) lines(lcd$path, col = vir_col[2], lw = 3) # End of the maze maze_finish <- maze_res * 0 maze_finish[20, 20] <- 1  plot_maze(maze_finish, \"Absorption\", vir_col) tolerance = sqrt(.Machine$double.eps) # Default tolerance in functions like all.equal()  print(tolerance) #> [1] 1.490116e-08"},{"path":"/articles/example-maze-part1.html","id":"create-the-samc-object","dir":"Articles","previous_headings":"","what":"Create the samc object","title":"Maze Part 1","text":"resistance absorption maps prepared, samc object can created: model represented samc object set assume simple random walk. “memory” past stop individual going back dead ends, ability “look ahead” see dead ends, individual always move different cell every time step. Note use four directions. prevents diagonal movements maze, turn important consequences short-term metrics (discussed later). start finish locations obtained samc object using locate() function. ’s important remember results xyFromCell() (used RasterLayer object) work samc objects. Although results functions may equivalent certain cases, generally equivalent used interchangeably.","code":"rw_model <- list(fun = function(x) 1/mean(x), dir = 4, sym = TRUE)  maze_samc <- samc(maze_res, maze_finish, model = rw_model)  maze_origin <- locate(maze_samc, data.frame(x = 1, y = 20)) maze_dest <- locate(maze_samc, data.frame(x = 20, y = 1))"},{"path":"/articles/example-maze-part1.html","id":"time-to-finish","dir":"Articles","previous_headings":"","what":"Time to finish","title":"Maze Part 1","text":"start determining long, average, expected single individual finish maze. Formally, survival() function calculates expected time absorption, since maze one absorption point representing finish point, means , example, survival() can interpreted expected time finish maze:  result vector expected time absorption, finish, every point maze, just top left start point. start location can used extract information vector: single point total absorption, like example, survival() cond_passage() nearly identical destination cond_passage() set point absorption (finish point): turns cell map corresponding finish point absorbing state; ’s still transient state. Absorption occurs one time step later individual removed maze since can’t go anywhere else example. cond_passage() reports long takes reach final cell, survival() tells us long takes us reach final cell removed . couple things keep mind: - survival() different results different interpretation maze complicated scenarios multiple points absorption. - cond_passage() normally work states lead total absorption. exception single instance state leading total absorption present dest parameter set . case, absorption state effectively ignored. cond_passage() works shown example, attempting change dest parameter different location cause fail. cond_passage() can still used dest values, first, absorption value changed value less 1.","code":"maze_surv <- survival(maze_samc)  plot_maze(map(maze_samc, maze_surv), \"Expected time to finish\", viridis(256)) maze_surv[maze_origin] #> [1] 13869 maze_cond <- cond_passage(maze_samc, dest = maze_dest)  maze_cond[maze_origin] #> [1] 13868"},{"path":"/articles/example-maze-part1.html","id":"probability-of-visiting-a-cell","dir":"Articles","previous_headings":"","what":"Probability of visiting a cell","title":"Maze Part 1","text":"’re interested knowing probability particular cell (cells) visited least , can use dispersal() function:  complete maze, individual visit every cell along path exit, cells probability 1.0. farther away path cell located, lower probability visited. Additionally, closer individual gets finish, less likely spend time taking incorrect routes stumbling upon finish. ’s also possibility scenarios like one individual near finish manages stumble back start. different aspects contribute time spent near start point, average, turn means cells near start higher probability visited. previous paragraph hinted results dispersal() function can used identify route maze:  Like survival() function, important caveat: visitation probabilities don’t include time 0. looks like starting cell might probability 1 first figure, ’s slightly less just wasn’t apparent color scale:","code":"maze_disp <- dispersal(maze_samc, origin = maze_origin) #>  #> Cached diagonal not found. #> Performing setup. This can take several minutes... Complete. #> Calculating matrix inverse diagonal... #> Computing: 100% (done)                          #> Complete                                                       #> Diagonal has been cached. Continuing with metric calculation...  plot_maze(map(maze_samc, maze_disp), \"Probability of Visit\", viridis(256)) # Ideally would use `as.numeric(maze_disp == 1)`, but floating point precision issues force an approximation maze_disp_sol <- as.numeric(abs(maze_disp - 1) < tolerance)  plot_maze(map(maze_samc, maze_disp_sol), \"Solution Using Dispersal()\", vir_col) maze_disp[maze_origin] #> [1] 0.9864865"},{"path":"/articles/example-maze-part1.html","id":"visits-per-cell","dir":"Articles","previous_headings":"","what":"Visits per cell","title":"Maze Part 1","text":"package can used see many times cell maze expected visited average. done using visitation() metric:  Since finish point leads total absorption, visited :","code":"maze_visit <- visitation(maze_samc, origin = maze_origin)  plot_maze(map(maze_samc, maze_visit), \"Visits Per Cell\", viridis(256)) maze_visit[maze_dest] #> [1] 1"},{"path":"/articles/example-maze-part1.html","id":"expected-location","dir":"Articles","previous_headings":"","what":"Expected location","title":"Maze Part 1","text":"Using distribution() function, location individual maze can predicted given time:  ’s odd pattern can emphasized incrementing time 20 21:  Earlier mentioned using 4 directions transition function consequences. Without either diagonal transitions form fidelity (possibility individual moving), alternating pattern cell can occupied. ’s easiest reason effect running function time steps 1-5 visualizing , exercise left interested.","code":"maze_dist <- distribution(maze_samc, origin = maze_origin, time = 20)  plot_maze(map(maze_samc, maze_dist), \"Location at t=20\", col = viridis(256)) maze_dist <- distribution(maze_samc, origin = maze_origin, time = 21)  plot_maze(map(maze_samc, maze_dist), \"Location at t=21\", viridis(256))"},{"path":"/articles/example-maze-part1.html","id":"other-metrics","dir":"Articles","previous_headings":"","what":"Other metrics","title":"Maze Part 1","text":"couple metrics covered yet: absorption() mortality(). example provide thus far, don’t anything useful. mortality() report 100% probability absorption finish point; useful multiple locations absorption probabilities. absorption() useful different types absorption.","code":""},{"path":"/articles/example-maze-part1.html","id":"occupancy","dir":"Articles","previous_headings":"","what":"Occupancy","title":"Maze Part 1","text":"Many metrics offer advanced flexible option setting initial state absorbing Markov chain. Inputs init parameter (short initial state) can essentially used alternative specifying singular start point. example init map represents scenario presented far:  Using survival() metric, produces result : now, interesting scenarios can tested. example, let’s start maze 3 individuals: interpretation becomes little trickier . survival() metric returning cumulative time spent maze individuals. means 3 individuals starting beginning, 3 times much time going spent maze, per individual, still take number time steps finish : ’s different scenario 3 individuals , now start different corners maze:  , cumulative time spent maze larger reported original scenario one individual. However, time average time per individual spent maze decreases: additional individuals now located corners substantially closer finish point, expected find faster average. Based individual starts, reasonable expect individual starting bottom left biggest advantage. One way try visualize distrbution() metric:  good exercise reader apply concepts animations vignette figure.","code":"maze_init <- maze_res * 0 maze_init[1, 1] <- 1  plot_maze(maze_init, \"Occupancy\", vir_col) survival(maze_samc, init = maze_init) #> [1] 13869  maze_surv[maze_origin] #> [1] 13869 # Scenario 1: 3 people start in the maze maze_init3 <- maze_res * 0 maze_init3[1, 1] <- 3  survival(maze_samc, init = maze_init3) #> [1] 41607 survival(maze_samc, init = maze_init3) / 3 #> [1] 13869 # Scenario 2: A person starts in each corner of the maze maze_init3 <- maze_res * 0 maze_init3[1, 1] <- 1 maze_init3[20, 1] <- 1 maze_init3[1, 20] <- 1  plot_maze(maze_init3, \"Occupancy\", vir_col)  survival(maze_samc, init = maze_init3) #> [1] 21949 survival(maze_samc, init = maze_init3) / 3 #> [1] 7316.333 maze_init3_dist <- distribution(maze_samc, init = maze_init3, time = 17)  # This makes it easier to see how far along the individuals could be maze_init3_dist <- as.numeric(maze_init3_dist > 0)  plot_maze(map(maze_samc, maze_init3_dist), \"Location at t=17\", viridis(256))"},{"path":"/articles/example-maze-part1.html","id":"future-parts","dir":"Articles","previous_headings":"","what":"Future parts","title":"Maze Part 1","text":"future parts, many different modifications made maze explore change results different metrics different metrics related. modifications include use fidelity simulate scenarios individual pauses think next decision, modifying resistance input simulate “looking ahead” perform dead-end avoidance, modifying absorption input simulate different sources absorption lethal traps.","code":""},{"path":"/articles/example-maze-part2.html","id":"introduction","dir":"Articles","previous_headings":"","what":"Introduction","title":"Maze Part 2","text":"Part 1 series explored applications absorbing Markov chains context simple perfect maze. part series expand simple maze various ways explore changes affect interpretations different metrics offered samc package. complete code series available Github.","code":""},{"path":"/articles/example-maze-part2.html","id":"setup","dir":"Articles","previous_headings":"","what":"Setup","title":"Maze Part 2","text":"Part 2 reuses code Part 1.","code":""},{"path":"/articles/example-maze-part2.html","id":"fidelity","dir":"Articles","previous_headings":"","what":"Fidelity","title":"Maze Part 2","text":"first change explored part incorporation fidelity samc object. Part 1, transitions always occurred one cell different neighboring cell. fidelity, transitions can occur cell ; essentially, ’s movement time step. potentially many different ways fidelity applied maze, simplicity, example keep things simple using create delay movement intersections. goal model “hesitation” individual presented choice three paths. additional simplicity, intersections treated assigned fidelity probability 0.1, means individual intersection, 10% probability stay intersection one time step next.  Fidelity changes PP matrix underlying samc object, means samc object recreated: start, let’s see new fidelity input affects expected time finish: Intuitively, “hesitation” added movement, expected time finish increases. Also, note incorporating fidelity particular example affect relationship survival() cond_passage(). terms probability visiting particular cell, changing fidelity change results Part 1: Fidelity , however, change number times cell expected visited:  fidelity present, intersections seeing significantly different number visits. Since “visit” effectively represents transition cell one time step next, presence fidelity means metric counting transitions cell well. Interestingly, compared figure Part 1, legend figure seems indicate increase intersections might 10%, fidelity probabilities. also seems like non-intersections (cells fidelity probability 0.0) experienced change. Let’s check ideas:  turns change number expected visits non-intersections. also turns hunch intersections partially true; change constant, ’s 1/9 instead 0.1 10%. interesting change incorporating fidelity might distribution() metric. Recall Part 1 alternating pattern cells changing time steps. fidelity, effect still exists, degree:  Given sufficient amount time, cumulative effect fidelity present almost entirely eliminate pattern. Even time steps 200-201, alternating pattern visually nearly gone:  comparison, ’s original samc object using time steps:","code":"# Intersections determined using a moving window function ints_res <- focal(maze_res,                   w = matrix(c(NA, 1, NA, 1, 1, 1, NA, 1, NA), nrow = 3, ncol = 3),                   fun = function(x) {sum(!is.na(x)) > 3})  ints_res[is.na(maze_res)] <- NA ints_res <- ints_res * 0.1  plot_maze(ints_res, \"Intersections\", vir_col) ints_samc <- samc(maze_res, maze_finish, ints_res, model = rw_model) # Original results from Part 1 survival(maze_samc)[maze_origin] #> [1] 13869 cond_passage(maze_samc, origin = maze_origin, dest = maze_dest) #> [1] 13868  # Results with fidelity at intersections survival(ints_samc)[maze_origin] #> [1] 14356 cond_passage(ints_samc, origin = maze_origin, dest = maze_dest) #> [1] 14355 ints_disp <- dispersal(ints_samc, origin = maze_origin) #>  #> Cached diagonal not found. #> Performing setup. This can take several minutes... Complete. #> Calculating matrix inverse diagonal... #> Computing: 100% (done)                          #> Complete                                                       #> Diagonal has been cached. Continuing with metric calculation...  all.equal(maze_disp, ints_disp) #> [1] TRUE ints_visit <- visitation(ints_samc, origin = maze_origin)  all.equal(maze_visit, ints_visit) #> [1] \"Mean relative difference: 0.03511428\"  # Let's plot the difference to see if there is a noticeable pattern visit_diff <- map(maze_samc, ints_visit) - map(maze_samc, maze_visit) plot_maze(visit_diff, \"Visits Per Cell (Difference)\", viridis(256)) # First, let's see which cells changed. # Ideally would just use `visit_diff > 0`, but floating point precision issues force an approximation plot_maze(visit_diff > tolerance, \"Visits With Non-Zero Difference\", vir_col)  # Second, let's see what the percent change is for our non-zero differences. visit_perc <- (ints_visit - maze_visit) / maze_visit visit_perc[visit_perc>tolerance] #>  [1] 0.1111111 0.1111111 0.1111111 0.1111111 0.1111111 0.1111111 0.1111111 #>  [8] 0.1111111 0.1111111 0.1111111 0.1111111 0.1111111 0.1111111 0.1111111 #> [15] 0.1111111 0.1111111 0.1111111 0.1111111 0.1111111 0.1111111 0.1111111 #> [22] 0.1111111 0.1111111 0.1111111 0.1111111 0.1111111 0.1111111 0.1111111 #> [29] 0.1111111 0.1111111 0.1111111 0.1111111 0.1111111 0.1111111 0.1111111 #> [36] 0.1111111 0.1111111 0.1111111 0.1111111 0.1111111 0.1111111 0.1111111 #> [43] 0.1111111 ints_dist <- distribution(ints_samc, origin = maze_origin, time = 20) plot_maze(map(ints_samc, ints_dist), \"Location at t=20\", viridis(256))  ints_dist <- distribution(ints_samc, origin = maze_origin, time = 21) plot_maze(map(ints_samc, ints_dist), \"Location at t=21\", viridis(256)) ints_dist <- distribution(ints_samc, origin = maze_origin, time = 200) plot_maze(map(ints_samc, ints_dist), \"Location at t=200\", viridis(256))  ints_dist <- distribution(ints_samc, origin = maze_origin, time = 201) plot_maze(map(ints_samc, ints_dist), \"Location at t=201\", viridis(256)) maze_dist <- distribution(maze_samc, origin = maze_origin, time = 200) plot_maze(map(maze_samc, maze_dist), \"Location at t=200\", viridis(256))  maze_dist <- distribution(maze_samc, origin = maze_origin, time = 201) plot_maze(map(maze_samc, maze_dist), \"Location at t=201\", viridis(256))"},{"path":"/articles/example-maze-part2.html","id":"dead-end-avoidance","dir":"Articles","previous_headings":"","what":"Dead-End Avoidance","title":"Maze Part 2","text":"Technically, package doesn’t offer ability “look ahead” future states adjust transition probabilities. words, route eventually lead dead end, ’s nothing samc() function metric functions account model possibility individual maze can see hallway. can, however, faked somewhat adjusting resistance map dead ends much higher resistance. reduce probability individual entering dead end, almost looked ahead. sliding window function can used create new map:  dead ends assigned resistance value 10, relatively high means dead ends rarely entered. Since resistance map modified, samc object need recreated. fidelity data previous section used, allow direct comparisons model created Part 1. Hypothetically, since individual can now “look ahead”, able get maze faster spending less time dead ends. easily verified: Since dead ends lower probability transitioned , dispersal() visitation() metrics reflect :  effect obvious expected number visits visitation(); probability illustration subtle compared original results Part 1. explored similarly differences fidelity section illustrated, exercise left interested readers.","code":"# Dead ends ends_res <- focal(maze_res,                   w = matrix(c(NA, 1, NA, 1, 1, 1, NA, 1, NA), nrow = 3, ncol = 3),                   fun = function(x){sum(!is.na(x)) == 2}) ends_res[is.na(maze_res)] <- NA ends_res <- ends_res * 9 + 1 ends_res[20, 20] <- 1  plot_maze(ends_res, \"Dead Ends\", vir_col) ends_samc <- samc(ends_res, maze_finish, model = rw_model) # Original results from Part 1 survival(maze_samc)[maze_origin] #> [1] 13869 cond_passage(maze_samc, origin = maze_origin, dest = maze_dest) #> [1] 13868  # Results with dead ends survival(ends_samc)[maze_origin] #> [1] 11313 cond_passage(ends_samc, origin = maze_origin, dest = maze_dest) #> [1] 11312 ends_disp <- dispersal(ends_samc, origin = maze_origin) #>  #> Cached diagonal not found. #> Performing setup. This can take several minutes... Complete. #> Calculating matrix inverse diagonal... #> Computing: 100% (done)                          #> Complete                                                       #> Diagonal has been cached. Continuing with metric calculation... plot_maze(map(maze_samc, ends_disp), \"Probability of Visit\", viridis(256))  ends_visit <- visitation(ends_samc, origin = maze_origin) plot_maze(map(maze_samc, ends_visit), \"Visits Per Cell\", viridis(256))"},{"path":"/articles/example-maze-part2.html","id":"traps","dir":"Articles","previous_headings":"","what":"Traps","title":"Maze Part 2","text":"’s fairly trivial add lethal traps maze updating absorption input samc() function. key thing keep mind samc() function expects total absorption, provided single absorption input. However, package can used tease apart role different sources absorption model. two different approaches setting : Start single total absorption input. take input decompose multiple absorption components. Start multiple absorption components. take inputs combine single total absorption input. choice depends data available goals project. example, first strategy useful ’ve somehow measured total absorption model want explore different hypotheses breaks different types absorption. second useful already direct knowledge different sources absorption. example take second approach. One absorption component already created finish point. second simple absorption component created represents traps 0.2 20% absorption probability:  Since total absorption sum two components, samc object recreated: easy comparison, everything else kept original example Part 1. Continuing previous strategy, let’s start determining long expected individual finish maze: results drastically different seen . First, clear relationship survival() cond_passage() longer exists. survival() different interpretation context longer determines long take finish; instead, now calculates long take individual either finish absorbed one traps (.e., die). also drastically changes plotting results survival() (note change figure title Part 1 reflect new interpretation):  results also drastically different Part 1 looking visitation probability number visits:  Importantly, technique Part 1 using visitation probabilities 1.0 identify route maze work example; works specialized cases. reason simple: since individual can now absorbed locations, non-zero probability never reach finish, turn means probability visiting finish now less 1.0. However, technique can used see something interesting:  shows part solution observed , first maze intersection leads two possible sources absorption.","code":"# Traps absorption layer maze_traps <- maze_res * 0 maze_traps[17, 3] <- 0.2 maze_traps[1, 9] <- 0.2 maze_traps[6, 20] <- 0.2  plot_maze(maze_traps, \"Traps\", vir_col) maze_abs_total <- maze_finish + maze_traps  traps_samc <- samc(maze_res, maze_abs_total, model = rw_model) # Original results from Part 1 survival(maze_samc)[maze_origin] #> [1] 13869 cond_passage(maze_samc, origin = maze_origin, dest = maze_dest) #> [1] 13868  # Results with traps survival(traps_samc)[maze_origin] #> [1] 1330.26 cond_passage(traps_samc, origin = maze_origin, dest = maze_dest) #> [1] 3060.207 traps_surv <- survival(traps_samc)  # Note the updated title from part 1 plot_maze(map(maze_samc, traps_surv), \"Expected Time to Absorption\", viridis(256)) traps_disp <- dispersal(traps_samc, origin = maze_origin) #>  #> Cached diagonal not found. #> Performing setup. This can take several minutes... Complete. #> Calculating matrix inverse diagonal... #> Computing: 100% (done)                          #> Complete                                                       #> Diagonal has been cached. Continuing with metric calculation... plot_maze(map(traps_samc, traps_disp), \"Probability of Visit\", viridis(256))  traps_visit <- visitation(traps_samc, origin = maze_origin) plot_maze(map(traps_samc, traps_visit), \"Visits Per Cell\", viridis(256)) # Ideally, we would just use `as.numeric(traps_disp == 1)`, but we have floating point precision issues here, so we will approximate it traps_disp_route <- as.numeric(abs(traps_disp - 1) < tolerance)  plot_maze(map(traps_samc, traps_disp_route), \"dispersal() == 1\", vir_col)"},{"path":"/articles/example-maze-part2.html","id":"additional-metrics","dir":"Articles","previous_headings":"","what":"Additional metrics","title":"Maze Part 2","text":"inclusion multiple absorption states makes metrics useful Part 1 relevant. Starting mortality(), possible visualize individual expected absorbed:  result quite possibly unexpected. finish point look like ’s 0? Looking numbers might provide insight: ’s 3.0% chance individual finishing maze! might seem low given traps lethal 20% time, makes sense. Recall Probability visiting cell Visits per cell sections Part 1; individual spends time early part maze. means lot exposure first trap , consequently, likely absorbed 85.2% probability. trap farthest start, reaching first requires passing finish, consequently, 0.39% source absorption, substantially lower probability just finishing maze. possible break total absorption role different sources absorption can investigated easily. Now samc object created, can provided original absorption layers used calculate total absorption: , mortality() metric now returns list information just total absorption, individual components well. allows role different types absorption individually accessed visualized:  multiple sources absorption now specified samc object, absorption() metric becomes relevant: output quite simple: probability individual experience particular type absorption. seen , 3.0% chance finishing maze. absorption() also shows 97.0% total probability absorption occur one three traps. different mortality() metric, calculates absorption probabilities cell. clearly relationship two metrics, advantage example ’s easy see ; difficult see two metrics related complex situations.","code":"traps_mort <- mortality(traps_samc, origin = maze_origin)  plot_maze(map(traps_samc, traps_mort), \"Absorption Probability\", viridis(256)) traps_mort[traps_mort > 0] #> [1] 0.852084306 0.113761093 0.003940915 0.030213685  traps_mort[maze_dest] #> [1] 0.03021369 # Naming the rasters will make things easier and less prone to user error later names(maze_finish) <- \"Finish\" names(maze_traps) <- \"Traps\"  traps_samc$abs_states <- c(maze_finish, maze_traps) traps_mort_dec <- mortality(traps_samc, origin = maze_origin)  str(traps_mort_dec) #> List of 3 #>  $ total : num [1:215] 0 0 0 0 0.852 ... #>  $ Finish: num [1:215] 0 0 0 0 0 0 0 0 0 0 ... #>  $ Traps : num [1:215] 0 0 0 0 0.852 ...  plot_maze(map(traps_samc, traps_mort_dec$Finish), \"Absorption Probability (Finish)\", viridis(256)) plot_maze(map(traps_samc, traps_mort_dec$Traps), \"Absorption Probability (Traps)\", viridis(256)) absorption(traps_samc, origin = maze_origin) #>     Finish      Traps  #> 0.03021369 0.96978631"},{"path":"/articles/example-maze-part2.html","id":"part-3","dir":"Articles","previous_headings":"","what":"Part 3","title":"Maze Part 2","text":"next part example series take maze single solution modify “secret” shortcut. Wrapping example, Part 3 take changes introduced series combine single final example.","code":""},{"path":"/articles/example-maze-part3.html","id":"introduction","dir":"Articles","previous_headings":"","what":"Introduction","title":"Maze Part 3","text":"third part series takes perfect maze single solution modifies now one solution. Afterward, changes introduced series combined single complex example. complete code series available Github.","code":""},{"path":"/articles/example-maze-part3.html","id":"setup","dir":"Articles","previous_headings":"","what":"Setup","title":"Maze Part 3","text":"Part 3 reuses code Part 1 Part 2.","code":""},{"path":"/articles/example-maze-part3.html","id":"shortcut","dir":"Articles","previous_headings":"","what":"Shortcut","title":"Maze Part 3","text":"start, original maze modified new cell bridging previously existing cells. location chosen effectively acts shortcut previous solution. make things interesting, treated secret passage giving high resistance value rarely utilized. effectively method used model dead-end avoidance Part 2, interpretation different high resistance located.  Use gdistance quickly verify change distance shortest solution: Since structure resistance input changed, absorption input also changed structure: new resistance absorption inputs, samc object recreated: important thing keep mind: modifying NA non-NA cells located map means previous results locate() longer guaranteed valid. case, start technically , finish return incorrect results, special cases even lead crash. , let’s begin exploring different metrics compare results Part 1. Starting survival():  two noticeable changes. First, expected time finish drastically decreased starting point: second change overall increase expected time finish individual bottom left region maze shortcut can lead away finish point region. shortcut asymmetric (.e., one way), still drastic decrease time finish starting point, bottom left region remain unchanged original maze. type model setup possible package, without directly providing P matrix. Graph support future make complex scenarios like one-way shortcut easier set . Part 2 showed inclusion additional absorbing states changes relationship survival() cond_passage(). Since example back single absorbing state finish point, relationship restored: Part 2 also showed including additional absorbing states affects probability cells visited. Modifying maze multiple routes also significant ramifications:  Notably, longer possible discern optimal route maze looking cells probability 1.0. , like Part 2, partial path can still identified:  case, result contains solution regions loop created shortcut.","code":"# Create a copy and add a shortcut short_res <- maze_res short_res[16, 6] <- 10  # Get info about the shortest path through the new maze using gdistance lcd2 <- (function() {   points <- xyFromCell(short_res, c(1, 400))    tr <- transition(raster(short_res), function(x) 1/mean(x), 4)   tr <- geoCorrection(tr)    list(dist = gdistance::costDistance(tr, points),        path = shortestPath(tr, points[1, ], points[2, ], output=\"SpatialLines\")) })()   plot_maze(short_res, \"Shortcut Maze\", vir_col) lines(lcd2$path, col = vir_col[2], lw = 3) # Let's see what the difference in distance is lcd2$dist - lcd$dist #>    1 #> 2 -9 # Our old absorption layer does not quite match our new resistance layer, so make a new one short_finish <- short_res * 0 short_finish[20, 20] <- 1 short_samc <- samc(short_res, short_finish, model = rw_model)  # Important: we have to rerun locate() short_origin <- locate(short_samc, data.frame(x = 1, y = 20)) short_dest <- locate(short_samc, data.frame(x = 20, y = 1)) short_surv <- survival(short_samc)  plot_maze(map(short_samc, short_surv), \"Expected time to finish (Shortcut Maze)\", viridis(256)) # Expected time to finish from the start short_surv[maze_origin] #> [1] 9022.974  # The difference from our original maze short_surv[maze_origin] - maze_surv[maze_origin] #> [1] -4846.026 short_cond <- cond_passage(short_samc, dest = short_dest) short_cond[maze_origin] #> [1] 9021.974 short_disp <- dispersal(short_samc, origin = short_origin) #>  #> Cached diagonal not found. #> Performing setup. This can take several minutes... Complete. #> Calculating matrix inverse diagonal... #> Computing: 100% (done)                          #> Complete                                                       #> Diagonal has been cached. Continuing with metric calculation...  plot_maze(map(short_samc, short_disp), \"Probability of Visit (Shortcut Maze)\", viridis(256)) # Ideally, we would just use `as.numeric(short_disp == 1)`, but we have floating point precision issues here, so we will approximate it short_disp_sol <- as.numeric(abs(short_disp - 1) < tolerance)  plot_maze(map(short_samc, short_disp_sol), \"Partial solution (Shortcut Maze)\", vir_col)"},{"path":"/articles/example-maze-part3.html","id":"combined-example","dir":"Articles","previous_headings":"","what":"Combined Example","title":"Maze Part 3","text":"far, variety changes original maze independently explored. Now, many combined complex model. First, resistance absorption inputs need updated:  unusual artifact present new resistance raster: shortcut leads former dead end, dead end resistance value increase probability individual turning around shortcut even though, perspective shortcut, dead end. However, approaching bottom, dead end still exists assume shortcut hidden. case asymmetric transition probabilities ideal solution, simplicity, leave things . Create new samc object: Following previous model changes, start looking expected time absorption:  Similar Part 2, presence additional absorbing states (traps), drastically changes result interpretation survival() metric. results similar part 2, presence shortcut increase access bottom left trap finish point. relative role isn’t clear, overall seem decrease time absorption. Next complete overview different results survival() cond_passage(): presence traps shortcut cumulative effect metrics; time absorption decreases, time conditional first passage (time finish assuming individual absorbed elsewhere). Comparing traps-version maze cumulative maze using mortality() metric shows introducing shortcut affects probability finishing maze vs absorbed traps: introduction shortcut, probability absorption two top traps reduced less time spent top portion maze relative now accessible bottom portion. Also, probability absorption bottom left trap increased order magnitude, accounting decrease top two traps. Finally, individual somewhat likely survive finish maze. Note numeric indexes later two points shifted one; due changing NA cell non-NA shortcut, related locate() rerun structure input(s) samc() changes. now, process exploring different metrics examples clear. example highlighted key metrics left user explore remaining metrics interested . Additionally, combined example left occupancy fidelity changes introduced previous parts; another opportunity readers practice making exploring modifications model.","code":"# Combine our previous resistance layers all_res <- max(c(short_res, ints_res, ends_res), na.rm = TRUE)  # For absorption, all we need is an updated version of our traps raster all_traps <- maze_traps all_traps[16, 6] <- 0  # Total absorption all_abs_total <- short_finish + all_traps   # If we had more variety in our resistance values we would want more colors plot_maze(all_res, \"Final Maze\", vir_col)  # Plot the traps raster plot_maze(all_traps, \"Final Maze Traps\", vir_col) all_samc <- samc(all_res, all_abs_total, model = rw_model)  # We can actually reuse the short_res locations in this case, but let's make new ones anyway all_start <- locate(all_samc, data.frame(x = 1, y = 20)) all_finish <- locate(all_samc, data.frame(x = 20, y = 1)) all_surv <- survival(all_samc)  # Note the updated title from part 1 plot_maze(map(all_samc, all_surv), \"Expected Time to Absorption\", viridis(256)) # Original results (Part 1) survival(maze_samc)[maze_origin] #> [1] 13869 cond_passage(maze_samc, origin = maze_origin, dest = maze_dest) #> [1] 13868  # Results with traps (Part 2) survival(traps_samc)[maze_origin] #> [1] 1330.26 cond_passage(traps_samc, origin = maze_origin, dest = maze_dest) #> [1] 3060.207  # Results with a shortcut survival(short_samc)[short_origin] #> [1] 9022.974 cond_passage(short_samc, origin = short_origin, dest = short_dest) #> [1] 9021.974  # Results with everything survival(all_samc)[all_start] #> [1] 968.4007 cond_passage(all_samc, origin = all_start, dest = all_finish) #> [1] 2000.364 traps_mort[traps_mort > 0] #> [1] 0.852084306 0.113761093 0.003940915 0.030213685  all_mort <- mortality(all_samc, origin = all_start) all_mort[all_mort > 0] #> [1] 0.81665446 0.08106988 0.05073905 0.05153661"},{"path":"/articles/example-maze-part3.html","id":"future-work","dir":"Articles","previous_headings":"","what":"Future Work","title":"Maze Part 3","text":"Parts series may rewritten, expanded , /reorganized future. Additionally, igraph support added package, series expanded example illustrating construction maze using graph rather matrix/raster.","code":""},{"path":"/articles/overview.html","id":"background","dir":"Articles","previous_headings":"","what":"Background","title":"Overview","text":"package provides series functions working absorbing Markov chains. Markov chain model consisting multiple states describes transitions occur states. absorbing Markov chain special kind Markov chain every state transient state can eventually reach one absorbing states. Absorbing states special type state left. Absorbing Markov chains can represented using PP matrix following structure: P=[QR0I] P = \\begin{bmatrix} Q & R \\\\ 0 & \\end{bmatrix}  : QQ matrix describes probability transition different transient states. Qi,jQ_{,j} probability transitioning transient state ii transient state jj. =ji=j, transition probability describing probability transient state stays doesn’t transition different transient state. RR matrix describes probability transitioning transient state absorbing state. Ri,kR_{,k} probability transitioning transient state ii absorbing state kk. 00 matrix filled zeros. rows correspond absorbing states kk, columns correspond transient states jj. represents absorbing state 0% probability transitioning transient state II identity matrix row column corresponds different absorbing states. main diagonal filled ones, everything else set zero. matrix represents absorbing state kk 100% probability transitioning (.e., state never change). combined, [0I]\\begin{bmatrix}0 & \\end{bmatrix} represents absorbing state entered, left transient state different absorbing state.","code":""},{"path":"/articles/overview.html","id":"the-samc-class","dir":"Articles","previous_headings":"","what":"The samc-class","title":"Overview","text":"samc-class used manage PP matrix information help ensure calculations used rest package used correctly. Creating samc-class object mandatory first step package, created using samc() utility function. creating PP matrix, samc() treats RR matrix portion single column containing total absorption probability transient state. samc() function several parameters provide many different options constructing PP matrix core samc-class.","code":""},{"path":"/articles/overview.html","id":"option-1-maps","dir":"Articles","previous_headings":"","what":"Overview","title":"Overview","text":"first option use map resistance (conductance) map total absorption list transition arguments calculate transition probabilities cells maps. certain requirements maps: must 2-dimensional matrices, RasterLayer, SpatRaster objects. different types mixed. inputs must dimensions (number rows columns). NA allowed cells, must match sets data. .e., cell [3, 6] resistance data NA value, cell [3, 6] absorption data must also NA value vice versa. using SpatRaster RasterLayer objects, additional conditions must met: sets data must coordinate extents. sets data must use coordinate reference system (CRS). optional fidelity map may provided. map represent probability transition timesteps (e.g., movement). default, package treats cells maps uses value 0 fidelity. used, fidelity map must meet requirements listed map inputs.","code":""},{"path":"/articles/overview.html","id":"option-2-p-matrix","dir":"Articles","previous_headings":"","what":"Overview","title":"Overview","text":"second option using package directly supply PP matrix. PP matrix can provided either regular matrix dgCmatrix, sparse matrix object available Matrix package. RR portion PP matrix must single column represents total absorption probability transient state. advantage approach total flexibility. disadvantage PP matrix can created certain properties lead crashes, package unable detect time. disadvantage package map results back anything visualization purposes.","code":""},{"path":"/articles/overview.html","id":"option-3-igraph","dir":"Articles","previous_headings":"","what":"Overview","title":"Overview","text":"future version package incorporate igraph support graph-based inputs. provide flexibility custom PP matrix, generally user-friendly construct, able perform thorough data checking avoid issues PP matrix, allow mapping results back graph visualization purposes.","code":""},{"path":"/articles/overview.html","id":"utility-functions","dir":"Articles","previous_headings":"","what":"Utility Functions","title":"Overview","text":"addition samc() function, package utility functions users might find helpful: check() function used check input map data meets data requirements outlined . can used compare two SpatRaster objects, two RasterLayer objects, two matrix objects, check either SpatRaster, RasterLayer, matrix already created samc-class object. can also used multilayer SpatRaster RasterStack check layers stack one another. map() function used simplify mapping vector results based input maps returns object data type used create samc-class object. provided R handles matrices raster layers somewhat differently reading writing vector data, can cause users map data incorrectly aren’t careful. also handles mapping NA values, another potential source error. locate() function used get cell numbers use origin dest values various analytical function arguments. function used instead cellFromXY() raster terra packages cellFromXY() cell numbers necessarily correspond cell numbers samc package (samc package assign cell numbers NA cells, whereas packages ). locate() function can used return map cell numbers encoded cell values simply excluding xy argument. case, map class type inputs samc() pairwise() function provided easily efficiently run specific metrics pairwise combinations start end locations.","code":""},{"path":"/articles/overview.html","id":"analytical-functions","dir":"Articles","previous_headings":"","what":"Analytical Functions","title":"Overview","text":"package implements functions formulas provided Table 1 Fletcher et al. (2019), well new ones since publication. Many formulas related conceptually grouped single functions multiple parameter signatures reduce number unique function names needed. Note descriptions assume ψ\\psi contains probabilities (see ). following descriptions written ecological context; function reference pages provide mathematically formal descriptions. Depending combination inputs used, function might return single value, vector, matrix, list. cases, calculations impractical sufficiently large landscape datasets due memory performance constraints. work around , many equations multiple associated function signatures allow users calculate individual portions result rather entire result. opens multiple optimizations make calculating many metrics practical. specific details performance considerations can found Performance vignette.","code":""},{"path":"/articles/overview.html","id":"initial-state-data","dir":"Articles","previous_headings":"","what":"Initial State Data","title":"Overview","text":"Several analytical functions allow input initial state ψ\\psi Markov chain via init parameter. descriptions analytical functions assume values ψ\\psi sum one. case, ψi\\psi_i represents probability Markov chain starts transient state ii. values ψ\\psi sum value one, care must taken interpretation results. example, ψ\\psi used represent population individuals ψi\\psi_i represents number individuals start transient state ii. case, results functions using ψ\\psi aren’t probabilities, rather expected number individuals.","code":""},{"path":"/articles/overview.html","id":"built-in-example-data","dir":"Articles","previous_headings":"","what":"Built-in Example Data","title":"Overview","text":"package includes built-example map data. data used create figures SAMC paper used numerous package tutorials. res: matrix landscape resistance data. abs: matrix landscape absorption (mortality) data. init: matrix initial starting locations.","code":"str(samc::example_split_corridor) #> List of 3 #>  $ res : num [1:34, 1:202] NA NA NA NA NA NA NA NA NA NA ... #>  $ abs : num [1:34, 1:202] NA NA NA NA NA NA NA NA NA NA ... #>  $ init: num [1:34, 1:202] NA NA NA NA NA NA NA NA NA NA ...  res_data <- samc::example_split_corridor$res abs_data <- samc::example_split_corridor$abs init_data <- samc::example_split_corridor$init  plot(rasterize(res_data), main = \"Example Resistance Data\", xlab = \"x\", ylab = \"y\", col = viridis(256)) plot(rasterize(abs_data), main = \"Example Absorption Data\", xlab = \"x\", ylab = \"y\", col = viridis(256)) plot(rasterize(init_data), main = \"Example Starting Location Data\", xlab = \"x\", ylab = \"y\", col = viridis(256))"},{"path":"/articles/parallel.html","id":"introduction","dir":"Articles","previous_headings":"","what":"Introduction","title":"Parallel Computing","text":"v2.0.0, samc package support use multiple cores parallelization. Currently, feature targeted towards dispersal() function dispersal(samc, init) option. function particularly useful severe performance limitation explained Performance vignette. Fortunately, particular case suitable parallelization, means multiple cores can used drastically reduce runtime analysis. feature well established, recommended users compare results non-parallel version parallel version. can done efficiently using scaled-version input data. results scaled-data verified, parallel version can run larger full dataset. testing, samc object (create using samc()) recreated. , analysis use cached results previous run. ’s also important aware distinction cores threads. Roughly, cores physical units processor perform computations. thread can thought set instructions run core. general, core always able run one thread time. case, example, 4-core processor can run 4 threads. Sometimes, depending processor features (e.g., Intel Hyperthreading), core can execute two threads . case, 4-core processor used run 8 threads simultaneously. means can potentially break workload threads cores. However, works well certain types workloads may scale well situations.","code":""},{"path":"/articles/parallel.html","id":"enabling-parallelization","dir":"Articles","previous_headings":"","what":"Enabling Parallelization","title":"Parallel Computing","text":"enable parallelization, just set number threads positive integer greater one: ’s . function supports parallelization, now make use multiple threads (4 example).","code":"# Assume samc_obj was created using samc()  samc_obj$threads <- 4 #> Important: When setting the number of threads, make sure to use a reasonable number for the machine the code will run on. #> Using the maximum number of threads supported by your hardware can make other programs non-responsive. Only do this if nothing else needs to run during the analysis. #> Specifying more threads than a machine supports in hardware will likely lead to lost performance."},{"path":"/articles/parallel.html","id":"limitations","dir":"Articles","previous_headings":"","what":"Limitations","title":"Parallel Computing","text":"general, using cores solve problem scale perfectly. addition, can diminishing returns number cores used increases. Multiple factors play . Users high core count machines (e.g., 32, 64, 128 cores) may find using cores provide significant benefit moderate amount cores. way know sure benchmark analysis different core counts. general, using cores means additional memory need used solve problem. severity memory increase vary depending problem. case dispersal(), memory requirement additional cores used fairly minimal. means long machines reasonable amount memory per core, issue. use cores machine , can negatively affect performance software running. Therefore, need use machine tasks analysis running, likely need restrict many cores use. users access supercomputing resources, running parallel analysis across different nodes requires advanced features available package. Therefore, samc analyses run single node supercomputers.","code":""},{"path":"/articles/performance.html","id":"introduction","dir":"Articles","previous_headings":"","what":"Introduction","title":"Performance","text":"document provides details different performance aspects package. two general issues users aware : computation time memory (RAM) usage. Computation time straightforward two. Basically, size landscape data increases, amount time takes calculations run also increase. Additionally, many functions time parameter calculating short-term metrics. time parameter increases, users expect proportional increase computation time (important caveat discussed ). recommended strategy users initially use low resolution version landscape data low time inputs initially writing verifying scripts. allows users incrementally test things satisfied everything working correctly without needing wait long periods time testing. , ready, can start using final inputs, even first incrementally increasing size data time parameters way gauge long final analysis take complete. complex issue RAM usage. calculations involve matrix calculations can consume large amounts memory. cases, calculations can optimized avoid memory intensive calculations, cases unavoidable, limit functions package can used. important users aware limitations function wish use. Failing may result excessive RAM utilization. cases, analysis may still run using hard drive additional RAM, slow analysis one three orders magnitude, can cause disk wear particularly detrimental solid state drives (SSDs). Otherwise, analysis likely crash R, potentially causing loss work. Writing initial analysis using scaled versions user’s landscape data, later incrementally increasing resolution one approach determining possible run user’s system.","code":""},{"path":"/articles/performance.html","id":"transition-matrix","dir":"Articles","previous_headings":"","what":"Transition Matrix","title":"Performance","text":"calculations performed package make use transition matrix generated using landscape data. Technically, size transition matrix grows quadratically number cells landscape data, meaning can quickly consume computer’s available memory (RAM). following figure illustrates , even million landscape cells (1000x1000 raster without missing data) requires ~7500 GB RAM, 1000x typically available modern consumer computers.  Fortunately, initial transition matrix sparse (contains value 0 majority cells). allows way stored RAM optimized amount memory consumes grows linearly number cells landscape data. practice, means transition matrix takes significantly less RAM. Using 1000x1000 landscape raster (one million landscape cells) example, transition matrix can condensed less 0.15 GB RAM.","code":""},{"path":"/articles/performance.html","id":"calculations","dir":"Articles","previous_headings":"","what":"Calculations","title":"Performance","text":"Creating large transition matrix longer limiting factor terms memory, issues still arise transition matrix used calculations. calculations involving transition matrix, calculating inverse, produce dense matrix stored similarly optimized manner. Instead, dense matrix memory requirement first figure . calculations quickly become impractical even moderately-low amounts landscape data. following figure illustrates many landscape cells practical consumer hardware calculations involved. ideal circumstances; practice, one dense matrix may need memory time perform calculations.  Many equations SAMC paper perform calculations. cases completely unavoidable. Fortunately, cases, possible refactor equations avoid particular calculations, use math techniques tools limits downside.","code":""},{"path":"/articles/performance.html","id":"solvers","dir":"Articles","previous_headings":"","what":"Solvers","title":"Performance","text":"many different algorithms solving systems linear equations computers. straightforward direct solvers, use sequence operations deliver exact solution (accounting rounding limitations hardware). Iterative solvers generate sequence improving approximate solutions criteria met (e.g., max time, max number iterations, min tolerance, etc). case transition matrices generated raster data, direct solvers appear generally significantly faster, require large amount memory process. contrast, iterative solvers appear slower general (depending structure data, might faster rare situations), substantially memory efficient. Prior version 3.0.0, samc package always used direct solver. version 3.0.0, direct solver still used default, now samc-class objects can now switched direct solver iterative solver. general, direct solver used possible, iterative solver used problem solved within memory constraints system. iterative solver samc runs error result within tolerance machine precision; words iterative solver 15-16 digits precision modern computers, limitation direct solver well. metrics samc depend linear solvers; short-term metrics, dispersal() affected choice solver.","code":""},{"path":"/articles/performance.html","id":"short-term-metrics","dir":"Articles","previous_headings":"","what":"Short-term Metrics","title":"Performance","text":"short-term metrics (functions number time steps specified) expected run time increases linearly number time steps (seen benchmarks ). Currently, limitation way numbers stored computer hardware causing calculations slow substantially large time steps (~47000 one test computer). suitable workaround identified, users recommended start analyses smaller numbers increase incrementally. Plotting incremental results may reveal large number time steps necessary order results stabilize /short-term metrics.","code":""},{"path":[]},{"path":"/articles/performance.html","id":"dispersalsamc-origin-dispersalsamc-init","dir":"Articles","previous_headings":"Special Cases","what":"dispersal(samc, origin) & dispersal(samc, init)","title":"Performance","text":"metrics optimized memory usage, due requirement calculating diag(F)diag(F), remain substantially slower solutions metrics. Additionally, number transient states increases, time compute result increases quadratically. calculated, however, result diag(F)diag(F) cached reused future runs metrics. first time running metrics particular samc-class object slow. Given slow calculating diag(F)diag(F) can , progress updates provided different stages calculation. first stage involves matrix decomposition generally take less minutes, take several minutes large datasets. second stage far time consuming part calculation, time estimate periodically updated give users rough estimate long take complete. first time estimates tend inflated due low sampling time, improve update. calculation, software running computer can affect fast calculation runs, turn, lead changes time predictions. diag(F)diag(F) calculated, obtaining final result metrics take amount time comparable metrics. v1.5.0, functions support parallel computing reduce time required calculating diag(F)diag(F). See Parallel Computing vignette details.","code":""},{"path":"/articles/performance.html","id":"benchmarks","dir":"Articles","previous_headings":"","what":"Benchmarks","title":"Performance","text":"section includes automated benchmarks method optimized avoid memory issues. information primarily prioritizing future optimizations, published case users find helpful. benchmarking approach crude may occasional outliers result. Computation time vary quite lot different hardware.","code":""},{"path":"/articles/performance.html","id":"overall-performance","dir":"Articles","previous_headings":"Benchmarks","what":"Overall Performance","title":"Performance","text":"v3.0.0: needs updated Performance functions relative number landscape cells. short-term metrics, number time steps set 10000.","code":""},{"path":"/articles/performance.html","id":"overall-memory-usage","dir":"Articles","previous_headings":"Benchmarks","what":"Overall Memory Usage","title":"Performance","text":"Removed. profiling tools R measure memory consumed native code. words, figures showed memory used R parts code, C++ parts, caused memory consumption figures dramatically underestimate memory usage. external tool identified memory benchmarks redone future.","code":""},{"path":"/articles/performance.html","id":"temporal-performance","dir":"Articles","previous_headings":"Benchmarks","what":"Temporal Performance","title":"Performance","text":"v3.0.0: needs updated Performance short-term metrics varying number time steps. number landscape cells used benchmark 500,000.","code":""},{"path":"/articles/performance.html","id":"temporal-memory-usage","dir":"Articles","previous_headings":"Benchmarks","what":"Temporal Memory Usage","title":"Performance","text":"Removed. profiling tools R measure memory consumed native code. words, figures showed memory used R parts code, C++ parts, caused memory consumption figures dramatically underestimate memory usage. external tool identified memory benchmarks redone future.","code":""},{"path":"/articles/troubleshooting.html","id":"introduction","dir":"Articles","previous_headings":"","what":"Introduction","title":"Troubleshooting","text":"document lists common errors users might encounter address .","code":""},{"path":"/articles/troubleshooting.html","id":"error-in-rastercompareraster","dir":"Articles","previous_headings":"","what":"Error in raster::compareRaster","title":"Troubleshooting","text":"occur check() function detects different sources landscape data mismatched properties. variety reasons, including differing coordinate reference systems (CRS) using RasterLayers, differing dimensions, differing locations NA data. important thing aware package support mixing landscape data different types objects; landscape data used analysis must either matrices RasterLayers. includes occupancy data part creation samc-class object.","code":"# Working example r1 <- res_data r2 <- res_data check(r1, r2) #> [1] TRUE   # Remove the NA's in r2 by overwriting all the elements with the number 1. # check() doesn't check the actual values of the data, but it does check the # location of NA's r1 <- res_data r2 <- res_data r2[1] <- 1 check(r1, r2) #> Error: NA mismatch in input data   # Change the dimensions of r2 by subsetting it. check() ensures that the data # inputs have the same number of rows and columns r1 <- res_data r2 <- res_data r2 <- r2[1:5, 1:5] check(r1, r2) #> Error in h(simpleError(msg, call)): error in evaluating the argument 'a' in selecting a method for function 'check': [rast] extents do not match"},{"path":"/articles/troubleshooting.html","id":"unable-to-find-an-inherited-method","dir":"Articles","previous_headings":"","what":"Unable to find an inherited method","title":"Troubleshooting","text":"SAMC package makes use R’s S4 method dispatch system enforce different versions function can used. Hopefully, ensure users unintentionally misusing functions producing error rather letting code run returning result may obviously incorrect. error appears, means combination arguments provided function valid. couple different reasons. first optional parameter skipped without specifying argument names subsequent arguments. second user passing wrong type data argument (e.g., passing numeric function expects RasterLayer matrix).","code":"# Example: Skipping optional arguments. In this case, the `fidelity` argument is # optional, so we skip it. The model argument, however, is always required,  # so we pass the relevant to it. But because we don't specify which # argument it is, R is trying to find a version of the function that expects it # as the third argument, but this version does not exist. samc_obj <- samc(res_data, abs_data, list(fun = function(x) 1/mean(x), dir = 8, sym = TRUE)) #> Error: unable to find an inherited method for function 'samc' for signature 'data = \"matrix\", absorption = \"matrix\", fidelity = \"list\", model = \"missing\"'  # Solution samc_obj <- samc(res_data, abs_data, model = list(fun = function(x) 1/mean(x), dir = 8, sym = TRUE))   # Example: Incorrect input types. In this case, we are attempting to pass a # single numeric value as absorption data. However, the absorption data must  # always be in a matrix or RasterLayer object samc_obj <- samc(res_data, 0.01, model = list(fun = function(x) 1/mean(x), dir = 8, sym = TRUE)) #> Error: unable to find an inherited method for function 'samc' for signature 'data = \"matrix\", absorption = \"numeric\", fidelity = \"missing\", model = \"list\"'  # Solution samc_obj <- samc(res_data, abs_data, model = list(fun = function(x) 1/mean(x), dir = 8, sym = TRUE))"},{"path":"/articles/troubleshooting.html","id":"error-all-disconnected-regions-must-have-at-least-one-non-zero-absorption-value","dir":"Articles","previous_headings":"","what":"Error: All disconnected regions must have at least one non-zero absorption value","title":"Troubleshooting","text":"See Disconnected Data vignette.","code":""},{"path":"/articles/troubleshooting.html","id":"warning-input-contains-disconnected-regions--this-does-not-work-with-the-cond_passage-metric","dir":"Articles","previous_headings":"","what":"Warning: Input contains disconnected regions. This does not work with the cond_passage() metric","title":"Troubleshooting","text":"See Disconnected Data vignette.","code":""},{"path":"/articles/troubleshooting.html","id":"error-in-function-rcpp_precious_remove-not-provided-by-package-rcpp","dir":"Articles","previous_headings":"","what":"Error in <…> : function ‘Rcpp_precious_remove’ not provided by package ‘Rcpp’","title":"Troubleshooting","text":"Update Rcpp package. make sure unload packages reload . need load Rcpp package (.e, library(Rcpp)).","code":""},{"path":"/articles/tutorial-animations.html","id":"introduction","dir":"Articles","previous_headings":"","what":"Introduction","title":"Animations","text":"tutorial illustrates two different approaches creating animated plots temporal analyses. first using base plot tools R gifski package. second using gganimate (uses gifski hood). gganimate approach might user friendly two, appear mechanism available dynamically adjusting color scale frame, later frames appear dark probability values results decrease time (seen ). gifski package simply merges several different plots, color scale can different frame. can also used ggplot instead base plot users desire style ggplot dynamic color scales.","code":""},{"path":"/articles/tutorial-animations.html","id":"setup","dir":"Articles","previous_headings":"","what":"Setup","title":"Animations","text":"","code":"# First step is to load the libraries. Not all of these libraries are stricly # needed; some are used for convenience and visualization for this tutorial. library(\"samc\") library(\"raster\") library(\"ggplot2\") library(\"viridisLite\") library(\"gifski\") library(\"gganimate\")   # \"Load\" the data. In this case we are using data built into the package. # In practice, users will likely load raster data using the raster() function # from the raster package. res_data <- samc::example_split_corridor$res abs_data <- samc::example_split_corridor$abs   # Setup the details for our transition function rw_model <- list(fun = function(x) 1/mean(x), # Function for calculating transition probabilities                  dir = 8, # Directions of the transitions. Either 4 or 8.                  sym = TRUE) # Is the function symmetric?  # Create a samc object using the resistance and absorption data. We use the # recipricol of the arithmetic mean for calculating the transition matrix. Note, # the input data here are matrices, not RasterLayers. samc_obj <- samc(res_data, abs_data, model = rw_model)   # Calculate the probabilities of where an individual starting at specific # location will be for varying time steps. The starting location is going to # be cell 1 in the landscape, which is the first non-NA cell going in a # left-to-right then top-to-bottom order. time_steps <- ((1:50)*2) ^ 2  dist_list <- distribution(samc_obj, origin = 1, time = time_steps) dist_map <- map(samc_obj, dist_list)"},{"path":"/articles/tutorial-animations.html","id":"using-gifski","dir":"Articles","previous_headings":"","what":"Using gifski","title":"Animations","text":"","code":"png_path <- file.path(tempdir(), \"frame%03d.png\") png(png_path, width = 6, height = 3, units = \"in\", res = 100) par(ask = FALSE)  for (ts in time_steps) {   name <- as.character(ts)   plot(dist_map[[name]], main = paste(\"Individual Location at time step \", name), xlab = \"x\", ylab = \"y\", col = viridis(256)) }  dev.off() png_files <- sprintf(png_path, 1:length(time_steps)) gif_file <- tempfile(fileext = \".gif\") gifski(png_files, gif_file, delay = 0.1, progress = FALSE) unlink(png_files) utils::browseURL(gif_file)"},{"path":"/articles/tutorial-animations.html","id":"using-gganimate","dir":"Articles","previous_headings":"","what":"Using gganimate","title":"Animations","text":"","code":"# Create an empty dataframe to hold all the data from all the plots dist_df <- data.frame(x = numeric(0), y = numeric(0), layer = numeric(0), steps = numeric(0))  for (ts in time_steps) {   name <- as.character(ts)   dist <- as.data.frame(dist_map[[name]], xy = TRUE, na.rm = TRUE)   dist$steps <- ts    dist_df <- rbind(dist_df, dist) }   # Create the animation. Unfortunately, there does not appear to be a way to # adjust the color scale dynamically across frames using gganimate at this time anim <- ggplot(dist_df, aes(x = x, y = y)) +   geom_raster(aes(fill = layer)) +   transition_manual(steps) +   scale_fill_viridis(limits = c(0, max(dist_df$layer))) +   ggtitle(\"Individual Location at {current_frame}\") +   coord_equal() +   theme_bw()  animate(anim, duration = 5, height = 2, width = 6, units = \"in\", res = 150)"},{"path":"/articles/tutorial-basic.html","id":"introduction","dir":"Articles","previous_headings":"","what":"Introduction","title":"Basic Tutorial","text":"tutorial shows basics use package calculate visualize several metrics using map based inputs. utilizes package’s built-data, example data used Fletcher et al. (2019).","code":""},{"path":"/articles/tutorial-basic.html","id":"libraries","dir":"Articles","previous_headings":"","what":"Libraries","title":"Basic Tutorial","text":"","code":"# First step is to load the libraries. Not all of these libraries are stricly # needed; some are used for convenience and visualization for this tutorial. library(\"terra\") library(\"samc\") library(\"viridisLite\")"},{"path":"/articles/tutorial-basic.html","id":"load-the-data","dir":"Articles","previous_headings":"","what":"Load the Data","title":"Basic Tutorial","text":"","code":"# \"Load\" the data. In this case we are using data built into the package. # In practice, users will likely load raster data using the raster() function # from the raster package. res_data <- samc::example_split_corridor$res abs_data <- samc::example_split_corridor$abs init_data <- samc::example_split_corridor$init  # To make things easier for plotting later, convert the matrices to rasters res_data <- samc::rasterize(res_data) abs_data <- samc::rasterize(abs_data) init_data <- samc::rasterize(init_data)   # Plot the data and make sure it looks good. The built-in data is in matrices,  # so we use the raster() function to help with the plotting. Note that when # matrices are used by the package, it sets the extents based on the number of # rows/cols. We do the same thing here when converting to a raster, otherwise # the default extents will be (0,1) for both x and y, which is not only # uninformative, but can result in \"stretching\" when visualizing datasets # based non-square matrices. plot(res_data, main = \"Example Resistance Data\", xlab = \"x\", ylab = \"y\", col = viridis(256)) plot(abs_data, main = \"Example Absorption Data\", xlab = \"x\", ylab = \"y\", col = viridis(256)) plot(init_data, main = \"Example Occupancy Data\", xlab = \"x\", ylab = \"y\", col = viridis(256))"},{"path":"/articles/tutorial-basic.html","id":"create-the-samc-object","dir":"Articles","previous_headings":"","what":"Create the samc Object","title":"Basic Tutorial","text":"","code":"# Setup the details for our transition function rw_model <- list(fun = function(x) 1/mean(x), # Function for calculating transition probabilities                  dir = 8, # Directions of the transitions. Either 4 or 8.                  sym = TRUE) # Is the function symmetric?  # Create a `samc-class` object using the resistance and absorption data. We use the # recipricol of the arithmetic mean for calculating the transition matrix. Note, # the input data here are matrices, not RasterLayers. samc_obj <- samc(res_data, abs_data, model = rw_model)   # Print out the samc object and make sure everything is filled out. Try to # double check some of the values, such as the nrows/ncols of the landscape # data. The dimensions of the matrix (slot p) should be the number of non-NA # cells in your data +1. In this case, our data has 2624 non-NA cells, so the # matrix should be 2625 x 2625 str(samc_obj) #> Formal class 'samc' [package \"samc\"] with 15 slots #>   ..@ data      :Formal class 'samc_data' [package \"samc\"] with 3 slots #>   .. .. ..@ f    :Formal class 'dgCMatrix' [package \"Matrix\"] with 6 slots #>   .. .. .. .. ..@ i       : int [1:21612] 0 1 115 116 117 0 1 2 116 117 ... #>   .. .. .. .. ..@ p       : int [1:2625] 0 5 11 17 23 29 35 41 47 53 ... #>   .. .. .. .. ..@ Dim     : int [1:2] 2624 2624 #>   .. .. .. .. ..@ Dimnames:List of 2 #>   .. .. .. .. .. ..$ : NULL #>   .. .. .. .. .. ..$ : NULL #>   .. .. .. .. ..@ x       : num [1:21612] 1 -0.226 -0.138 -0.163 -0.104 ... #>   .. .. .. .. ..@ factors : list() #>   .. .. ..@ t_abs: num [1:2624] 2e-04 2e-04 2e-04 2e-04 2e-04 ... #>   .. .. ..@ c_abs: num[0 , 0 ]  #>   ..@ conv_cache: NULL #>   ..@ model     :List of 4 #>   .. ..$ fun :function (x)   #>   .. ..$ dir : num 8 #>   .. ..$ sym : logi TRUE #>   .. ..$ name: chr \"RW\" #>   ..@ source    : chr \"SpatRaster\" #>   ..@ nodes     : int 2624 #>   ..@ map       :S4 class 'SpatRaster' [package \"terra\"] #>   ..@ crw_map   : NULL #>   ..@ prob_mat  : NULL #>   ..@ names     : NULL #>   ..@ clumps    : int 1 #>   ..@ override  : logi FALSE #>   ..@ solver    : chr \"direct\" #>   ..@ threads   : num 1 #>   ..@ precision : chr \"double\" #>   ..@ .cache    :<environment: 0x560b4728daa0>"},{"path":"/articles/tutorial-basic.html","id":"basic-analysis","dir":"Articles","previous_headings":"","what":"Basic Analysis","title":"Basic Tutorial","text":"","code":"# Convert the initial state data to probabilities init_prob_data <- init_data / sum(values(init_data), na.rm = TRUE)   # Calculate short- and long-term mortality metrics and long-term dispersal short_mort <- mortality(samc_obj, init_prob_data, time = 4800) long_mort <- mortality(samc_obj, init_prob_data) long_disp <- dispersal(samc_obj, init_prob_data) #>  #> Cached diagonal not found. #> Performing setup. This can take several minutes... Complete. #> Calculating matrix inverse diagonal... #> Computing: 47%  (~11s remaining)       Computing: 95%  (~1s remaining)       Computing: 100% (done)                          #> Complete                                                       #> Diagonal has been cached. Continuing with metric calculation..."},{"path":"/articles/tutorial-basic.html","id":"visualization","dir":"Articles","previous_headings":"","what":"Visualization","title":"Basic Tutorial","text":"","code":"# Create rasters using the vector result data for plotting. short_mort_map <- map(samc_obj, short_mort) long_mort_map <- map(samc_obj, long_mort) long_disp_map <- map(samc_obj, long_disp)   # Plot the mortality and dispersal results plot(short_mort_map, main = \"Short-term Mortality\", xlab = \"x\", ylab = \"y\", col = viridis(256)) plot(long_mort_map, main = \"Long-term Mortality\", xlab = \"x\", ylab = \"y\", col = viridis(256)) plot(long_disp_map, main = \"Long-term Dispersal\", xlab = \"x\", ylab = \"y\", col = viridis(256))"},{"path":"/articles/tutorial-ggplot.html","id":"introduction","dir":"Articles","previous_headings":"","what":"Introduction","title":"ggplot Visualization","text":"tutorial shows plot samc analyses using ggplot2. based code basic tutorial.","code":""},{"path":"/articles/tutorial-ggplot.html","id":"setup","dir":"Articles","previous_headings":"","what":"Setup","title":"ggplot Visualization","text":"","code":"# First step is to load the libraries. Not all of these libraries are stricly # needed; some are used for convenience and visualization for this tutorial. library(\"terra\") library(\"samc\") library(\"ggplot2\")   # \"Load\" the data. In this case we are using data built into the package. # In practice, users will likely load raster data using the raster() function # from the raster package. res_data <- samc::example_split_corridor$res abs_data <- samc::example_split_corridor$abs init_data <- samc::example_split_corridor$init  # To make things easier for plotting later, convert the matrices to rasters res_data <- samc::rasterize(res_data) abs_data <- samc::rasterize(abs_data) init_data <- samc::rasterize(init_data)   # Setup the details for our transition function rw_model <- list(fun = function(x) 1/mean(x), # Function for calculating transition probabilities                  dir = 8, # Directions of the transitions. Either 4 or 8.                  sym = TRUE) # Is the function symmetric?  # Create a samc object using the resistance and absorption data. We use the # recipricol of the arithmetic mean for calculating the transition matrix. Note, # the input data here are matrices, not RasterLayers. samc_obj <- samc(res_data, abs_data, model = rw_model)   # Convert the initial state data to probabilities init_prob_data <- init_data / sum(values(init_data), na.rm = TRUE)   # Calculate short- and long-term mortality metrics and long-term dispersal short_mort <- mortality(samc_obj, init_prob_data, time = 4800) long_mort <- mortality(samc_obj, init_prob_data) long_disp <- dispersal(samc_obj, init_prob_data)   # Create rasters using the vector result data for plotting. short_mort_map <- map(samc_obj, short_mort) long_mort_map <- map(samc_obj, long_mort) long_disp_map <- map(samc_obj, long_disp)"},{"path":"/articles/tutorial-ggplot.html","id":"visualization-with-ggplot2","dir":"Articles","previous_headings":"","what":"Visualization With ggplot2","title":"ggplot Visualization","text":"","code":"# Convert the landscape data to RasterLayer objects, then to data frames for ggplot res_df <- as.data.frame(res_data, xy = TRUE, na.rm = TRUE) abs_df <- as.data.frame(abs_data, xy = TRUE, na.rm = TRUE) init_df <- as.data.frame(init_data, xy = TRUE, na.rm = TRUE)   # When overlaying the patch raster, we don't want to plot cells with values of 0 init_df <- init_df[init_df$lyr.1 != 0, ]   # Plot the example resistance and mortality data using ggplot res_plot <- ggplot(res_df, aes(x = x, y = y)) +   geom_raster(aes(fill = lyr.1)) +   scale_fill_viridis_c() +   geom_tile(data = init_df, aes(x = x, y = y, fill = lyr.1), fill = \"grey70\", color = \"grey70\") +   ggtitle(\"Resistance Data\") +   coord_equal() + theme_bw() print(res_plot)  abs_plot <- ggplot(abs_df, aes(x = x, y = y)) +   geom_raster(aes(fill = lyr.1)) +   scale_fill_viridis_c() +   geom_tile(data = init_df, aes(x = x, y = y, fill = lyr.1), fill = \"grey70\", color = \"grey70\") +   ggtitle(\"Absorption Data\") +   coord_equal() + theme_bw() print(abs_plot) # Convert result RasterLayer objects to data frames for ggplot short_mort_df <- as.data.frame(short_mort_map, xy = TRUE, na.rm = TRUE) long_mort_df <- as.data.frame(long_mort_map, xy = TRUE, na.rm = TRUE) long_disp_df <- as.data.frame(long_disp_map, xy = TRUE, na.rm = TRUE)   # Plot short-term mortality stm_plot <- ggplot(short_mort_df, aes(x = x, y = y)) +   geom_raster(aes(fill = lyr.1)) +   scale_fill_viridis_c() +   geom_tile(data = init_df, aes(x = x, y = y, fill = lyr.1), fill = \"grey70\", color = \"grey70\") +   ggtitle(\"Short-term Mortality\") +   coord_equal() + theme_bw() print(stm_plot)  # Plot long-term mortality ltm_plot <- ggplot(long_mort_df, aes(x = x, y = y)) +   geom_raster(aes(fill = lyr.1)) +   scale_fill_viridis_c() +   geom_tile(data = init_df, aes(x = x, y = y,fill = lyr.1), fill = \"grey70\", color = \"grey70\") +   ggtitle(\"Long-term Mortality\") +   coord_equal() + theme_bw() print(ltm_plot)  # Plot long-term dispersal ltd_plot <- ggplot(long_disp_df, aes(x = x, y = y)) +   geom_raster(aes(fill = lyr.1)) +   scale_fill_viridis_c() +   geom_tile(data = init_df, aes(x = x, y = y, fill = lyr.1), fill = \"grey70\", color = \"grey70\") +   ggtitle(\"Long-term Dispersal\") +   coord_equal() + theme_bw() print(ltd_plot)"},{"path":"/articles/tutorial-locations.html","id":"introduction","dir":"Articles","previous_headings":"","what":"Introduction","title":"Locations","text":"tutorial discusses perform retrieve results specific individual locations.","code":""},{"path":"/articles/tutorial-locations.html","id":"background","dir":"Articles","previous_headings":"","what":"Background","title":"Locations","text":"analytical functions package provide ability get results specific particular locations (e.g., cells transient states). accomplished use origin dest parameters, correspond row column j P matrix, respectively. Locations can specified one two ways: First, can referred via positive integer value. values map directly row/columns numbers P matrix (specifically, transition matrix portion P, aka Q). ’s important assume locations directly correlate cell numbers raster layer matrix (e.g., location 1 refers first cell raster). relationship two, cases may direct correlation, matrix raster inputs contain NA’s, case. can make creation interpretation location values tricky. locate() function specifically created help . can used get raster shows location values map raster. can also used map xy coordinates location values, recommended manually choosing location values since coordinates clearer interpretation makes easier catch fix mistakes code. second approach refer locations row/column names P matrix. applicable samc-class objects directly created P matrix, can custom names applied via functions dimnames(), rownames(), /colnames(). ’ll particularly useful via named nodes graph support added future release. Referring locations names significant advantage makes easier read interpret code analysis, turn can make easier catch unintended mistakes (using integers location inputs, may obvious wrong number used refers valid location returns result).","code":""},{"path":"/articles/tutorial-locations.html","id":"setup","dir":"Articles","previous_headings":"","what":"Setup","title":"Locations","text":"","code":"# First step is to load the libraries. Not all of these libraries are strictly # needed; some are used for convenience and visualization for this tutorial. library(\"terra\") library(\"samc\") library(\"viridisLite\")  # \"Load\" the data. In this case we are using data built into the package. # In practice, users will likely load raster data using the raster() function # from the raster package. res_data <- samc::example_split_corridor$res abs_data <- samc::example_split_corridor$abs   # Setup the details for our transition function rw_model <- list(fun = function(x) 1/mean(x), # Function for calculating transition probabilities                  dir = 8, # Directions of the transitions. Either 4 or 8.                  sym = TRUE) # Is the function symmetric?  # Create a samc object using the resistance and absorption data. We use the # reciprical of the arithmetic mean for calculating the transition matrix. Note, # the input data here are matrices, not RasterLayers. samc_obj <- samc(res_data, abs_data, model = rw_model)"},{"path":"/articles/tutorial-locations.html","id":"basic-location-usage","dir":"Articles","previous_headings":"","what":"Basic Location Usage","title":"Locations","text":"","code":"# A couple examples of using numeric locations mort_origin <- mortality(samc_obj, origin = 7) head(mort_origin) # The result is a vector. Let's see the first few elements #> [1] 0.0004454945 0.0005970254 0.0006268049 0.0006652296 0.0007168680 #> [6] 0.0007962162  mort_dest <- mortality(samc_obj, dest = 13) head(mort_dest) # The result is a vector. Let's see the first few elements #> [1] 0.0004952858 0.0005096278 0.0005283281 0.0005495412 0.0005727323 #> [6] 0.0005978134  mort_both <- mortality(samc_obj, origin = 7, dest = 13) mort_both # The result is a single value #> [1] 0.0006250264  # The single value of mort_both simply is just extracted from one of the vector # results. So using both the origin and dest parameters is largely for convenience, # and helps to prevent accidental mistakes from trying to manually extract values # from the vectors mort_origin[13] #> [1] 0.0006250264 mort_dest[7] #> [1] 0.0006250264"},{"path":"/articles/tutorial-locations.html","id":"viewing-location-values","dir":"Articles","previous_headings":"","what":"Viewing Location Values","title":"Locations","text":"","code":"# Use the locate() function to get a raster that shows pixels or cells as # location values locations_map <- locate(samc_obj)  # Convert to a raster for visualization purposes locations_map = samc::rasterize(locations_map)   # Plot it. since the location values increase incrementally from left to right and # top to bottom, it forms what appears to be a smooth gradient. If a user is  # interested in identifying actual location values from this raster, they'll likely # have to save the raster and view it in external GIS software plot(locations_map, col = viridis(1024))  # There's a simple way to see visually where a particular location is. The location # will be shown as 1 (converted from TRUE), and all other locations will be shown # as 0 (converted from FALSE) plot(locations_map == 277, col = viridis(2))"},{"path":"/articles/tutorial-locations.html","id":"using-coordinates","dir":"Articles","previous_headings":"","what":"Using Coordinates","title":"Locations","text":"Users can use locate() function convert coordinate information (even line polygon info) locations. coordinate information can provided variety ways, including data frame, matrix, sf spatial objects, etc. Given locations map raster/matrix samc package, imperative users use cellFrom* functions raster package; may work situations, generally produce incorrect location values samc package.","code":"coords <- data.frame(x = c(50, 130),                      y = c(23, 9))  # Use the locate() function with coords to get location values locations <- locate(samc_obj, coords)  plot(locations_map == locations[1], col = viridis(2)) plot(locations_map == locations[2], col = viridis(2))  # Use the locations in a function mort_1 <- mortality(samc_obj, origin = locations[1]) head(mort_1) #> [1] 0.0004313355 0.0005695849 0.0005833685 0.0005963590 0.0006070493 #> [6] 0.0006144510  mort_2 <- mortality(samc_obj, origin = locations[2]) head(mort_2) #> [1] 0.0001651789 0.0002113811 0.0002086714 0.0002057462 0.0002027257 #> [6] 0.0001996758"},{"path":"/articles/tutorial-locations.html","id":"multiple-locations","dir":"Articles","previous_headings":"","what":"Multiple locations","title":"Locations","text":"specifying origin dest parameters function, possible provide multiple values vectors. , origin dest vectors paired, must length. eliminates need users use loops apply statements get results multiple pairs locations. Additionally, built-solution optimizations possible using external loops apply statements. order outputs guaranteed match order inputs. users may wish perform pairwise analysis combinations values origin vector dest vector, results can represented pairwise matrix. accommodate , pairwise() utility function can used. Since input vectors aren’t paired, can different lengths. result ‘long’ format; convert result pairwise matrix, see Code Snippets vignette.","code":"# We're going to use a data.frame to manage our input and output vectors easily data <- data.frame(origin = c(45, 3, 99),                    dest = c(102, 102, 33))  # Use the locations in a function data$mort <- mortality(samc_obj, origin = data$origin, dest = data$dest) data #>   origin dest         mort #> 1     45  102 0.0002442529 #> 2      3  102 0.0001578835 #> 3     99   33 0.0002157067 # Get the result for all the pairwise combinations of two vectors of locations pairwise(mortality, samc_obj, 5:6, 23:25) #>   origin dest       result #> 1      5   23 0.0004605204 #> 2      6   23 0.0004784789 #> 3      5   24 0.0004510868 #> 4      6   24 0.0004686200 #> 5      5   25 0.0004418815 #> 6      6   25 0.0004590024"},{"path":"/articles/tutorial-multiple-absorption.html","id":"introduction","dir":"Articles","previous_headings":"","what":"Introduction","title":"Multiple Absorption Tutorial","text":"Starting v1.4.0, samc package included support multiple sources absorption creating samc object. Additionally, multiple sources absorption provided, results mortality() metric now decomposed individual total components, returned named list. single absorption input provided, function work exactly like previously maintain backwards compatibility existing code. Note: asymptotic (long-term) calculations currently decomposed. short-term mortality metrics still need updated.","code":""},{"path":"/articles/tutorial-multiple-absorption.html","id":"setup","dir":"Articles","previous_headings":"","what":"Setup","title":"Multiple Absorption Tutorial","text":"example, use example data included package, semi-randomly divide/decompose absorption matrix two separate layers. layers used illustrative purposes represent anything meaningful.","code":"# First step is to load the libraries. Not all of these libraries are strictly # needed; some are used for convenience and visualization for this tutorial. library(\"terra\") library(\"samc\") library(\"viridisLite\")  # \"Load\" the data. In this case we are using data built into the package. # In practice, users will likely load raster data using the raster() function # from the raster package. res_data <- samc::example_split_corridor$res abs_data <- samc::example_split_corridor$abs  # To make things easier for plotting later, convert the matrices to rasters res_data <- samc::rasterize(res_data) abs_data <- samc::rasterize(abs_data)  # Generate some random values that will be used as proportions for dividing the # absorption data. p1 <- runif(length(abs_data), max = 0.3) p2 <- 1 - p1  # Divide our absorption data into two layers. When added together, these two # layers should be identical to the original abs_data_a <- abs_data * p1 abs_data_b <- abs_data * p2  # With terra, make sure each layer has a unique name names(abs_data_a) = \"abs1\" names(abs_data_b) = \"abs2\"  # Verify all.equal(abs_data_a + abs_data_b, abs_data) #> [1] \"Names: 1 string mismatch\"                                                  #> [2] \"Attributes: < Component \\\"ptr\\\": Component \\\"names\\\": 1 string mismatch >\""},{"path":"/articles/tutorial-multiple-absorption.html","id":"total-single-absorption","dir":"Articles","previous_headings":"","what":"Total (Single) Absorption","title":"Multiple Absorption Tutorial","text":"use multiple absorption layers mainly interest mortality() metric, calculates probability absorption different transient states locations. providing multiple absorption layers, can tease apart role different sources absorption might model. start, work total absorption.","code":"# Setup the details for our transition function rw_model <- list(fun = function(x) 1/mean(x), # Function for calculating transition probabilities            dir = 8, # Directions of the transitions. Either 4 or 8.            sym = TRUE) # Is the function symmetric?  # Create the samc object using the original \"total\" absorption layer samc_obj <- samc(res_data, abs_data, model = rw_model)  # Let's say we're interested in where absorption is expected to occur throughout # the model if starting from a single location mort <- mortality(samc_obj, origin = 1)  # When only working with total absorption, this version of mortality() returns # a named vector str(mort) #>  num [1:2624] 0.000783 0.000787 0.000704 0.000655 0.000621 ...  # Let's visualize it mort_map <- map(samc_obj, mort) plot(mort_map, xlab = \"x\", ylab = \"y\", col = viridis(256))"},{"path":"/articles/tutorial-multiple-absorption.html","id":"multiple-absorption","dir":"Articles","previous_headings":"","what":"Multiple Absorption","title":"Multiple Absorption Tutorial","text":"Since data matrix object, provide decomposed absorption layers list object. using raster data, provided either RasterStack RasterBrick. layers list/RasterStack/RasterBrick can named, carryover results, can help code readability accessing different parts results.","code":"# Let's attach absorption layers to our samc object samc_obj$abs_states <- c(abs_data_a, abs_data_b)  # Now rerun the analysis mort_multiple <- mortality(samc_obj, origin = 1)  # Let's note the differences from what was returned before. Here, we have a list # of named vectors. The first is for the total absorption. The last two are for # the subdivided or decomposed absorption inputs str(mort_multiple) #> List of 3 #>  $ total: num [1:2624] 0.000783 0.000787 0.000704 0.000655 0.000621 ... #>  $ abs1 : num [1:2624] 1.90e-05 1.91e-05 1.71e-05 1.59e-05 1.51e-05 ... #>  $ abs2 : num [1:2624] 0.000764 0.000768 0.000687 0.000639 0.000606 ...  # Let's visualize it multiple_map <- map(samc_obj, mort_multiple) multiple_map <- rast(multiple_map) # Convert the list to a multi-layer SpatRaster for plotting plot(multiple_map, xlab = \"x\", ylab = \"y\", col = viridis(256), nc = 1, nr = 3) # Let's check some things.  #First, the results of the decomposed layers in the list should add up to the total result all.equal(values(multiple_map[[1]], mat = FALSE),           values(multiple_map[[2]] + multiple_map[[3]], mat = FALSE)) #> [1] TRUE # Alternatively, we could use the layer names: all.equal(values(multiple_map$total, mat = FALSE),           values(multiple_map$abs1 + multiple_map$abs2, mat = FALSE)) #> [1] TRUE  # Second, notice in the plots above that the result for the single input and the total # result for the multiple input look very similar? That's because they are identical all.equal(mort, mort_multiple$total) #> [1] TRUE"},{"path":"/articles/tutorial-multiple-absorption.html","id":"partial-absorption-data","dir":"Articles","previous_headings":"","what":"Partial Absorption Data","title":"Multiple Absorption Tutorial","text":"code, decomposed absorption data sums total absorption data. strictly necessary, decomposed absorption data can consist number inputs. inputs treated independently one another package. potentially useful least two different situations. first situation interested results subset absorption components. words, might multiple sources absorption contributing total overall absorption used create samc object, analysis might interested learning one . case, need supply absorption probabilities interested ; others can excluded.  second situation might multiple candidate models particular source absorption. Rather running analysis every candidate, can simply include run analysis .","code":"# Let's say we are interested in just the first component we created above samc_obj$abs_states <- abs_data_a  mort_partial <- mortality(samc_obj, origin = 1)  # Let's visualize it. Note that the results are the same as before, just without # the second component. partial_map <- map(samc_obj, mort_partial) partial_map <- rast(partial_map) # Convert the list to a RasterStack for plotting plot(partial_map, xlab = \"x\", ylab = \"y\", col = viridis(256), nc = 1, nr = 3) # Create multiple versions of our first component. This might represent multiple # models or hypotheses we want to explore abs_1_models <- c(abs_data_a * 0.2,                   abs_data_a * 0.4,                   abs_data_a * 0.6,                   abs_data_a * 0.8,                   abs_data_a) names(abs_1_models) <- c(\"abs1_2\", \"abs1_4\", \"abs1_6\", \"abs1_8\", \"abs1\") samc_obj$abs_states <- abs_1_models  mort_models <- mortality(samc_obj, origin = 1)  # Let's visualize it. Note that the results are not particularly interesting visually; # the only difference between these models is the scale models_map <- map(samc_obj, mort_models) models_map <- rast(models_map) # Convert the list to a RasterStack for plotting plot(models_map, xlab = \"x\", ylab = \"y\", col = viridis(256), nc = 2, nr = 3)"},{"path":"/articles/tutorial-multiple-absorption.html","id":"calculating-total-absorption-from-individual-components","dir":"Articles","previous_headings":"","what":"Calculating Total Absorption From Individual Components","title":"Multiple Absorption Tutorial","text":"point, total absorption examples assumed already known. One possibility total absorption known estimated directly empirical data. section, however, comments situation ’s individual absorption components (e.g., different sources absorption) directly measured estimated, now user situation need combine data total absorption can use input samc() function. Ultimately, number arbitrary mathematical functions used combine individual components total absorption. starting point, however, users may want think data fits probability theory. Let’s say two possible sources absorption AA BB. occur time, mutually exclusive, disjoint, events. example might deer dispersing across landscape can die either predation road mortality (hit vehicle). case, types absorption result death deer, since deer die twice, means types absorption mutually exclusive. rules probability, can calculate total absorption P(B)=P()+P(B)P(\\text{ }B) = P() + P(B) P()=Probability PredationP() = \\text{Probability Predation} P(B)=Probability Road MortalityP(B) = \\text{Probability Road Mortality}. complex scenarios possible. ’s conceivable might situations two different sources absorption can occur simultaneously. case, total absorption calculated P(B)=P()+P(B)−P()P(B)P(\\text{ }B) = P() + P(B) - P()P(B). interpreting results using multiple absorption package, results P()P(B)P()P(B) can calculated either providing absorption sources AA BB multiplying results analysis, absorption sources AA BB can pre-multiplied single absorbing state used absorbing state analysis.","code":""},{"path":"/articles/tutorial-multiple-absorption.html","id":"disabling-multiple-absorption","dir":"Articles","previous_headings":"","what":"Disabling Multiple Absorption","title":"Multiple Absorption Tutorial","text":"","code":"# To remove all the absorption components samc_obj$abs_states <- NA"},{"path":"/articles/tutorial-temporal.html","id":"introduction","dir":"Articles","previous_headings":"","what":"Introduction","title":"Temporal Analysis","text":"tutorial shows basics working short-term temporal metrics plot using base plotting tools R.","code":""},{"path":"/articles/tutorial-temporal.html","id":"setup","dir":"Articles","previous_headings":"","what":"Setup","title":"Temporal Analysis","text":"","code":"# First step is to load the libraries. Not all of these libraries are stricly # needed; some are used for convenience and visualization for this tutorial. library(\"terra\") library(\"samc\") library(\"viridisLite\")   # \"Load\" the data. In this case we are using data built into the package. # In practice, users will likely load raster data using the raster() function # from the raster package. res_data <- samc::example_split_corridor$res abs_data <- samc::example_split_corridor$abs  # To make things easier for plotting later, convert the matrices to rasters res_data <- rasterize(res_data) abs_data <- rasterize(abs_data)  # Setup the details for our transition function rw_model <- list(fun = function(x) 1/mean(x), # Function for calculating transition probabilities                  dir = 8, # Directions of the transitions. Either 4 or 8.                  sym = TRUE) # Is the function symmetric?  # Create a samc object using the resistance and absorption data. We use the  # recipricol of the arithmetic mean for calculating the transition matrix. Note, # the input data here are matrices, not RasterLayers. samc_obj <- samc(res_data, abs_data, model = rw_model)"},{"path":"/articles/tutorial-temporal.html","id":"temporal-analysis","dir":"Articles","previous_headings":"","what":"Temporal Analysis","title":"Temporal Analysis","text":"Given starting location, ’re going calculate probabilities individual varying time steps. starting location going cell 1 landscape, first non-NA cell going left--right top--bottom order. actual analysis visualization shown two ways. easiest, efficient, safest approach using time step vector inputs added version 1.1.0.  want control, following shows loop results using two different options  Previous version required individually calculating metric time step. ultimately slower computationally error prone users comfortable loops, included posterity.","code":"# First, let's specify the time steps we are interested in time_steps <- c(10, 100, 1000, 10000) # First, calculate the metric for the entire vector of time steps results <- distribution(samc_obj, origin = 1, time = time_steps)  # The result is a list of vectors. Note that the list is named with the time steps str(results) #> List of 4 #>  $ 10   : num [1:2624] 0.0246 0.0306 0.0261 0.0193 0.0125 ... #>  $ 100  : num [1:2624] 0.00256 0.00336 0.00338 0.00334 0.00326 ... #>  $ 1000 : num [1:2624] 0.000212 0.000284 0.000295 0.000307 0.00032 ... #>  $ 10000: num [1:2624] 3.09e-05 3.97e-05 3.93e-05 3.88e-05 3.83e-05 ...  # We can take this list, and use map() to convert it to a list of RasterLayers. results_map <- map(samc_obj, results) str(results_map, max.level = 1) # max.level is to hide a lot of gory details #> List of 4 #>  $ 10   :S4 class 'SpatRaster' [package \"terra\"] #>  $ 100  :S4 class 'SpatRaster' [package \"terra\"] #>  $ 1000 :S4 class 'SpatRaster' [package \"terra\"] #>  $ 10000:S4 class 'SpatRaster' [package \"terra\"]  # A list of SpatRasters can be turned results_stack <- rast(results_map)  # Let's look at the names names(results_stack) #> [1] \"10\"    \"100\"   \"1000\"  \"10000\"  # RasterStacks are convenient for a lot of different things, like processing the # rasters all at once using spatial methods. But we're just going to plot them plot(results_stack, xlab = \"x\", ylab = \"y\", col = viridis(256)) # The results of individual time steps can be retrieved by either index or by name  results[[3]] #>  [1] 0.0002122761 0.0002838443 0.0002953125 0.0003074062 0.0003195378 #>  [6] 0.0003313612 0.0003426443 0.0003532239 0.0003629837 0.0003718411 #> [11] 0.0003797378 0.0003866344 0.0003925059 0.0003973388 0.0004011292 #> [16] 0.0004038814 0.0004056069 0.0004063231 0.0004060532 0.0004048254 #>  [ reached getOption(\"max.print\") -- omitted 2604 entries ] results[[\"1000\"]] #>  [1] 0.0002122761 0.0002838443 0.0002953125 0.0003074062 0.0003195378 #>  [6] 0.0003313612 0.0003426443 0.0003532239 0.0003629837 0.0003718411 #> [11] 0.0003797378 0.0003866344 0.0003925059 0.0003973388 0.0004011292 #> [16] 0.0004038814 0.0004056069 0.0004063231 0.0004060532 0.0004048254 #>  [ reached getOption(\"max.print\") -- omitted 2604 entries ]  # The latter is particularly useful in making reliable for loops because indexed # for loops can be harder to troubleshoot if something goes wrong.  for (ts in time_steps) {   name <- as.character(ts)   r <- results[[name]]   r_map <- map(samc_obj, r)   plot(r_map, main = paste(\"Individual Location at Time\", ts), xlab = \"x\", ylab = \"y\", col = viridis(256)) } # For comparison, here is an indexed for loop that does the same thing for (i in 1:length(time_steps)) {   name <- as.character(time_steps[i])   r <- results[[i]] # or we could replace `i` with `name` on this line   # ... } for (ts in time_steps) {   dist <- distribution(samc_obj, origin = 1, time = ts)   dist_map <- map(samc_obj, dist)   plot(dist_map, main = paste(\"Individual Location at Time\", ts), xlab = \"x\", ylab = \"y\", col = viridis(256)) }"},{"path":"/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"Andrew Marx. Author, maintainer, copyright holder. Robert Fletcher. Contributor. Miguel Acevedo. Contributor. Jorge Sefair. Contributor. Chao Wang. Contributor. Hughes Josie. Contributor. Barrett Griffin. Contributor.","code":""},{"path":"/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"Marx (????). samc: Spatial Absorbing Markov Chains. R package version 4.0.0, https://andrewmarx.github.io/samc/. Marx AJ, Wang C, Sefair JA, Acevedo MA, Fletcher Jr. RJ (2020). “samc: R package connectivity modeling spatial absorbing Markov chains.” Ecography, 43(4), 518-527. https://onlinelibrary.wiley.com/doi/abs/10.1111/ecog.04891.","code":"@Manual{,   title = {samc: Spatial Absorbing Markov Chains},   author = {Andrew Marx},   note = {R package version 4.0.0},   url = {https://andrewmarx.github.io/samc/}, } @Article{,   title = {samc: an R package for connectivity modeling with spatial absorbing Markov chains},   author = {Andrew J. Marx and Chao Wang and Jorge A. Sefair and Miguel A. Acevedo and Robert J. {Fletcher Jr.}},   journal = {Ecography},   year = {2020},   volume = {43},   number = {4},   pages = {518-527},   url = {https://onlinelibrary.wiley.com/doi/abs/10.1111/ecog.04891}, }"},{"path":[]},{"path":"/index.html","id":"introduction","dir":"","previous_headings":"samc","what":"Introduction","title":"Spatial Absorbing Markov Chains","text":"R package implements functions working absorbing Markov chains using theorems described book “Finite Markov Chains” Kemeny Snell. design package based implementation theorems framework described Fletcher et al. (2019), applies spatial ecology. framework incorporates resistance absorption (mortality) using spatial absorbing Markov chains provide several short- long-term predictions metrics related connectivity landscapes. metrics listed Table 1 Fletcher et al. (2019), well Overview vignette. Despite ecological context package, functions can used application absorbing Markov chains. version 3.1.0, package also supports use convolution algorithm described Hughes et al. (2023). algorithm uses moving window approach calculate many metrics iteratively fast memory efficient manner.","code":""},{"path":"/index.html","id":"installation","dir":"","previous_headings":"samc","what":"Installation","title":"Spatial Absorbing Markov Chains","text":"recommended users install samc package via CRAN, regularly kept date.","code":"install.packages(\"samc\")"},{"path":"/index.html","id":"citation","dir":"","previous_headings":"samc","what":"Citation","title":"Spatial Absorbing Markov Chains","text":"using package, please cite using: Marx, .J., Wang, C., Sefair, J.., Acevedo, M.. Fletcher, R.J., Jr. (2020), samc: R package connectivity modeling spatial absorbing Markov chains. Ecography, 43: 518-527. doi:10.1111/ecog.04891","code":""},{"path":"/index.html","id":"publications","dir":"","previous_headings":"samc","what":"Publications","title":"Spatial Absorbing Markov Chains","text":"list publications samc package used way: Predicting dispersal conflict risk wolf recolonization Colorado Journal Applied Ecology (Sep 2023) framework linking dispersal biology connectivity across landscapes Landscape Ecology (Jul 2023) Comparison parallel implementation alternative moving-window metrics connectivity protected areas across large landscapes Landscape Ecology (Mar 2023) Mapping connectivity–conflict interface inform conservation PNAS (Dec 2022) Landscape connectivity endangered carnivore: habitat conservation road mitigation ocelots US Landscape Ecology (Dec 2022) Extending isolation resistance predict genetic connectivity Methods Ecology Evolution (Sep 2022) Defining quantifying effective connectivity landscapes species’ movements Ecography (Mar 2021)","code":""},{"path":"/index.html","id":"major-changes","dir":"","previous_headings":"samc","what":"Major Changes","title":"Spatial Absorbing Markov Chains","text":"Version 4 package made one breaking change: visitation_net(samc, origin, dest) function updated behave consistently like metrics. Instead returning vector, now returns single value. accompanied change mathematical implementation correctly generalizes models multiple absorbing points. Version 3 package made minor breaking changes: samc() function longer supports TransitionLayer inputs. niche use case, v3 wasn’t issue include dependencies gdistance. v3, became dependency left gdistance, removed avoid potential future issues gdistance ever get removed CRAN (nearly happened 2022). addition terra support, map() function updated output matches input type samc(). Previously, matrix inputs matched RasterLayers, now mapped back matrices. sym option creating samc object currently ignored. tr_args occ parameters renamed model init, respectively. cond_passage() visitation() init argument inserted match usage metrics. arguments fully implemented v3.0.0 may implemented future. Cells longer automatically named samc() creating transition matrix maps. Generating unique character names cell ended significant waste memory inputs samc() got larger. ’s unlikely names ever used practice, since using numeric results locate() convenient. Version 2 package officially removed support various deprecated parameters samc() function. Deprecation warnings provided starting v1.4.0 package, along message details backward compatible implementation expected changes. Removing backward compatibility breaking change require old code updated order run latest version package. changes needed straightforward mostly entail reorganization input parameters samc() function. old functionality, primarily overriding memory safety limits, moved samc-class longer tied object creation. Redesigning samc() function removing backward compatibility makes maintaining package adding new features later substantially improved process; hopefully minor inconvenience users.","code":""},{"path":"/index.html","id":"support","dir":"","previous_headings":"samc","what":"Support","title":"Spatial Absorbing Markov Chains","text":"Please note section package-specific queries. questions comments related published articles, contact authors.","code":""},{"path":"/index.html","id":"have-an-error-and-cant-fix-it","dir":"","previous_headings":"","what":"Spatial Absorbing Markov Chains","title":"Spatial Absorbing Markov Chains","text":"error, make sure using newest version package. , check site’s Troubleshooting page, periodically updated common errors users encounter.","code":""},{"path":"/index.html","id":"not-sure-how-to-do-something-found-a-bug-have-a-feature-request-still-cant-solve-your-error-want-to-show-off-your-project","dir":"","previous_headings":"","what":"Spatial Absorbing Markov Chains","title":"Spatial Absorbing Markov Chains","text":"Github discussions page anything everything related package : Github Discussions","code":""},{"path":"/index.html","id":"license","dir":"","previous_headings":"samc","what":"License","title":"Spatial Absorbing Markov Chains","text":"default, package code licensed AGPLv3. code files derived 3rd party sources may licensed GPLv3 comment indicate case. Website materials licensed CC -NC-SA 4.0.","code":""},{"path":"/index.html","id":"references","dir":"","previous_headings":"samc","what":"References","title":"Spatial Absorbing Markov Chains","text":"Fletcher, R.J., Jr., Sefair, J.., Wang, C., Poli, C.L., Smith, T..H., Bruna, E.M., Holt, R.D., Barfield, M., Marx, .J. Acevedo, M.. (2019), Towards unified framework connectivity disentangles movement mortality space time. Ecol Lett, 22: 1680-1689. https://doi.org/10.1111/ele.13333 Hughes, J., Lucet, V., Barrett, G. et al. Comparison parallel implementation alternative moving-window metrics connectivity protected areas across large landscapes. Landsc Ecol (2023). https://doi.org/10.1007/s10980-023-01619-9","code":""},{"path":"/reference/absorption.html","id":null,"dir":"Reference","previous_headings":"","what":"Calculate absorption metrics — absorption","title":"Calculate absorption metrics — absorption","text":"Calculates probability absorption absorbing states rather individual transient states. distint , yet closely linked , mortality() metric, calculates probability absorption individual transient states. results mortality() metric decomposed individual results absorbing state, sums individual results every transient state equivalent results absorption() metric.","code":""},{"path":"/reference/absorption.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Calculate absorption metrics — absorption","text":"","code":"absorption(samc, init, origin)  # S4 method for class 'samc,missing,missing' absorption(samc)  # S4 method for class 'samc,missing,location' absorption(samc, origin)  # S4 method for class 'samc,ANY,missing' absorption(samc, init)"},{"path":"/reference/absorption.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Calculate absorption metrics — absorption","text":"samc samc-class object created using samc function. init Sets initial state \\(\\psi\\) transients states. Input must able pass check function compared samc-class object. Can contain positive finite values. origin positive integer character name representing transient state \\(\\mathit{}\\). Corresponds row \\(\\mathit{}\\) matrix \\(\\mathbf{P}\\) samc-class object. paired dest parameter, multiple values may provided vector.","code":""},{"path":"/reference/absorption.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Calculate absorption metrics — absorption","text":"See Details","code":""},{"path":"/reference/absorption.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Calculate absorption metrics — absorption","text":"\\(= F R\\) absorption(samc) result matrix \\(M\\) \\(M_{,k}\\) probability absorption due absorbing state \\(\\mathit{k}\\) starting transient state \\(\\mathit{}\\). absorption(samc, origin) result vector \\(\\mathbf{v}\\) \\(\\mathbf{v}_{k}\\) probability absorption due absorbing state \\(\\mathit{k}\\) starting transient state \\(\\mathit{}\\). \\(\\psi^T \\) absorption(samc, init) result vector \\(\\mathbf{v}\\) \\(\\mathbf{v}_{k}\\) probability absorption due absorbing state \\(\\mathit{k}\\) given initial state \\(\\psi\\).","code":""},{"path":"/reference/absorption.html","id":"performance","dir":"Reference","previous_headings":"","what":"Performance","title":"Calculate absorption metrics — absorption","text":"relevant performance information function can found performance vignette: vignette(\"performance\", package = \"samc\")","code":""},{"path":"/reference/absorption.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Calculate absorption metrics — absorption","text":"","code":"# \"Load\" the data. In this case we are using data built into the package. # In practice, users will likely load raster data using the raster() function # from the raster package. res_data <- samc::example_split_corridor$res abs_data <- samc::example_split_corridor$abs init_data <- samc::example_split_corridor$init   # Make sure our data meets the basic input requirements of the package using # the check() function. check(res_data, abs_data) #> [1] TRUE check(res_data, init_data) #> [1] TRUE  # Setup the details for a random-walk model rw_model <- list(fun = function(x) 1/mean(x), # Function for calculating transition probabilities                  dir = 8, # Directions of the transitions. Either 4 or 8.                  sym = TRUE) # Is the function symmetric?   # Create a `samc-class` object with the resistance and absorption data using # the samc() function. We use the recipricol of the arithmetic mean for # calculating the transition matrix. Note, the input data here are matrices, # not RasterLayers. samc_obj <- samc(res_data, abs_data, model = rw_model)   # Convert the initial state data to probabilities init_prob_data <- init_data / sum(init_data, na.rm = TRUE)   # Calculate short- and long-term metrics using the analytical functions short_mort <- mortality(samc_obj, init_prob_data, time = 50) short_dist <- distribution(samc_obj, origin = 3, time = 50) long_disp <- dispersal(samc_obj, init_prob_data) #>  #> Cached diagonal not found. #> Performing setup. This can take several minutes... Complete. #> Calculating matrix inverse diagonal... #>  Computing: 49%  (~10s remaining)        Computing: 98%  (~0s remaining)        Computing: 100% (done)                          #>  Complete                                                       #> Diagonal has been cached. Continuing with metric calculation... visit <- visitation(samc_obj, dest = 4) surv <- survival(samc_obj)   # Use the map() function to turn vector results into RasterLayer objects. short_mort_map <- map(samc_obj, short_mort) short_dist_map <- map(samc_obj, short_dist) long_disp_map <- map(samc_obj, long_disp) visit_map <- map(samc_obj, visit) surv_map <- map(samc_obj, surv)"},{"path":"/reference/char_null-class.html","id":null,"dir":"Reference","previous_headings":"","what":"samc char_null class — char_null-class","title":"samc char_null class — char_null-class","text":"Class grouping character NULL data types","code":""},{"path":"/reference/check.html","id":null,"dir":"Reference","previous_headings":"","what":"Check landscape data — check","title":"Check landscape data — check","text":"Check landscape inputs valid values matching properties.","code":""},{"path":"/reference/check.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Check landscape data — check","text":"","code":"check(a, b)  # S4 method for class 'Raster,missing' check(a)  # S4 method for class 'SpatRaster,missing' check(a)  # S4 method for class 'matrix,missing' check(a)  # S4 method for class 'SpatRaster,SpatRaster' check(a, b)  # S4 method for class 'Raster,Raster' check(a, b)  # S4 method for class 'matrix,matrix' check(a, b)  # S4 method for class 'samc,Raster' check(a, b)  # S4 method for class 'samc,SpatRaster' check(a, b)  # S4 method for class 'samc,matrix' check(a, b)  # S4 method for class 'samc,numeric' check(a, b)"},{"path":"/reference/check.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Check landscape data — check","text":"samc-class, matrix, RasterLayer-class object b matrix RasterLayer-class object","code":""},{"path":"/reference/check.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Check landscape data — check","text":"See Details section.","code":""},{"path":"/reference/check.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Check landscape data — check","text":"function used ensure inputs (resistance, absorption, fidelity, occupancy) valid values properties. includes checking CRS (using raster inputs), dimensions, locations cells NA data. can used directly compare two matrices two rasters, can used check samc-class object matrix raster. can also used check numeric vector samc-class object created P matrix. case, length vector must equal number transient states. transient states named, vector must contain names. function returns TRUE inputs matching properties. Otherwise, stop execution print error message details difference two inputs. Note package assumes different landscape inputs type, either matrices RasterLayers. Mixing RasterLayer data matrix data supported.","code":""},{"path":"/reference/check.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Check landscape data — check","text":"","code":"# \"Load\" the data. In this case we are using data built into the package. # In practice, users will likely load raster data using the raster() function # from the raster package. res_data <- samc::example_split_corridor$res abs_data <- samc::example_split_corridor$abs init_data <- samc::example_split_corridor$init   # Make sure our data meets the basic input requirements of the package using # the check() function. check(res_data, abs_data) #> [1] TRUE check(res_data, init_data) #> [1] TRUE  # Setup the details for a random-walk model rw_model <- list(fun = function(x) 1/mean(x), # Function for calculating transition probabilities                  dir = 8, # Directions of the transitions. Either 4 or 8.                  sym = TRUE) # Is the function symmetric?   # Create a `samc-class` object with the resistance and absorption data using # the samc() function. We use the recipricol of the arithmetic mean for # calculating the transition matrix. Note, the input data here are matrices, # not RasterLayers. samc_obj <- samc(res_data, abs_data, model = rw_model)   # Convert the initial state data to probabilities init_prob_data <- init_data / sum(init_data, na.rm = TRUE)   # Calculate short- and long-term metrics using the analytical functions short_mort <- mortality(samc_obj, init_prob_data, time = 50) short_dist <- distribution(samc_obj, origin = 3, time = 50) long_disp <- dispersal(samc_obj, init_prob_data) #>  #> Cached diagonal not found. #> Performing setup. This can take several minutes... Complete. #> Calculating matrix inverse diagonal... #>  Computing: 50%  (~10s remaining)        Computing: 98%  (~0s remaining)        Computing: 100% (done)                          #>  Complete                                                       #> Diagonal has been cached. Continuing with metric calculation... visit <- visitation(samc_obj, dest = 4) surv <- survival(samc_obj)   # Use the map() function to turn vector results into RasterLayer objects. short_mort_map <- map(samc_obj, short_mort) short_dist_map <- map(samc_obj, short_dist) long_disp_map <- map(samc_obj, long_disp) visit_map <- map(samc_obj, visit) surv_map <- map(samc_obj, surv)"},{"path":"/reference/cond_passage.html","id":null,"dir":"Reference","previous_headings":"","what":"Conditional Mean First Passage Time — cond_passage","title":"Conditional Mean First Passage Time — cond_passage","text":"Calculate mean number steps first passage","code":""},{"path":"/reference/cond_passage.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Conditional Mean First Passage Time — cond_passage","text":"","code":"cond_passage(samc, init, origin, dest)  # S4 method for class 'samc,missing,missing,location' cond_passage(samc, dest)  # S4 method for class 'samc,missing,location,location' cond_passage(samc, origin, dest)  # S4 method for class 'samc,ANY,missing,location' cond_passage(samc, init, dest)"},{"path":"/reference/cond_passage.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Conditional Mean First Passage Time — cond_passage","text":"samc samc-class object created using samc function. init Sets initial state \\(\\psi\\) transients states. Input must able pass check function compared samc-class object. Can contain positive finite values. origin positive integer character name representing transient state \\(\\mathit{}\\). Corresponds row \\(\\mathit{}\\) matrix \\(\\mathbf{P}\\) samc-class object. paired dest parameter, multiple values may provided vector. dest positive integer character name representing transient state \\(\\mathit{j}\\). Corresponds column \\(\\mathit{j}\\) matrix \\(\\mathbf{P}\\) samc-class object. paired origin parameter, multiple values may provided vector.","code":""},{"path":"/reference/cond_passage.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Conditional Mean First Passage Time — cond_passage","text":"See Details","code":""},{"path":"/reference/cond_passage.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Conditional Mean First Passage Time — cond_passage","text":"\\(\\tilde{t}=\\tilde{B}_j^{-1}\\tilde{F}\\tilde{B}_j{\\cdot}1\\) cond_passage(samc, dest) result vector element corresponds cell landscape, can mapped back landscape using map function. Element mean number steps absorption starting location conditional absorption j Note mathematically, formula actually return value equal j. leads situation resultant vector actually one element short index elements may shifted. cond_passage() function fills inserts 0 value vector indices corresponding == j. corrects final result vector indices work expected, allows vector properly used map function. cond_passage(samc, origin, dest) result numeric value representing mean number steps absorption starting given origin conditional absorption j. described , mathematically formula return result origin dest inputs equal, function simply returns 0 case. WARNING: function compatible used data states total absorption present. present, states representing total absorption leads unsolvable linear equations. exception single total absorption state corresponds input dest parameter. case, total absorption effectively ignored linear equations solved. WARNING: function crash used data representing disconnected graph. includes, example, isolated pixels islands raster data. result transition matrix disconnected graphs leading equations unsolvable. Different options explored best identify situations data handle accordingly.","code":""},{"path":"/reference/cond_passage.html","id":"performance","dir":"Reference","previous_headings":"","what":"Performance","title":"Conditional Mean First Passage Time — cond_passage","text":"relevant performance information function can found performance vignette: vignette(\"performance\", package = \"samc\")","code":""},{"path":"/reference/cond_passage.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Conditional Mean First Passage Time — cond_passage","text":"","code":"# \"Load\" the data. In this case we are using data built into the package. # In practice, users will likely load raster data using the raster() function # from the raster package. res_data <- samc::example_split_corridor$res abs_data <- samc::example_split_corridor$abs init_data <- samc::example_split_corridor$init   # Make sure our data meets the basic input requirements of the package using # the check() function. check(res_data, abs_data) #> [1] TRUE check(res_data, init_data) #> [1] TRUE  # Setup the details for a random-walk model rw_model <- list(fun = function(x) 1/mean(x), # Function for calculating transition probabilities                  dir = 8, # Directions of the transitions. Either 4 or 8.                  sym = TRUE) # Is the function symmetric?   # Create a `samc-class` object with the resistance and absorption data using # the samc() function. We use the recipricol of the arithmetic mean for # calculating the transition matrix. Note, the input data here are matrices, # not RasterLayers. samc_obj <- samc(res_data, abs_data, model = rw_model)   # Convert the initial state data to probabilities init_prob_data <- init_data / sum(init_data, na.rm = TRUE)   # Calculate short- and long-term metrics using the analytical functions short_mort <- mortality(samc_obj, init_prob_data, time = 50) short_dist <- distribution(samc_obj, origin = 3, time = 50) long_disp <- dispersal(samc_obj, init_prob_data) #>  #> Cached diagonal not found. #> Performing setup. This can take several minutes... Complete. #> Calculating matrix inverse diagonal... #>  Computing: 50%  (~9s remaining)        Computing: 98%  (~0s remaining)        Computing: 100% (done)                          #>  Complete                                                       #> Diagonal has been cached. Continuing with metric calculation... visit <- visitation(samc_obj, dest = 4) surv <- survival(samc_obj)   # Use the map() function to turn vector results into RasterLayer objects. short_mort_map <- map(samc_obj, short_mort) short_dist_map <- map(samc_obj, short_dist) long_disp_map <- map(samc_obj, long_disp) visit_map <- map(samc_obj, visit) surv_map <- map(samc_obj, surv)"},{"path":"/reference/dispersal.html","id":null,"dir":"Reference","previous_headings":"","what":"Calculate dispersal metrics — dispersal","title":"Calculate dispersal metrics — dispersal","text":"Calculates probability individuals visiting locations","code":""},{"path":"/reference/dispersal.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Calculate dispersal metrics — dispersal","text":"","code":"dispersal(samc, init, origin, dest, time)  # S4 method for class 'samc,missing,location,location,numeric' dispersal(samc, origin, dest, time)  # S4 method for class 'samc,missing,missing,location,numeric' dispersal(samc, dest, time)  # S4 method for class 'samc,ANY,missing,location,numeric' dispersal(samc, init, dest, time)  # S4 method for class 'samc,missing,missing,missing,missing' dispersal(samc)  # S4 method for class 'samc,missing,location,missing,missing' dispersal(samc, origin)  # S4 method for class 'samc,missing,missing,location,missing' dispersal(samc, dest)  # S4 method for class 'samc,missing,location,location,missing' dispersal(samc, origin, dest)  # S4 method for class 'samc,ANY,missing,missing,missing' dispersal(samc, init)  # S4 method for class 'samc,ANY,missing,location,missing' dispersal(samc, init, dest)"},{"path":"/reference/dispersal.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Calculate dispersal metrics — dispersal","text":"samc samc-class object created using samc function. init Sets initial state \\(\\psi\\) transients states. Input must able pass check function compared samc-class object. Can contain positive finite values. origin positive integer character name representing transient state \\(\\mathit{}\\). Corresponds row \\(\\mathit{}\\) matrix \\(\\mathbf{P}\\) samc-class object. paired dest parameter, multiple values may provided vector. dest positive integer character name representing transient state \\(\\mathit{j}\\). Corresponds column \\(\\mathit{j}\\) matrix \\(\\mathbf{P}\\) samc-class object. paired origin parameter, multiple values may provided vector. time positive integer vector positive integers representing \\(\\mathit{t}\\) time steps. Vectors must ordered contain duplicates. Vectors may used metrics return dense matrices. maximum time step value capped 10,000 due numerical precision issues.","code":""},{"path":"/reference/dispersal.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Calculate dispersal metrics — dispersal","text":"See Details","code":""},{"path":"/reference/dispersal.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Calculate dispersal metrics — dispersal","text":"\\(\\tilde{D}_{jt}=(\\sum_{n=0}^{t-1}\\tilde{Q}^n)\\tilde{q}_j\\) dispersal(samc, dest, time) result vector \\(\\mathbf{v}\\) \\(\\mathbf{v}_i\\) probability visiting transient state \\(\\mathit{j}\\) within \\(\\mathit{t}\\) fewer time steps starting transient state \\(\\mathit{}\\). Note: Given current derivation, \\(\\mathit{=j}\\), \\(\\mathbf{v}_i\\) unknown set NA. multiple time steps provided vector, result ordered named list containing vector time step. samc-class object created using matrix RasterLayer maps, vector \\(\\mathbf{v}\\) can mapped RasterLayer using map function. \\(\\psi^T\\tilde{D}_{jt}\\) dispersal(samc, init, dest, time) result numeric probability visiting transient state \\(\\mathit{j}\\) within \\(\\mathit{t}\\) fewer time steps given initial state \\(\\psi\\) multiple time steps provided vector, result ordered named list containing vector time step. \\(D=(F-)diag(F)^{-1}\\) dispersal(samc) result matrix \\(M\\) \\(M_{,j}\\) probability visiting transient state \\(\\mathit{j}\\) starting transient state \\(\\mathit{}\\). returned matrix always dense optimized. Must enable override use (see samc-class). dispersal(samc, origin) result vector \\(\\mathbf{v}\\) \\(\\mathbf{v}_j\\) probability visiting transient state \\(\\mathit{j}\\) starting transient state \\(\\mathit{}\\). samc-class object created using matrix RasterLayer maps, vector \\(\\mathbf{v}\\) can mapped RasterLayer using map function. dispersal(samc, dest) result vector \\(\\mathbf{v}\\) \\(\\mathbf{v}_i\\) probability visiting transient state \\(\\mathit{j}\\) starting transient state \\(\\mathit{}\\). samc-class object created using matrix RasterLayer maps, vector \\(\\mathbf{v}\\) can mapped RasterLayer using map function. dispersal(samc, origin, dest) result numeric value probability visiting transient state \\(\\mathit{j}\\) starting transient state \\(\\mathit{}\\). \\(\\psi^TD\\) dispersal(samc, init) result vector \\(\\mathbf{v}\\) \\(\\mathbf{v}_j\\) probability visiting transient state \\(\\mathit{j}\\) given initial state \\(\\psi\\). samc-class object created using matrix RasterLayer maps, vector \\(\\mathbf{v}\\) can mapped RasterLayer using map function. dispersal(samc, init, dest) result numeric value probability visiting transient state \\(\\mathit{j}\\) given initial state \\(\\psi\\).","code":""},{"path":"/reference/dispersal.html","id":"performance","dir":"Reference","previous_headings":"","what":"Performance","title":"Calculate dispersal metrics — dispersal","text":"relevant performance information function can found performance vignette: vignette(\"performance\", package = \"samc\")","code":""},{"path":"/reference/dispersal.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Calculate dispersal metrics — dispersal","text":"","code":"# \"Load\" the data. In this case we are using data built into the package. # In practice, users will likely load raster data using the raster() function # from the raster package. res_data <- samc::example_split_corridor$res abs_data <- samc::example_split_corridor$abs init_data <- samc::example_split_corridor$init   # Make sure our data meets the basic input requirements of the package using # the check() function. check(res_data, abs_data) #> [1] TRUE check(res_data, init_data) #> [1] TRUE  # Setup the details for a random-walk model rw_model <- list(fun = function(x) 1/mean(x), # Function for calculating transition probabilities                  dir = 8, # Directions of the transitions. Either 4 or 8.                  sym = TRUE) # Is the function symmetric?   # Create a `samc-class` object with the resistance and absorption data using # the samc() function. We use the recipricol of the arithmetic mean for # calculating the transition matrix. Note, the input data here are matrices, # not RasterLayers. samc_obj <- samc(res_data, abs_data, model = rw_model)   # Convert the initial state data to probabilities init_prob_data <- init_data / sum(init_data, na.rm = TRUE)   # Calculate short- and long-term metrics using the analytical functions short_mort <- mortality(samc_obj, init_prob_data, time = 50) short_dist <- distribution(samc_obj, origin = 3, time = 50) long_disp <- dispersal(samc_obj, init_prob_data) #>  #> Cached diagonal not found. #> Performing setup. This can take several minutes... Complete. #> Calculating matrix inverse diagonal... #>  Computing: 49%  (~10s remaining)        Computing: 95%  (~0s remaining)        Computing: 100% (done)                          #>  Complete                                                       #> Diagonal has been cached. Continuing with metric calculation... visit <- visitation(samc_obj, dest = 4) surv <- survival(samc_obj)   # Use the map() function to turn vector results into RasterLayer objects. short_mort_map <- map(samc_obj, short_mort) short_dist_map <- map(samc_obj, short_dist) long_disp_map <- map(samc_obj, long_disp) visit_map <- map(samc_obj, visit) surv_map <- map(samc_obj, surv)"},{"path":"/reference/distribution.html","id":null,"dir":"Reference","previous_headings":"","what":"Calculate distribution metrics — distribution","title":"Calculate distribution metrics — distribution","text":"Calculate probability transient state specific time.","code":""},{"path":"/reference/distribution.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Calculate distribution metrics — distribution","text":"","code":"distribution(samc, init, origin, dest, time)  # S4 method for class 'samc,missing,missing,missing,numeric' distribution(samc, time)  # S4 method for class 'samc,missing,location,missing,numeric' distribution(samc, origin, time)  # S4 method for class 'samc,missing,missing,location,numeric' distribution(samc, dest, time)  # S4 method for class 'samc,missing,location,location,numeric' distribution(samc, origin, dest, time)  # S4 method for class 'samc,ANY,missing,missing,numeric' distribution(samc, init, time)  # S4 method for class 'samc,ANY,missing,location,numeric' distribution(samc, init, dest, time)"},{"path":"/reference/distribution.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Calculate distribution metrics — distribution","text":"samc samc-class object created using samc function. init Sets initial state \\(\\psi\\) transients states. Input must able pass check function compared samc-class object. Can contain positive finite values. origin positive integer character name representing transient state \\(\\mathit{}\\). Corresponds row \\(\\mathit{}\\) matrix \\(\\mathbf{P}\\) samc-class object. paired dest parameter, multiple values may provided vector. dest positive integer character name representing transient state \\(\\mathit{j}\\). Corresponds column \\(\\mathit{j}\\) matrix \\(\\mathbf{P}\\) samc-class object. paired origin parameter, multiple values may provided vector. time positive integer vector positive integers representing \\(\\mathit{t}\\) time steps. Vectors must ordered contain duplicates. Vectors may used metrics return dense matrices. maximum time step value capped 10,000 due numerical precision issues.","code":""},{"path":"/reference/distribution.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Calculate distribution metrics — distribution","text":"See Details","code":""},{"path":"/reference/distribution.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Calculate distribution metrics — distribution","text":"\\(Q^t\\) distribution(samc, time) result matrix \\(M\\) \\(M_{,j}\\) probability transient state \\(\\mathit{j}\\) \\(\\mathit{t}\\) time steps starting transient state \\(\\mathit{}\\). returned matrix always dense optimized. Must enable override use (see samc-class). distribution(samc, origin, time) result vector \\(\\mathbf{v}\\) \\(\\mathbf{v}_j\\) probability transient state \\(\\mathit{j}\\) \\(\\mathit{t}\\) time steps starting transient state \\(\\mathit{}\\). multiple time steps provided vector, result ordered named list containing vector time step. samc-class object created using matrix RasterLayer maps, vector \\(\\mathbf{v}\\) can mapped RasterLayer using map function. distribution(samc, dest, time) result vector \\(\\mathbf{v}\\) \\(\\mathbf{v}_i\\) probability transient state \\(\\mathit{j}\\) \\(\\mathit{t}\\) time steps starting transient state \\(\\mathit{}\\). multiple time steps provided vector, result ordered named list containing vector time step. samc-class object created using matrix RasterLayer maps, vector \\(\\mathbf{v}\\) can mapped RasterLayer using map function. distribution(samc, origin, dest, time) result numeric value probability transient state \\(\\mathit{j}\\) \\(\\mathit{t}\\) time steps starting transient state \\(\\mathit{}\\). multiple time steps provided vector, result ordered named list containing vector time step. \\(\\psi^TQ^t\\) distribution(samc, init, time) result vector \\(\\mathbf{v}\\) \\(\\mathbf{v}_j\\) probability transient state \\(\\mathit{}\\) \\(\\mathit{t}\\) time steps given initial state \\(\\psi\\). multiple time steps provided vector, result ordered named list containing vector time step. samc-class object created using matrix RasterLayer maps, vector \\(\\mathbf{v}\\) can mapped RasterLayer using map function.","code":""},{"path":"/reference/distribution.html","id":"performance","dir":"Reference","previous_headings":"","what":"Performance","title":"Calculate distribution metrics — distribution","text":"relevant performance information function can found performance vignette: vignette(\"performance\", package = \"samc\")","code":""},{"path":"/reference/distribution.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Calculate distribution metrics — distribution","text":"","code":"# \"Load\" the data. In this case we are using data built into the package. # In practice, users will likely load raster data using the raster() function # from the raster package. res_data <- samc::example_split_corridor$res abs_data <- samc::example_split_corridor$abs init_data <- samc::example_split_corridor$init   # Make sure our data meets the basic input requirements of the package using # the check() function. check(res_data, abs_data) #> [1] TRUE check(res_data, init_data) #> [1] TRUE  # Setup the details for a random-walk model rw_model <- list(fun = function(x) 1/mean(x), # Function for calculating transition probabilities                  dir = 8, # Directions of the transitions. Either 4 or 8.                  sym = TRUE) # Is the function symmetric?   # Create a `samc-class` object with the resistance and absorption data using # the samc() function. We use the recipricol of the arithmetic mean for # calculating the transition matrix. Note, the input data here are matrices, # not RasterLayers. samc_obj <- samc(res_data, abs_data, model = rw_model)   # Convert the initial state data to probabilities init_prob_data <- init_data / sum(init_data, na.rm = TRUE)   # Calculate short- and long-term metrics using the analytical functions short_mort <- mortality(samc_obj, init_prob_data, time = 50) short_dist <- distribution(samc_obj, origin = 3, time = 50) long_disp <- dispersal(samc_obj, init_prob_data) #>  #> Cached diagonal not found. #> Performing setup. This can take several minutes... Complete. #> Calculating matrix inverse diagonal... #>  Computing: 46%  (~11s remaining)        Computing: 93%  (~1s remaining)        Computing: 100% (done)                          #>  Complete                                                       #> Diagonal has been cached. Continuing with metric calculation... visit <- visitation(samc_obj, dest = 4) surv <- survival(samc_obj)   # Use the map() function to turn vector results into RasterLayer objects. short_mort_map <- map(samc_obj, short_mort) short_dist_map <- map(samc_obj, short_dist) long_disp_map <- map(samc_obj, long_disp) visit_map <- map(samc_obj, visit) surv_map <- map(samc_obj, surv)"},{"path":"/reference/example_maze.html","id":null,"dir":"Reference","previous_headings":"","what":"Simple maze example — example_maze","title":"Simple maze example — example_maze","text":"simple maze layout.","code":""},{"path":"/reference/example_maze.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Simple maze example — example_maze","text":"","code":"example_maze"},{"path":"/reference/example_maze.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"Simple maze example — example_maze","text":"20x20 matrix.","code":""},{"path":"/reference/example_maze.html","id":"source","dir":"Reference","previous_headings":"","what":"Source","title":"Simple maze example — example_maze","text":"Generated Maze Example vignettes","code":""},{"path":"/reference/example_split_corridor.html","id":null,"dir":"Reference","previous_headings":"","what":"Simple split corridor example — example_split_corridor","title":"Simple split corridor example — example_split_corridor","text":"fabricated dataset simple split corridor. Contains resistance, absorption, occupancy data.","code":""},{"path":"/reference/example_split_corridor.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Simple split corridor example — example_split_corridor","text":"","code":"example_split_corridor"},{"path":"/reference/example_split_corridor.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"Simple split corridor example — example_split_corridor","text":"list three matrices. Matrices 34 rows 202 columns.","code":""},{"path":"/reference/example_split_corridor.html","id":"source","dir":"Reference","previous_headings":"","what":"Source","title":"Simple split corridor example — example_split_corridor","text":"Fletcher et al (2019) <doi:10.1111/ele.13333>","code":""},{"path":"/reference/example_toy_res.html","id":null,"dir":"Reference","previous_headings":"","what":"Toy resistance data — example_toy_res","title":"Toy resistance data — example_toy_res","text":"Toy resistance data used workshop IALE 2021","code":""},{"path":"/reference/example_toy_res.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Toy resistance data — example_toy_res","text":"","code":"example_toy_res"},{"path":"/reference/example_toy_res.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"Toy resistance data — example_toy_res","text":"10x10 matrix.","code":""},{"path":"/reference/example_toy_res.html","id":"source","dir":"Reference","previous_headings":"","what":"Source","title":"Toy resistance data — example_toy_res","text":"IALE 2021 workshop","code":""},{"path":"/reference/locate.html","id":null,"dir":"Reference","previous_headings":"","what":"Get cell numbers — locate","title":"Get cell numbers — locate","text":"Get cell numbers raster data","code":""},{"path":"/reference/locate.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Get cell numbers — locate","text":"","code":"locate(samc, xy)  # S4 method for class 'samc,missing' locate(samc)  # S4 method for class 'samc,ANY' locate(samc, xy)"},{"path":"/reference/locate.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Get cell numbers — locate","text":"samc samc-class object xy valid input y argument extract function raster package.","code":""},{"path":"/reference/locate.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Get cell numbers — locate","text":"SpatRaster, RasterLayer, matrix, vector","code":""},{"path":"/reference/locate.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Get cell numbers — locate","text":"function used get cell numbers raster data. numbers used origin destination values many samc metrics refer column/row numbers P matrix. P matrix derived raster data, numbers normally line cell numbers raster, always true. case raster contains NA data; cells associated data excluded P matrix. causes issues trying determine cell numbers used analyses. locate function operates --less like cellFromXY function raster package, unlike cellFromXY, locate properly accounts NA cells identifying cell numbers coordinate data. function can also used samc object created matrix inputs resistance, absorption, fidelity parameters. case, values xy coordinate parameter can column-row values caveat (1,1) bottom left corner. xy parameter can also excluded. case, function returns raster values cells contains cell number. Internally, function relies extract function raster package, valid input y argument function valid .","code":""},{"path":"/reference/locate.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Get cell numbers — locate","text":"","code":"library(terra) #> terra 1.7.83 #>  #> Attaching package: ‘terra’ #> The following object is masked from ‘package:samc’: #>  #>     rasterize library(samc)   # Load example data res_data <- samc::example_split_corridor$res abs_data <- samc::example_split_corridor$abs   # Create samc-class object samc_obj <- samc(res_data, abs_data,                  model = list(fun = function(x) 1/mean(x), dir = 8, sym = TRUE))   # We can use locate() to return an object with the cell numbers encoded as data # in the cells cell_raster <- locate(samc_obj) print(cell_raster) #>       [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] [,9] [,10] [,11] [,12] [,13] #>  [1,]   NA   NA   NA   NA   NA   NA   NA   NA   NA    NA    NA    NA    NA #>  [2,]   NA   NA   NA   NA   NA   NA   NA   NA   NA    NA    NA    NA    NA #>  [3,]   NA   NA   NA   NA   NA   NA   NA   NA   NA    NA    NA    NA    NA #>  [4,]   NA   NA   NA   NA   NA   NA   NA   NA   NA    NA    NA    NA    NA #>  [5,]   NA   NA   NA   NA   NA   NA   NA   NA   NA    NA    NA    NA    NA #>  [6,]   NA   NA   NA   NA   NA   NA   NA   NA   NA    NA    NA    NA    NA #>  [7,]   NA   NA   NA   NA   NA   NA   NA   NA   NA    NA    NA    NA    NA #>  [8,]   NA   NA   NA   NA   NA   NA   NA   NA   NA    NA    NA    NA    NA #>  [9,]   NA   NA   NA   NA   NA   NA   NA   NA   NA    NA    NA    NA    NA #> [10,]   NA   NA   NA   NA   NA   NA   NA   NA   NA    NA    NA    NA    NA #> [11,]   NA   NA   NA   NA   NA   NA   NA   NA   NA    NA    NA    NA    NA #> [12,]   NA   NA   NA   NA   NA   NA   NA   NA   NA    NA    NA    NA    NA #> [13,]   NA   NA   NA   NA   NA   NA   NA   NA   NA    NA    NA    NA    NA #> [14,]   NA   NA   NA   NA   NA 1025 1026 1027 1028  1029  1030  1031  1032 #> [15,]   NA   NA   NA   NA   NA 1103 1104 1105 1106  1107  1108  1109  1110 #> [16,]   NA   NA   NA   NA   NA 1177 1178 1179 1180  1181  1182  1183  1184 #> [17,]   NA   NA   NA   NA   NA 1247 1248 1249 1250  1251  1252  1253  1254 #> [18,]   NA   NA   NA   NA   NA 1313 1314 1315 1316  1317  1318  1319  1320 #> [19,]   NA   NA   NA   NA   NA 1379 1380 1381 1382  1383  1384  1385  1386 #> [20,]   NA   NA   NA   NA   NA 1449 1450 1451 1452  1453  1454  1455  1456 #> [21,]   NA   NA   NA   NA   NA 1523 1524 1525 1526  1527  1528  1529  1530 #> [22,]   NA   NA   NA   NA   NA   NA   NA   NA   NA    NA    NA    NA    NA #> [23,]   NA   NA   NA   NA   NA   NA   NA   NA   NA    NA    NA    NA    NA #> [24,]   NA   NA   NA   NA   NA   NA   NA   NA   NA    NA    NA    NA    NA #> [25,]   NA   NA   NA   NA   NA   NA   NA   NA   NA    NA    NA    NA    NA #> [26,]   NA   NA   NA   NA   NA   NA   NA   NA   NA    NA    NA    NA    NA #> [27,]   NA   NA   NA   NA   NA   NA   NA   NA   NA    NA    NA    NA    NA #> [28,]   NA   NA   NA   NA   NA   NA   NA   NA   NA    NA    NA    NA    NA #> [29,]   NA   NA   NA   NA   NA   NA   NA   NA   NA    NA    NA    NA    NA #> [30,]   NA   NA   NA   NA   NA   NA   NA   NA   NA    NA    NA    NA    NA #> [31,]   NA   NA   NA   NA   NA   NA   NA   NA   NA    NA    NA    NA    NA #> [32,]   NA   NA   NA   NA   NA   NA   NA   NA   NA    NA    NA    NA    NA #> [33,]   NA   NA   NA   NA   NA   NA   NA   NA   NA    NA    NA    NA    NA #> [34,]   NA   NA   NA   NA   NA   NA   NA   NA   NA    NA    NA    NA    NA #>       [,14] [,15] [,16] [,17] [,18] [,19] [,20] [,21] [,22] [,23] [,24] [,25] #>  [1,]    NA    NA    NA    NA    NA    NA    NA    NA    NA    NA    NA    NA #>  [2,]    NA    NA    NA    NA    NA    NA    NA    NA    NA    NA    NA    NA #>  [3,]    NA    NA    NA    NA    NA    NA    NA    NA    NA    NA    NA    NA #>  [4,]    NA    NA    NA    NA    NA    NA    NA    NA    NA    NA    NA    NA #>  [5,]    NA    NA    NA    NA    NA    NA    NA    NA    NA    NA    NA    NA #>  [6,]    NA    NA    NA    NA    NA    NA    NA    NA    NA    NA    NA    NA #>  [7,]    NA    NA    NA    NA    NA    NA    NA    NA    NA    NA    NA    NA #>  [8,]    NA    NA    NA    NA    NA    NA    NA    NA    NA    NA    NA    NA #>  [9,]    NA    NA    NA    NA    NA    NA    NA    NA    NA    NA    NA    NA #> [10,]    NA    NA    NA    NA    NA    NA    NA    NA    NA    NA    NA    NA #> [11,]    NA    NA    NA    NA    NA    NA    NA    NA    NA    NA    NA    NA #> [12,]    NA    NA    NA    NA    NA    NA    NA    NA    NA    NA    NA    NA #> [13,]    NA    NA    NA    NA    NA    NA    NA    NA    NA    NA    NA    NA #> [14,]  1033  1034  1035  1036  1037  1038  1039  1040  1041  1042  1043  1044 #> [15,]  1111  1112  1113  1114  1115  1116  1117  1118  1119  1120  1121  1122 #> [16,]  1185  1186  1187  1188  1189  1190  1191  1192  1193  1194  1195  1196 #> [17,]  1255  1256  1257  1258  1259  1260  1261  1262  1263  1264  1265  1266 #> [18,]  1321  1322  1323  1324  1325  1326  1327  1328  1329  1330  1331  1332 #> [19,]  1387  1388  1389  1390  1391  1392  1393  1394  1395  1396  1397  1398 #> [20,]  1457  1458  1459  1460  1461  1462  1463  1464  1465  1466  1467  1468 #> [21,]  1531  1532  1533  1534  1535  1536  1537  1538  1539  1540  1541  1542 #> [22,]    NA    NA    NA    NA    NA    NA    NA    NA    NA    NA    NA    NA #> [23,]    NA    NA    NA    NA    NA    NA    NA    NA    NA    NA    NA    NA #> [24,]    NA    NA    NA    NA    NA    NA    NA    NA    NA    NA    NA    NA #> [25,]    NA    NA    NA    NA    NA    NA    NA    NA    NA    NA    NA    NA #> [26,]    NA    NA    NA    NA    NA    NA    NA    NA    NA    NA    NA    NA #> [27,]    NA    NA    NA    NA    NA    NA    NA    NA    NA    NA    NA    NA #> [28,]    NA    NA    NA    NA    NA    NA    NA    NA    NA    NA    NA    NA #> [29,]    NA    NA    NA    NA    NA    NA    NA    NA    NA    NA    NA    NA #> [30,]    NA    NA    NA    NA    NA    NA    NA    NA    NA    NA    NA    NA #> [31,]    NA    NA    NA    NA    NA    NA    NA    NA    NA    NA    NA    NA #> [32,]    NA    NA    NA    NA    NA    NA    NA    NA    NA    NA    NA    NA #> [33,]    NA    NA    NA    NA    NA    NA    NA    NA    NA    NA    NA    NA #> [34,]    NA    NA    NA    NA    NA    NA    NA    NA    NA    NA    NA    NA #>       [,26] [,27] [,28] [,29] [,30] [,31] [,32] [,33] [,34] [,35] [,36] [,37] #>  [1,]    NA    NA    NA    NA    NA    NA    NA    NA    NA    NA    NA    NA #>  [2,]    NA    NA    NA    NA    NA    NA    NA    NA    NA    NA    NA    NA #>  [3,]    NA    NA    NA    NA    NA    NA    NA    NA    NA    NA    NA    NA #>  [4,]    NA    NA    NA    NA    NA    NA    NA    NA    NA    NA    NA    NA #>  [5,]    NA    NA    NA    NA    NA    NA    NA    NA    NA    NA    NA    NA #>  [6,]    NA    NA    NA    NA    NA    NA    NA    NA    NA    NA    NA    NA #>  [7,]    NA    NA    NA    NA    NA    NA    NA    NA    NA    NA    NA    NA #>  [8,]    NA    NA    NA    NA    NA    NA    NA    NA    NA    NA    NA    NA #>  [9,]    NA    NA    NA    NA    NA    NA    NA    NA    NA    NA    NA    NA #> [10,]    NA    NA    NA    NA    NA    NA    NA    NA    NA    NA    NA   481 #> [11,]    NA    NA    NA    NA    NA    NA    NA    NA    NA   611   612   613 #> [12,]    NA    NA    NA    NA    NA    NA    NA   745   746   747   748   749 #> [13,]    NA    NA    NA    NA    NA   883   884   885   886   887   888   889 #> [14,]  1045  1046  1047  1048  1049  1050  1051  1052  1053  1054  1055  1056 #> [15,]  1123  1124  1125  1126  1127  1128  1129  1130  1131  1132  1133  1134 #> [16,]  1197  1198  1199  1200  1201  1202  1203  1204  1205  1206  1207  1208 #> [17,]  1267  1268  1269  1270  1271  1272  1273  1274  1275  1276  1277  1278 #> [18,]  1333  1334  1335  1336  1337  1338  1339  1340  1341  1342  1343  1344 #> [19,]  1399  1400  1401  1402  1403  1404  1405  1406  1407  1408  1409  1410 #> [20,]  1469  1470  1471  1472  1473  1474  1475  1476  1477  1478  1479  1480 #> [21,]  1543  1544  1545  1546  1547  1548  1549  1550  1551  1552  1553  1554 #> [22,]    NA    NA    NA    NA    NA  1601  1602  1603  1604  1605  1606  1607 #> [23,]    NA    NA    NA    NA    NA    NA    NA  1743  1744  1745  1746  1747 #> [24,]    NA    NA    NA    NA    NA    NA    NA    NA    NA  1881  1882  1883 #> [25,]    NA    NA    NA    NA    NA    NA    NA    NA    NA    NA    NA  2015 #> [26,]    NA    NA    NA    NA    NA    NA    NA    NA    NA    NA    NA    NA #> [27,]    NA    NA    NA    NA    NA    NA    NA    NA    NA    NA    NA    NA #> [28,]    NA    NA    NA    NA    NA    NA    NA    NA    NA    NA    NA    NA #> [29,]    NA    NA    NA    NA    NA    NA    NA    NA    NA    NA    NA    NA #> [30,]    NA    NA    NA    NA    NA    NA    NA    NA    NA    NA    NA    NA #> [31,]    NA    NA    NA    NA    NA    NA    NA    NA    NA    NA    NA    NA #> [32,]    NA    NA    NA    NA    NA    NA    NA    NA    NA    NA    NA    NA #> [33,]    NA    NA    NA    NA    NA    NA    NA    NA    NA    NA    NA    NA #> [34,]    NA    NA    NA    NA    NA    NA    NA    NA    NA    NA    NA    NA #>       [,38] [,39] [,40] [,41] [,42] [,43] [,44] [,45] [,46] [,47] [,48] [,49] #>  [1,]    NA    NA    NA    NA    NA    NA    NA    NA    NA    NA    NA    NA #>  [2,]    NA    NA    NA    NA    NA    NA    NA    NA    NA    NA    NA    NA #>  [3,]    NA    NA    NA    NA    NA    NA    NA    NA    NA    NA    NA    NA #>  [4,]    NA    NA    NA    NA    NA    NA    NA    NA    NA    NA    NA    NA #>  [5,]    NA    NA    NA    NA    NA    NA    NA    NA    NA    NA    NA    NA #>  [6,]    NA    NA    NA    NA    NA    NA    NA     1     2     3     4     5 #>  [7,]    NA    NA    NA    NA    NA   115   116   117   118   119   120   121 #>  [8,]    NA    NA    NA   233   234   235   236   237   238   239   240   241 #>  [9,]    NA   355   356   357   358   359   360   361   362   363   364   365 #> [10,]   482   483   484   485   486   487   488   489   490   491   492   493 #> [11,]   614   615   616   617   618   619   620   621   622   623   624   625 #> [12,]   750   751   752   753   754   755   756   757   758   759   760   761 #> [13,]   890   891   892   893   894   895   896   897   898   899   900   901 #> [14,]  1057  1058  1059  1060  1061  1062  1063    NA    NA    NA    NA    NA #> [15,]  1135  1136  1137  1138  1139    NA    NA    NA    NA    NA    NA    NA #> [16,]  1209  1210  1211    NA    NA    NA    NA    NA    NA    NA    NA    NA #> [17,]  1279    NA    NA    NA    NA    NA    NA    NA    NA    NA    NA    NA #> [18,]  1345    NA    NA    NA    NA    NA    NA    NA    NA    NA    NA    NA #> [19,]  1411  1412  1413    NA    NA    NA    NA    NA    NA    NA    NA    NA #> [20,]  1481  1482  1483  1484  1485    NA    NA    NA    NA    NA    NA    NA #> [21,]  1555  1556  1557  1558  1559  1560  1561    NA    NA    NA    NA    NA #> [22,]  1608  1609  1610  1611  1612  1613  1614  1615  1616  1617  1618  1619 #> [23,]  1748  1749  1750  1751  1752  1753  1754  1755  1756  1757  1758  1759 #> [24,]  1884  1885  1886  1887  1888  1889  1890  1891  1892  1893  1894  1895 #> [25,]  2016  2017  2018  2019  2020  2021  2022  2023  2024  2025  2026  2027 #> [26,]    NA  2145  2146  2147  2148  2149  2150  2151  2152  2153  2154  2155 #> [27,]    NA    NA    NA  2271  2272  2273  2274  2275  2276  2277  2278  2279 #> [28,]    NA    NA    NA    NA    NA  2393  2394  2395  2396  2397  2398  2399 #> [29,]    NA    NA    NA    NA    NA    NA    NA  2511  2512  2513  2514  2515 #> [30,]    NA    NA    NA    NA    NA    NA    NA    NA    NA    NA    NA    NA #> [31,]    NA    NA    NA    NA    NA    NA    NA    NA    NA    NA    NA    NA #> [32,]    NA    NA    NA    NA    NA    NA    NA    NA    NA    NA    NA    NA #> [33,]    NA    NA    NA    NA    NA    NA    NA    NA    NA    NA    NA    NA #> [34,]    NA    NA    NA    NA    NA    NA    NA    NA    NA    NA    NA    NA #>       [,50] [,51] [,52] [,53] [,54] [,55] [,56] [,57] [,58] [,59] [,60] [,61] #>  [1,]    NA    NA    NA    NA    NA    NA    NA    NA    NA    NA    NA    NA #>  [2,]    NA    NA    NA    NA    NA    NA    NA    NA    NA    NA    NA    NA #>  [3,]    NA    NA    NA    NA    NA    NA    NA    NA    NA    NA    NA    NA #>  [4,]    NA    NA    NA    NA    NA    NA    NA    NA    NA    NA    NA    NA #>  [5,]    NA    NA    NA    NA    NA    NA    NA    NA    NA    NA    NA    NA #>  [6,]     6     7     8     9    10    11    12    13    14    15    16    17 #>  [7,]   122   123   124   125   126   127   128   129   130   131   132   133 #>  [8,]   242   243   244   245   246   247   248   249   250   251   252   253 #>  [9,]   366   367   368   369   370   371   372   373   374   375   376   377 #> [10,]   494   495   496   497   498   499   500   501   502   503   504   505 #> [11,]   626   627   628   629   630   631   632   633   634   635   636   637 #> [12,]   762   763   764   765   766   767   768   769   770   771   772   773 #> [13,]   902   903   904   905   906   907   908   909   910   911   912   913 #> [14,]    NA    NA    NA    NA    NA    NA    NA    NA    NA    NA    NA    NA #> [15,]    NA    NA    NA    NA    NA    NA    NA    NA    NA    NA    NA    NA #> [16,]    NA    NA    NA    NA    NA    NA    NA    NA    NA    NA    NA    NA #> [17,]    NA    NA    NA    NA    NA    NA    NA    NA    NA    NA    NA    NA #> [18,]    NA    NA    NA    NA    NA    NA    NA    NA    NA    NA    NA    NA #> [19,]    NA    NA    NA    NA    NA    NA    NA    NA    NA    NA    NA    NA #> [20,]    NA    NA    NA    NA    NA    NA    NA    NA    NA    NA    NA    NA #> [21,]    NA    NA    NA    NA    NA    NA    NA    NA    NA    NA    NA    NA #> [22,]  1620  1621  1622  1623  1624  1625  1626  1627  1628  1629  1630  1631 #> [23,]  1760  1761  1762  1763  1764  1765  1766  1767  1768  1769  1770  1771 #> [24,]  1896  1897  1898  1899  1900  1901  1902  1903  1904  1905  1906  1907 #> [25,]  2028  2029  2030  2031  2032  2033  2034  2035  2036  2037  2038  2039 #> [26,]  2156  2157  2158  2159  2160  2161  2162  2163  2164  2165  2166  2167 #> [27,]  2280  2281  2282  2283  2284  2285  2286  2287  2288  2289  2290  2291 #> [28,]  2400  2401  2402  2403  2404  2405  2406  2407  2408  2409  2410  2411 #> [29,]  2516  2517  2518  2519  2520  2521  2522  2523  2524  2525  2526  2527 #> [30,]    NA    NA    NA    NA    NA    NA    NA    NA    NA    NA    NA    NA #> [31,]    NA    NA    NA    NA    NA    NA    NA    NA    NA    NA    NA    NA #> [32,]    NA    NA    NA    NA    NA    NA    NA    NA    NA    NA    NA    NA #> [33,]    NA    NA    NA    NA    NA    NA    NA    NA    NA    NA    NA    NA #> [34,]    NA    NA    NA    NA    NA    NA    NA    NA    NA    NA    NA    NA #>       [,62] [,63] [,64] [,65] [,66] [,67] [,68] [,69] [,70] [,71] [,72] [,73] #>  [1,]    NA    NA    NA    NA    NA    NA    NA    NA    NA    NA    NA    NA #>  [2,]    NA    NA    NA    NA    NA    NA    NA    NA    NA    NA    NA    NA #>  [3,]    NA    NA    NA    NA    NA    NA    NA    NA    NA    NA    NA    NA #>  [4,]    NA    NA    NA    NA    NA    NA    NA    NA    NA    NA    NA    NA #>  [5,]    NA    NA    NA    NA    NA    NA    NA    NA    NA    NA    NA    NA #>  [6,]    18    19    20    21    22    23    24    25    26    27    28    29 #>  [7,]   134   135   136   137   138   139   140   141   142   143   144   145 #>  [8,]   254   255   256   257   258   259   260   261   262   263   264   265 #>  [9,]   378   379   380   381   382   383   384   385   386   387   388   389 #> [10,]   506   507   508   509   510   511   512   513   514   515   516   517 #> [11,]   638   639   640   641   642   643   644   645   646   647   648   649 #> [12,]   774   775   776   777   778   779   780   781   782   783   784   785 #> [13,]   914   915   916   917   918   919   920   921   922   923   924   925 #> [14,]    NA    NA    NA    NA    NA    NA    NA    NA    NA    NA    NA    NA #> [15,]    NA    NA    NA    NA    NA    NA    NA    NA    NA    NA    NA    NA #> [16,]    NA    NA    NA    NA    NA    NA    NA    NA    NA    NA    NA    NA #> [17,]    NA    NA    NA    NA    NA    NA    NA    NA    NA    NA    NA    NA #> [18,]    NA    NA    NA    NA    NA    NA    NA    NA    NA    NA    NA    NA #> [19,]    NA    NA    NA    NA    NA    NA    NA    NA    NA    NA    NA    NA #> [20,]    NA    NA    NA    NA    NA    NA    NA    NA    NA    NA    NA    NA #> [21,]    NA    NA    NA    NA    NA    NA    NA    NA    NA    NA    NA    NA #> [22,]  1632  1633  1634  1635  1636  1637  1638  1639  1640  1641  1642  1643 #> [23,]  1772  1773  1774  1775  1776  1777  1778  1779  1780  1781  1782  1783 #> [24,]  1908  1909  1910  1911  1912  1913  1914  1915  1916  1917  1918  1919 #> [25,]  2040  2041  2042  2043  2044  2045  2046  2047  2048  2049  2050  2051 #> [26,]  2168  2169  2170  2171  2172  2173  2174  2175  2176  2177  2178  2179 #> [27,]  2292  2293  2294  2295  2296  2297  2298  2299  2300  2301  2302  2303 #> [28,]  2412  2413  2414  2415  2416  2417  2418  2419  2420  2421  2422  2423 #> [29,]  2528  2529  2530  2531  2532  2533  2534  2535  2536  2537  2538  2539 #> [30,]    NA    NA    NA    NA    NA    NA    NA    NA    NA    NA    NA    NA #> [31,]    NA    NA    NA    NA    NA    NA    NA    NA    NA    NA    NA    NA #> [32,]    NA    NA    NA    NA    NA    NA    NA    NA    NA    NA    NA    NA #> [33,]    NA    NA    NA    NA    NA    NA    NA    NA    NA    NA    NA    NA #> [34,]    NA    NA    NA    NA    NA    NA    NA    NA    NA    NA    NA    NA #>       [,74] [,75] [,76] [,77] [,78] [,79] [,80] [,81] [,82] [,83] [,84] [,85] #>  [1,]    NA    NA    NA    NA    NA    NA    NA    NA    NA    NA    NA    NA #>  [2,]    NA    NA    NA    NA    NA    NA    NA    NA    NA    NA    NA    NA #>  [3,]    NA    NA    NA    NA    NA    NA    NA    NA    NA    NA    NA    NA #>  [4,]    NA    NA    NA    NA    NA    NA    NA    NA    NA    NA    NA    NA #>  [5,]    NA    NA    NA    NA    NA    NA    NA    NA    NA    NA    NA    NA #>  [6,]    30    31    32    33    34    35    36    37    38    39    40    41 #>  [7,]   146   147   148   149   150   151   152   153   154   155   156   157 #>  [8,]   266   267   268   269   270   271   272   273   274   275   276   277 #>  [9,]   390   391   392   393   394   395   396   397   398   399   400   401 #> [10,]   518   519   520   521   522   523   524   525   526   527   528   529 #> [11,]   650   651   652   653   654   655   656   657   658   659   660   661 #> [12,]   786   787   788   789   790   791   792   793   794   795   796   797 #> [13,]   926   927   928   929   930   931   932   933   934   935   936   937 #> [14,]    NA    NA    NA    NA    NA    NA    NA    NA    NA    NA    NA    NA #> [15,]    NA    NA    NA    NA    NA    NA    NA    NA    NA    NA    NA    NA #> [16,]    NA    NA    NA    NA    NA    NA    NA    NA    NA    NA    NA    NA #> [17,]    NA    NA    NA    NA    NA    NA    NA    NA    NA    NA    NA    NA #> [18,]    NA    NA    NA    NA    NA    NA    NA    NA    NA    NA    NA    NA #> [19,]    NA    NA    NA    NA    NA    NA    NA    NA    NA    NA    NA    NA #> [20,]    NA    NA    NA    NA    NA    NA    NA    NA    NA    NA    NA    NA #> [21,]    NA    NA    NA    NA    NA    NA    NA    NA    NA    NA    NA    NA #> [22,]  1644  1645  1646  1647  1648  1649  1650  1651  1652  1653  1654  1655 #> [23,]  1784  1785  1786  1787  1788  1789  1790  1791  1792  1793  1794  1795 #> [24,]  1920  1921  1922  1923  1924  1925  1926  1927  1928  1929  1930  1931 #> [25,]  2052  2053  2054  2055  2056  2057  2058  2059  2060  2061  2062  2063 #> [26,]  2180  2181  2182  2183  2184  2185  2186  2187  2188  2189  2190  2191 #> [27,]  2304  2305  2306  2307  2308  2309  2310  2311  2312  2313  2314  2315 #> [28,]  2424  2425  2426  2427  2428  2429  2430  2431  2432  2433  2434  2435 #> [29,]  2540  2541  2542  2543  2544  2545  2546  2547  2548  2549  2550  2551 #> [30,]    NA    NA    NA    NA    NA    NA    NA    NA    NA    NA    NA    NA #> [31,]    NA    NA    NA    NA    NA    NA    NA    NA    NA    NA    NA    NA #> [32,]    NA    NA    NA    NA    NA    NA    NA    NA    NA    NA    NA    NA #> [33,]    NA    NA    NA    NA    NA    NA    NA    NA    NA    NA    NA    NA #> [34,]    NA    NA    NA    NA    NA    NA    NA    NA    NA    NA    NA    NA #>       [,86] [,87] [,88] [,89] [,90] [,91] [,92] [,93] [,94] [,95] [,96] [,97] #>  [1,]    NA    NA    NA    NA    NA    NA    NA    NA    NA    NA    NA    NA #>  [2,]    NA    NA    NA    NA    NA    NA    NA    NA    NA    NA    NA    NA #>  [3,]    NA    NA    NA    NA    NA    NA    NA    NA    NA    NA    NA    NA #>  [4,]    NA    NA    NA    NA    NA    NA    NA    NA    NA    NA    NA    NA #>  [5,]    NA    NA    NA    NA    NA    NA    NA    NA    NA    NA    NA    NA #>  [6,]    42    43    44    45    46    47    48    49    50    51    52    53 #>  [7,]   158   159   160   161   162   163   164   165   166   167   168   169 #>  [8,]   278   279   280   281   282   283   284   285   286   287   288   289 #>  [9,]   402   403   404   405   406   407   408   409   410   411   412   413 #> [10,]   530   531   532   533   534   535   536   537   538   539   540   541 #> [11,]   662   663   664   665   666   667   668   669   670   671   672   673 #> [12,]   798   799   800   801   802   803   804   805   806   807   808   809 #> [13,]   938   939   940   941   942   943   944   945   946   947   948   949 #> [14,]    NA    NA    NA    NA    NA    NA    NA    NA    NA    NA    NA    NA #> [15,]    NA    NA    NA    NA    NA    NA    NA    NA    NA    NA    NA    NA #> [16,]    NA    NA    NA    NA    NA    NA    NA    NA    NA    NA    NA    NA #> [17,]    NA    NA    NA    NA    NA    NA    NA    NA    NA    NA    NA    NA #> [18,]    NA    NA    NA    NA    NA    NA    NA    NA    NA    NA    NA    NA #> [19,]    NA    NA    NA    NA    NA    NA    NA    NA    NA    NA    NA    NA #> [20,]    NA    NA    NA    NA    NA    NA    NA    NA    NA    NA    NA    NA #> [21,]    NA    NA    NA    NA    NA    NA    NA    NA    NA    NA    NA    NA #> [22,]  1656  1657  1658  1659  1660  1661  1662  1663  1664  1665  1666  1667 #> [23,]  1796  1797  1798  1799  1800  1801  1802  1803  1804  1805  1806  1807 #> [24,]  1932  1933  1934  1935  1936  1937  1938  1939  1940  1941  1942  1943 #> [25,]  2064  2065  2066  2067  2068  2069  2070  2071  2072  2073  2074  2075 #> [26,]  2192  2193  2194  2195  2196  2197  2198  2199  2200  2201  2202  2203 #> [27,]  2316  2317  2318  2319  2320  2321  2322  2323  2324  2325  2326  2327 #> [28,]  2436  2437  2438  2439  2440  2441  2442  2443  2444  2445  2446  2447 #> [29,]  2552  2553  2554  2555  2556  2557  2558  2559  2560  2561  2562  2563 #> [30,]    NA    NA    NA    NA    NA    NA    NA    NA    NA    NA    NA    NA #> [31,]    NA    NA    NA    NA    NA    NA    NA    NA    NA    NA    NA    NA #> [32,]    NA    NA    NA    NA    NA    NA    NA    NA    NA    NA    NA    NA #> [33,]    NA    NA    NA    NA    NA    NA    NA    NA    NA    NA    NA    NA #> [34,]    NA    NA    NA    NA    NA    NA    NA    NA    NA    NA    NA    NA #>       [,98] [,99] [,100] [,101] [,102] [,103] [,104] [,105] [,106] [,107] #>  [1,]    NA    NA     NA     NA     NA     NA     NA     NA     NA     NA #>  [2,]    NA    NA     NA     NA     NA     NA     NA     NA     NA     NA #>  [3,]    NA    NA     NA     NA     NA     NA     NA     NA     NA     NA #>  [4,]    NA    NA     NA     NA     NA     NA     NA     NA     NA     NA #>  [5,]    NA    NA     NA     NA     NA     NA     NA     NA     NA     NA #>  [6,]    54    55     56     57     58     59     60     61     62     63 #>  [7,]   170   171    172    173    174    175    176    177    178    179 #>  [8,]   290   291    292    293    294    295    296    297    298    299 #>  [9,]   414   415    416    417    418    419    420    421    422    423 #> [10,]   542   543    544    545    546    547    548    549    550    551 #> [11,]   674   675    676    677    678    679    680    681    682    683 #> [12,]   810   811    812    813    814    815    816    817    818    819 #> [13,]   950   951    952    953    954    955    956    957    958    959 #> [14,]    NA    NA     NA     NA     NA     NA     NA     NA     NA     NA #> [15,]    NA    NA     NA     NA     NA     NA     NA     NA     NA     NA #> [16,]    NA    NA     NA     NA     NA     NA     NA     NA     NA     NA #> [17,]    NA    NA     NA     NA     NA     NA     NA     NA     NA     NA #> [18,]    NA    NA     NA     NA     NA     NA     NA     NA     NA     NA #> [19,]    NA    NA     NA     NA     NA     NA     NA     NA     NA     NA #> [20,]    NA    NA     NA     NA     NA     NA     NA     NA     NA     NA #> [21,]    NA    NA     NA     NA     NA     NA     NA     NA     NA     NA #> [22,]  1668  1669   1670   1671   1672   1673   1674   1675   1676   1677 #> [23,]  1808  1809   1810   1811   1812   1813   1814   1815   1816   1817 #> [24,]  1944  1945   1946   1947   1948   1949   1950   1951   1952   1953 #> [25,]  2076  2077   2078   2079   2080   2081   2082   2083   2084   2085 #> [26,]  2204  2205   2206   2207   2208   2209   2210   2211   2212   2213 #> [27,]  2328  2329   2330   2331   2332   2333   2334   2335   2336   2337 #> [28,]  2448  2449   2450   2451   2452   2453   2454   2455   2456   2457 #> [29,]  2564  2565   2566   2567   2568   2569   2570   2571   2572   2573 #> [30,]    NA    NA     NA     NA     NA     NA     NA     NA     NA     NA #> [31,]    NA    NA     NA     NA     NA     NA     NA     NA     NA     NA #> [32,]    NA    NA     NA     NA     NA     NA     NA     NA     NA     NA #> [33,]    NA    NA     NA     NA     NA     NA     NA     NA     NA     NA #> [34,]    NA    NA     NA     NA     NA     NA     NA     NA     NA     NA #>       [,108] [,109] [,110] [,111] [,112] [,113] [,114] [,115] [,116] [,117] #>  [1,]     NA     NA     NA     NA     NA     NA     NA     NA     NA     NA #>  [2,]     NA     NA     NA     NA     NA     NA     NA     NA     NA     NA #>  [3,]     NA     NA     NA     NA     NA     NA     NA     NA     NA     NA #>  [4,]     NA     NA     NA     NA     NA     NA     NA     NA     NA     NA #>  [5,]     NA     NA     NA     NA     NA     NA     NA     NA     NA     NA #>  [6,]     64     65     66     67     68     69     70     71     72     73 #>  [7,]    180    181    182    183    184    185    186    187    188    189 #>  [8,]    300    301    302    303    304    305    306    307    308    309 #>  [9,]    424    425    426    427    428    429    430    431    432    433 #> [10,]    552    553    554    555    556    557    558    559    560    561 #> [11,]    684    685    686    687    688    689    690    691    692    693 #> [12,]    820    821    822    823    824    825    826    827    828    829 #> [13,]    960    961    962    963    964    965    966    967    968    969 #> [14,]     NA     NA     NA     NA     NA     NA     NA     NA     NA     NA #> [15,]     NA     NA     NA     NA     NA     NA     NA     NA     NA     NA #> [16,]     NA     NA     NA     NA     NA     NA     NA     NA     NA     NA #> [17,]     NA     NA     NA     NA     NA     NA     NA     NA     NA     NA #> [18,]     NA     NA     NA     NA     NA     NA     NA     NA     NA     NA #> [19,]     NA     NA     NA     NA     NA     NA     NA     NA     NA     NA #> [20,]     NA     NA     NA     NA     NA     NA     NA     NA     NA     NA #> [21,]     NA     NA     NA     NA     NA     NA     NA     NA     NA     NA #> [22,]   1678   1679   1680   1681   1682   1683   1684   1685   1686   1687 #> [23,]   1818   1819   1820   1821   1822   1823   1824   1825   1826   1827 #> [24,]   1954   1955   1956   1957   1958   1959   1960   1961   1962   1963 #> [25,]   2086   2087   2088   2089   2090   2091   2092   2093   2094   2095 #> [26,]   2214   2215   2216   2217   2218   2219   2220   2221   2222   2223 #> [27,]   2338   2339   2340   2341   2342   2343   2344   2345   2346   2347 #> [28,]   2458   2459   2460   2461   2462   2463   2464   2465   2466   2467 #> [29,]   2574   2575   2576   2577   2578   2579   2580   2581   2582   2583 #> [30,]     NA     NA     NA     NA     NA     NA     NA     NA     NA     NA #> [31,]     NA     NA     NA     NA     NA     NA     NA     NA     NA     NA #> [32,]     NA     NA     NA     NA     NA     NA     NA     NA     NA     NA #> [33,]     NA     NA     NA     NA     NA     NA     NA     NA     NA     NA #> [34,]     NA     NA     NA     NA     NA     NA     NA     NA     NA     NA #>       [,118] [,119] [,120] [,121] [,122] [,123] [,124] [,125] [,126] [,127] #>  [1,]     NA     NA     NA     NA     NA     NA     NA     NA     NA     NA #>  [2,]     NA     NA     NA     NA     NA     NA     NA     NA     NA     NA #>  [3,]     NA     NA     NA     NA     NA     NA     NA     NA     NA     NA #>  [4,]     NA     NA     NA     NA     NA     NA     NA     NA     NA     NA #>  [5,]     NA     NA     NA     NA     NA     NA     NA     NA     NA     NA #>  [6,]     74     75     76     77     78     79     80     81     82     83 #>  [7,]    190    191    192    193    194    195    196    197    198    199 #>  [8,]    310    311    312    313    314    315    316    317    318    319 #>  [9,]    434    435    436    437    438    439    440    441    442    443 #> [10,]    562    563    564    565    566    567    568    569    570    571 #> [11,]    694    695    696    697    698    699    700    701    702    703 #> [12,]    830    831    832    833    834    835    836    837    838    839 #> [13,]    970    971    972    973    974    975    976    977    978    979 #> [14,]     NA     NA     NA     NA     NA     NA     NA     NA     NA     NA #> [15,]     NA     NA     NA     NA     NA     NA     NA     NA     NA     NA #> [16,]     NA     NA     NA     NA     NA     NA     NA     NA     NA     NA #> [17,]     NA     NA     NA     NA     NA     NA     NA     NA     NA     NA #> [18,]     NA     NA     NA     NA     NA     NA     NA     NA     NA     NA #> [19,]     NA     NA     NA     NA     NA     NA     NA     NA     NA     NA #> [20,]     NA     NA     NA     NA     NA     NA     NA     NA     NA     NA #> [21,]     NA     NA     NA     NA     NA     NA     NA     NA     NA     NA #> [22,]   1688   1689   1690   1691   1692   1693   1694   1695   1696   1697 #> [23,]   1828   1829   1830   1831   1832   1833   1834   1835   1836   1837 #> [24,]   1964   1965   1966   1967   1968   1969   1970   1971   1972   1973 #> [25,]   2096   2097   2098   2099   2100   2101   2102   2103   2104   2105 #> [26,]   2224   2225   2226   2227   2228   2229   2230   2231   2232   2233 #> [27,]   2348   2349   2350   2351   2352   2353   2354   2355   2356   2357 #> [28,]   2468   2469   2470   2471   2472   2473   2474   2475   2476   2477 #> [29,]   2584   2585   2586   2587   2588   2589   2590   2591   2592   2593 #> [30,]     NA     NA     NA     NA     NA     NA     NA     NA     NA     NA #> [31,]     NA     NA     NA     NA     NA     NA     NA     NA     NA     NA #> [32,]     NA     NA     NA     NA     NA     NA     NA     NA     NA     NA #> [33,]     NA     NA     NA     NA     NA     NA     NA     NA     NA     NA #> [34,]     NA     NA     NA     NA     NA     NA     NA     NA     NA     NA #>       [,128] [,129] [,130] [,131] [,132] [,133] [,134] [,135] [,136] [,137] #>  [1,]     NA     NA     NA     NA     NA     NA     NA     NA     NA     NA #>  [2,]     NA     NA     NA     NA     NA     NA     NA     NA     NA     NA #>  [3,]     NA     NA     NA     NA     NA     NA     NA     NA     NA     NA #>  [4,]     NA     NA     NA     NA     NA     NA     NA     NA     NA     NA #>  [5,]     NA     NA     NA     NA     NA     NA     NA     NA     NA     NA #>  [6,]     84     85     86     87     88     89     90     91     92     93 #>  [7,]    200    201    202    203    204    205    206    207    208    209 #>  [8,]    320    321    322    323    324    325    326    327    328    329 #>  [9,]    444    445    446    447    448    449    450    451    452    453 #> [10,]    572    573    574    575    576    577    578    579    580    581 #> [11,]    704    705    706    707    708    709    710    711    712    713 #> [12,]    840    841    842    843    844    845    846    847    848    849 #> [13,]    980    981    982    983    984    985    986    987    988    989 #> [14,]     NA     NA     NA     NA     NA     NA     NA     NA     NA     NA #> [15,]     NA     NA     NA     NA     NA     NA     NA     NA     NA     NA #> [16,]     NA     NA     NA     NA     NA     NA     NA     NA     NA     NA #> [17,]     NA     NA     NA     NA     NA     NA     NA     NA     NA     NA #> [18,]     NA     NA     NA     NA     NA     NA     NA     NA     NA     NA #> [19,]     NA     NA     NA     NA     NA     NA     NA     NA     NA     NA #> [20,]     NA     NA     NA     NA     NA     NA     NA     NA     NA     NA #> [21,]     NA     NA     NA     NA     NA     NA     NA     NA     NA     NA #> [22,]   1698   1699   1700   1701   1702   1703   1704   1705   1706   1707 #> [23,]   1838   1839   1840   1841   1842   1843   1844   1845   1846   1847 #> [24,]   1974   1975   1976   1977   1978   1979   1980   1981   1982   1983 #> [25,]   2106   2107   2108   2109   2110   2111   2112   2113   2114   2115 #> [26,]   2234   2235   2236   2237   2238   2239   2240   2241   2242   2243 #> [27,]   2358   2359   2360   2361   2362   2363   2364   2365   2366   2367 #> [28,]   2478   2479   2480   2481   2482   2483   2484   2485   2486   2487 #> [29,]   2594   2595   2596   2597   2598   2599   2600   2601   2602   2603 #> [30,]     NA     NA     NA     NA     NA     NA     NA     NA     NA     NA #> [31,]     NA     NA     NA     NA     NA     NA     NA     NA     NA     NA #> [32,]     NA     NA     NA     NA     NA     NA     NA     NA     NA     NA #> [33,]     NA     NA     NA     NA     NA     NA     NA     NA     NA     NA #> [34,]     NA     NA     NA     NA     NA     NA     NA     NA     NA     NA #>       [,138] [,139] [,140] [,141] [,142] [,143] [,144] [,145] [,146] [,147] #>  [1,]     NA     NA     NA     NA     NA     NA     NA     NA     NA     NA #>  [2,]     NA     NA     NA     NA     NA     NA     NA     NA     NA     NA #>  [3,]     NA     NA     NA     NA     NA     NA     NA     NA     NA     NA #>  [4,]     NA     NA     NA     NA     NA     NA     NA     NA     NA     NA #>  [5,]     NA     NA     NA     NA     NA     NA     NA     NA     NA     NA #>  [6,]     94     95     96     97     98     99    100    101    102    103 #>  [7,]    210    211    212    213    214    215    216    217    218    219 #>  [8,]    330    331    332    333    334    335    336    337    338    339 #>  [9,]    454    455    456    457    458    459    460    461    462    463 #> [10,]    582    583    584    585    586    587    588    589    590    591 #> [11,]    714    715    716    717    718    719    720    721    722    723 #> [12,]    850    851    852    853    854    855    856    857    858    859 #> [13,]    990    991    992    993    994    995    996    997    998    999 #> [14,]     NA     NA     NA     NA     NA     NA     NA     NA     NA     NA #> [15,]     NA     NA     NA     NA     NA     NA     NA     NA     NA     NA #> [16,]     NA     NA     NA     NA     NA     NA     NA     NA     NA     NA #> [17,]     NA     NA     NA     NA     NA     NA     NA     NA     NA     NA #> [18,]     NA     NA     NA     NA     NA     NA     NA     NA     NA     NA #> [19,]     NA     NA     NA     NA     NA     NA     NA     NA     NA     NA #> [20,]     NA     NA     NA     NA     NA     NA     NA     NA     NA     NA #> [21,]     NA     NA     NA     NA     NA     NA     NA     NA     NA     NA #> [22,]   1708   1709   1710   1711   1712   1713   1714   1715   1716   1717 #> [23,]   1848   1849   1850   1851   1852   1853   1854   1855   1856   1857 #> [24,]   1984   1985   1986   1987   1988   1989   1990   1991   1992   1993 #> [25,]   2116   2117   2118   2119   2120   2121   2122   2123   2124   2125 #> [26,]   2244   2245   2246   2247   2248   2249   2250   2251   2252   2253 #> [27,]   2368   2369   2370   2371   2372   2373   2374   2375   2376   2377 #> [28,]   2488   2489   2490   2491   2492   2493   2494   2495   2496   2497 #> [29,]   2604   2605   2606   2607   2608   2609   2610   2611   2612   2613 #> [30,]     NA     NA     NA     NA     NA     NA     NA     NA     NA     NA #> [31,]     NA     NA     NA     NA     NA     NA     NA     NA     NA     NA #> [32,]     NA     NA     NA     NA     NA     NA     NA     NA     NA     NA #> [33,]     NA     NA     NA     NA     NA     NA     NA     NA     NA     NA #> [34,]     NA     NA     NA     NA     NA     NA     NA     NA     NA     NA #>       [,148] [,149] [,150] [,151] [,152] [,153] [,154] [,155] [,156] [,157] #>  [1,]     NA     NA     NA     NA     NA     NA     NA     NA     NA     NA #>  [2,]     NA     NA     NA     NA     NA     NA     NA     NA     NA     NA #>  [3,]     NA     NA     NA     NA     NA     NA     NA     NA     NA     NA #>  [4,]     NA     NA     NA     NA     NA     NA     NA     NA     NA     NA #>  [5,]     NA     NA     NA     NA     NA     NA     NA     NA     NA     NA #>  [6,]    104    105    106    107    108    109    110    111    112    113 #>  [7,]    220    221    222    223    224    225    226    227    228    229 #>  [8,]    340    341    342    343    344    345    346    347    348    349 #>  [9,]    464    465    466    467    468    469    470    471    472    473 #> [10,]    592    593    594    595    596    597    598    599    600    601 #> [11,]    724    725    726    727    728    729    730    731    732    733 #> [12,]    860    861    862    863    864    865    866    867    868    869 #> [13,]   1000   1001   1002   1003   1004   1005   1006   1007   1008   1009 #> [14,]     NA     NA     NA     NA     NA     NA     NA     NA     NA     NA #> [15,]     NA     NA     NA     NA     NA     NA     NA     NA     NA     NA #> [16,]     NA     NA     NA     NA     NA     NA     NA     NA     NA     NA #> [17,]     NA     NA     NA     NA     NA     NA     NA     NA     NA     NA #> [18,]     NA     NA     NA     NA     NA     NA     NA     NA     NA     NA #> [19,]     NA     NA     NA     NA     NA     NA     NA     NA     NA     NA #> [20,]     NA     NA     NA     NA     NA     NA     NA     NA     NA     NA #> [21,]     NA     NA     NA     NA     NA     NA     NA     NA     NA     NA #> [22,]   1718   1719   1720   1721   1722   1723   1724   1725   1726   1727 #> [23,]   1858   1859   1860   1861   1862   1863   1864   1865   1866   1867 #> [24,]   1994   1995   1996   1997   1998   1999   2000   2001   2002   2003 #> [25,]   2126   2127   2128   2129   2130   2131   2132   2133   2134   2135 #> [26,]   2254   2255   2256   2257   2258   2259   2260   2261   2262   2263 #> [27,]   2378   2379   2380   2381   2382   2383   2384   2385   2386   2387 #> [28,]   2498   2499   2500   2501   2502   2503   2504   2505   2506   2507 #> [29,]   2614   2615   2616   2617   2618   2619   2620   2621   2622   2623 #> [30,]     NA     NA     NA     NA     NA     NA     NA     NA     NA     NA #> [31,]     NA     NA     NA     NA     NA     NA     NA     NA     NA     NA #> [32,]     NA     NA     NA     NA     NA     NA     NA     NA     NA     NA #> [33,]     NA     NA     NA     NA     NA     NA     NA     NA     NA     NA #> [34,]     NA     NA     NA     NA     NA     NA     NA     NA     NA     NA #>       [,158] [,159] [,160] [,161] [,162] [,163] [,164] [,165] [,166] [,167] #>  [1,]     NA     NA     NA     NA     NA     NA     NA     NA     NA     NA #>  [2,]     NA     NA     NA     NA     NA     NA     NA     NA     NA     NA #>  [3,]     NA     NA     NA     NA     NA     NA     NA     NA     NA     NA #>  [4,]     NA     NA     NA     NA     NA     NA     NA     NA     NA     NA #>  [5,]     NA     NA     NA     NA     NA     NA     NA     NA     NA     NA #>  [6,]    114     NA     NA     NA     NA     NA     NA     NA     NA     NA #>  [7,]    230    231    232     NA     NA     NA     NA     NA     NA     NA #>  [8,]    350    351    352    353    354     NA     NA     NA     NA     NA #>  [9,]    474    475    476    477    478    479    480     NA     NA     NA #> [10,]    602    603    604    605    606    607    608    609    610     NA #> [11,]    734    735    736    737    738    739    740    741    742    743 #> [12,]    870    871    872    873    874    875    876    877    878    879 #> [13,]   1010   1011   1012   1013   1014   1015   1016   1017   1018   1019 #> [14,]     NA   1064   1065   1066   1067   1068   1069   1070   1071   1072 #> [15,]     NA     NA     NA   1140   1141   1142   1143   1144   1145   1146 #> [16,]     NA     NA     NA     NA     NA   1212   1213   1214   1215   1216 #> [17,]     NA     NA     NA     NA     NA     NA     NA   1280   1281   1282 #> [18,]     NA     NA     NA     NA     NA     NA     NA   1346   1347   1348 #> [19,]     NA     NA     NA     NA     NA   1414   1415   1416   1417   1418 #> [20,]     NA     NA     NA   1486   1487   1488   1489   1490   1491   1492 #> [21,]     NA   1562   1563   1564   1565   1566   1567   1568   1569   1570 #> [22,]   1728   1729   1730   1731   1732   1733   1734   1735   1736   1737 #> [23,]   1868   1869   1870   1871   1872   1873   1874   1875   1876   1877 #> [24,]   2004   2005   2006   2007   2008   2009   2010   2011   2012   2013 #> [25,]   2136   2137   2138   2139   2140   2141   2142   2143   2144     NA #> [26,]   2264   2265   2266   2267   2268   2269   2270     NA     NA     NA #> [27,]   2388   2389   2390   2391   2392     NA     NA     NA     NA     NA #> [28,]   2508   2509   2510     NA     NA     NA     NA     NA     NA     NA #> [29,]   2624     NA     NA     NA     NA     NA     NA     NA     NA     NA #> [30,]     NA     NA     NA     NA     NA     NA     NA     NA     NA     NA #> [31,]     NA     NA     NA     NA     NA     NA     NA     NA     NA     NA #> [32,]     NA     NA     NA     NA     NA     NA     NA     NA     NA     NA #> [33,]     NA     NA     NA     NA     NA     NA     NA     NA     NA     NA #> [34,]     NA     NA     NA     NA     NA     NA     NA     NA     NA     NA #>       [,168] [,169] [,170] [,171] [,172] [,173] [,174] [,175] [,176] [,177] #>  [1,]     NA     NA     NA     NA     NA     NA     NA     NA     NA     NA #>  [2,]     NA     NA     NA     NA     NA     NA     NA     NA     NA     NA #>  [3,]     NA     NA     NA     NA     NA     NA     NA     NA     NA     NA #>  [4,]     NA     NA     NA     NA     NA     NA     NA     NA     NA     NA #>  [5,]     NA     NA     NA     NA     NA     NA     NA     NA     NA     NA #>  [6,]     NA     NA     NA     NA     NA     NA     NA     NA     NA     NA #>  [7,]     NA     NA     NA     NA     NA     NA     NA     NA     NA     NA #>  [8,]     NA     NA     NA     NA     NA     NA     NA     NA     NA     NA #>  [9,]     NA     NA     NA     NA     NA     NA     NA     NA     NA     NA #> [10,]     NA     NA     NA     NA     NA     NA     NA     NA     NA     NA #> [11,]    744     NA     NA     NA     NA     NA     NA     NA     NA     NA #> [12,]    880    881    882     NA     NA     NA     NA     NA     NA     NA #> [13,]   1020   1021   1022   1023   1024     NA     NA     NA     NA     NA #> [14,]   1073   1074   1075   1076   1077   1078   1079   1080   1081   1082 #> [15,]   1147   1148   1149   1150   1151   1152   1153   1154   1155   1156 #> [16,]   1217   1218   1219   1220   1221   1222   1223   1224   1225   1226 #> [17,]   1283   1284   1285   1286   1287   1288   1289   1290   1291   1292 #> [18,]   1349   1350   1351   1352   1353   1354   1355   1356   1357   1358 #> [19,]   1419   1420   1421   1422   1423   1424   1425   1426   1427   1428 #> [20,]   1493   1494   1495   1496   1497   1498   1499   1500   1501   1502 #> [21,]   1571   1572   1573   1574   1575   1576   1577   1578   1579   1580 #> [22,]   1738   1739   1740   1741   1742     NA     NA     NA     NA     NA #> [23,]   1878   1879   1880     NA     NA     NA     NA     NA     NA     NA #> [24,]   2014     NA     NA     NA     NA     NA     NA     NA     NA     NA #> [25,]     NA     NA     NA     NA     NA     NA     NA     NA     NA     NA #> [26,]     NA     NA     NA     NA     NA     NA     NA     NA     NA     NA #> [27,]     NA     NA     NA     NA     NA     NA     NA     NA     NA     NA #> [28,]     NA     NA     NA     NA     NA     NA     NA     NA     NA     NA #> [29,]     NA     NA     NA     NA     NA     NA     NA     NA     NA     NA #> [30,]     NA     NA     NA     NA     NA     NA     NA     NA     NA     NA #> [31,]     NA     NA     NA     NA     NA     NA     NA     NA     NA     NA #> [32,]     NA     NA     NA     NA     NA     NA     NA     NA     NA     NA #> [33,]     NA     NA     NA     NA     NA     NA     NA     NA     NA     NA #> [34,]     NA     NA     NA     NA     NA     NA     NA     NA     NA     NA #>       [,178] [,179] [,180] [,181] [,182] [,183] [,184] [,185] [,186] [,187] #>  [1,]     NA     NA     NA     NA     NA     NA     NA     NA     NA     NA #>  [2,]     NA     NA     NA     NA     NA     NA     NA     NA     NA     NA #>  [3,]     NA     NA     NA     NA     NA     NA     NA     NA     NA     NA #>  [4,]     NA     NA     NA     NA     NA     NA     NA     NA     NA     NA #>  [5,]     NA     NA     NA     NA     NA     NA     NA     NA     NA     NA #>  [6,]     NA     NA     NA     NA     NA     NA     NA     NA     NA     NA #>  [7,]     NA     NA     NA     NA     NA     NA     NA     NA     NA     NA #>  [8,]     NA     NA     NA     NA     NA     NA     NA     NA     NA     NA #>  [9,]     NA     NA     NA     NA     NA     NA     NA     NA     NA     NA #> [10,]     NA     NA     NA     NA     NA     NA     NA     NA     NA     NA #> [11,]     NA     NA     NA     NA     NA     NA     NA     NA     NA     NA #> [12,]     NA     NA     NA     NA     NA     NA     NA     NA     NA     NA #> [13,]     NA     NA     NA     NA     NA     NA     NA     NA     NA     NA #> [14,]   1083   1084   1085   1086   1087   1088   1089   1090   1091   1092 #> [15,]   1157   1158   1159   1160   1161   1162   1163   1164   1165   1166 #> [16,]   1227   1228   1229   1230   1231   1232   1233   1234   1235   1236 #> [17,]   1293   1294   1295   1296   1297   1298   1299   1300   1301   1302 #> [18,]   1359   1360   1361   1362   1363   1364   1365   1366   1367   1368 #> [19,]   1429   1430   1431   1432   1433   1434   1435   1436   1437   1438 #> [20,]   1503   1504   1505   1506   1507   1508   1509   1510   1511   1512 #> [21,]   1581   1582   1583   1584   1585   1586   1587   1588   1589   1590 #> [22,]     NA     NA     NA     NA     NA     NA     NA     NA     NA     NA #> [23,]     NA     NA     NA     NA     NA     NA     NA     NA     NA     NA #> [24,]     NA     NA     NA     NA     NA     NA     NA     NA     NA     NA #> [25,]     NA     NA     NA     NA     NA     NA     NA     NA     NA     NA #> [26,]     NA     NA     NA     NA     NA     NA     NA     NA     NA     NA #> [27,]     NA     NA     NA     NA     NA     NA     NA     NA     NA     NA #> [28,]     NA     NA     NA     NA     NA     NA     NA     NA     NA     NA #> [29,]     NA     NA     NA     NA     NA     NA     NA     NA     NA     NA #> [30,]     NA     NA     NA     NA     NA     NA     NA     NA     NA     NA #> [31,]     NA     NA     NA     NA     NA     NA     NA     NA     NA     NA #> [32,]     NA     NA     NA     NA     NA     NA     NA     NA     NA     NA #> [33,]     NA     NA     NA     NA     NA     NA     NA     NA     NA     NA #> [34,]     NA     NA     NA     NA     NA     NA     NA     NA     NA     NA #>       [,188] [,189] [,190] [,191] [,192] [,193] [,194] [,195] [,196] [,197] #>  [1,]     NA     NA     NA     NA     NA     NA     NA     NA     NA     NA #>  [2,]     NA     NA     NA     NA     NA     NA     NA     NA     NA     NA #>  [3,]     NA     NA     NA     NA     NA     NA     NA     NA     NA     NA #>  [4,]     NA     NA     NA     NA     NA     NA     NA     NA     NA     NA #>  [5,]     NA     NA     NA     NA     NA     NA     NA     NA     NA     NA #>  [6,]     NA     NA     NA     NA     NA     NA     NA     NA     NA     NA #>  [7,]     NA     NA     NA     NA     NA     NA     NA     NA     NA     NA #>  [8,]     NA     NA     NA     NA     NA     NA     NA     NA     NA     NA #>  [9,]     NA     NA     NA     NA     NA     NA     NA     NA     NA     NA #> [10,]     NA     NA     NA     NA     NA     NA     NA     NA     NA     NA #> [11,]     NA     NA     NA     NA     NA     NA     NA     NA     NA     NA #> [12,]     NA     NA     NA     NA     NA     NA     NA     NA     NA     NA #> [13,]     NA     NA     NA     NA     NA     NA     NA     NA     NA     NA #> [14,]   1093   1094   1095   1096   1097   1098   1099   1100   1101   1102 #> [15,]   1167   1168   1169   1170   1171   1172   1173   1174   1175   1176 #> [16,]   1237   1238   1239   1240   1241   1242   1243   1244   1245   1246 #> [17,]   1303   1304   1305   1306   1307   1308   1309   1310   1311   1312 #> [18,]   1369   1370   1371   1372   1373   1374   1375   1376   1377   1378 #> [19,]   1439   1440   1441   1442   1443   1444   1445   1446   1447   1448 #> [20,]   1513   1514   1515   1516   1517   1518   1519   1520   1521   1522 #> [21,]   1591   1592   1593   1594   1595   1596   1597   1598   1599   1600 #> [22,]     NA     NA     NA     NA     NA     NA     NA     NA     NA     NA #> [23,]     NA     NA     NA     NA     NA     NA     NA     NA     NA     NA #> [24,]     NA     NA     NA     NA     NA     NA     NA     NA     NA     NA #> [25,]     NA     NA     NA     NA     NA     NA     NA     NA     NA     NA #> [26,]     NA     NA     NA     NA     NA     NA     NA     NA     NA     NA #> [27,]     NA     NA     NA     NA     NA     NA     NA     NA     NA     NA #> [28,]     NA     NA     NA     NA     NA     NA     NA     NA     NA     NA #> [29,]     NA     NA     NA     NA     NA     NA     NA     NA     NA     NA #> [30,]     NA     NA     NA     NA     NA     NA     NA     NA     NA     NA #> [31,]     NA     NA     NA     NA     NA     NA     NA     NA     NA     NA #> [32,]     NA     NA     NA     NA     NA     NA     NA     NA     NA     NA #> [33,]     NA     NA     NA     NA     NA     NA     NA     NA     NA     NA #> [34,]     NA     NA     NA     NA     NA     NA     NA     NA     NA     NA #>       [,198] [,199] [,200] [,201] [,202] #>  [1,]     NA     NA     NA     NA     NA #>  [2,]     NA     NA     NA     NA     NA #>  [3,]     NA     NA     NA     NA     NA #>  [4,]     NA     NA     NA     NA     NA #>  [5,]     NA     NA     NA     NA     NA #>  [6,]     NA     NA     NA     NA     NA #>  [7,]     NA     NA     NA     NA     NA #>  [8,]     NA     NA     NA     NA     NA #>  [9,]     NA     NA     NA     NA     NA #> [10,]     NA     NA     NA     NA     NA #> [11,]     NA     NA     NA     NA     NA #> [12,]     NA     NA     NA     NA     NA #> [13,]     NA     NA     NA     NA     NA #> [14,]     NA     NA     NA     NA     NA #> [15,]     NA     NA     NA     NA     NA #> [16,]     NA     NA     NA     NA     NA #> [17,]     NA     NA     NA     NA     NA #> [18,]     NA     NA     NA     NA     NA #> [19,]     NA     NA     NA     NA     NA #> [20,]     NA     NA     NA     NA     NA #> [21,]     NA     NA     NA     NA     NA #> [22,]     NA     NA     NA     NA     NA #> [23,]     NA     NA     NA     NA     NA #> [24,]     NA     NA     NA     NA     NA #> [25,]     NA     NA     NA     NA     NA #> [26,]     NA     NA     NA     NA     NA #> [27,]     NA     NA     NA     NA     NA #> [28,]     NA     NA     NA     NA     NA #> [29,]     NA     NA     NA     NA     NA #> [30,]     NA     NA     NA     NA     NA #> [31,]     NA     NA     NA     NA     NA #> [32,]     NA     NA     NA     NA     NA #> [33,]     NA     NA     NA     NA     NA #> [34,]     NA     NA     NA     NA     NA  # We can use a variety of spatial inputs to get cell numbers using locate() # The simplest is a two-column data.frame coords <- data.frame(x = c(50, 79, 22),                      y = c(25, 11, 19)) print(coords) #>    x  y #> 1 50 25 #> 2 79 11 #> 3 22 19 locate(samc_obj, coords) #> [1]  494 1925 1193  # You will get an error if you input a coordinate that does not correspond # to a non-NA cell coords <- data.frame(x = c(1),                      y = c(1)) print(coords) #>   x y #> 1 1 1 try(locate(samc_obj, coords)) #> Error : One or more coordinates do not correspond to non-NA cells."},{"path":"/reference/location-class.html","id":null,"dir":"Reference","previous_headings":"","what":"location class — location-class","title":"location class — location-class","text":"Union class location inputs","code":""},{"path":"/reference/location-class.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"location class — location-class","text":"location class union class \"numeric\" \"character\" classes. Users generally need worry except know method parameter \"location\" type can either integer character name provided input.","code":""},{"path":"/reference/map.html","id":null,"dir":"Reference","previous_headings":"","what":"Map vector data — map","title":"Map vector data — map","text":"Map vector data RasterLayer","code":""},{"path":"/reference/map.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Map vector data — map","text":"","code":"map(samc, vec)  # S4 method for class 'samc,numeric' map(samc, vec)  # S4 method for class 'samc,list' map(samc, vec)"},{"path":"/reference/map.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Map vector data — map","text":"samc Spatial absorbing Markov chain object. output samc() function. vec Vector data fill map.","code":""},{"path":"/reference/map.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Map vector data — map","text":"matrix, RasterLayer, SpatRaster object. returned type match type used create samc object.","code":""},{"path":"/reference/map.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Map vector data — map","text":"convenience function ensure vector data properly mapped back original landscape data. reason needed package supports matrices, RasterLayers, SpatRasters, can differ order data read written (R matrices column-major order, whereas raster package uses row-major order). Internally, package uses single order, regardless original data. can cause issues mapping vector results care taken, function provided simplify process. also correctly maps results landscape data NA cells, another potential source error careful. requirement vec input number elements matches number non-NA cells landscape data used create samc object.","code":""},{"path":"/reference/map.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Map vector data — map","text":"","code":"# \"Load\" the data. In this case we are using data built into the package. # In practice, users will likely load raster data using the raster() function # from the raster package. res_data <- samc::example_split_corridor$res abs_data <- samc::example_split_corridor$abs init_data <- samc::example_split_corridor$init   # Make sure our data meets the basic input requirements of the package using # the check() function. check(res_data, abs_data) #> [1] TRUE check(res_data, init_data) #> [1] TRUE  # Setup the details for a random-walk model rw_model <- list(fun = function(x) 1/mean(x), # Function for calculating transition probabilities                  dir = 8, # Directions of the transitions. Either 4 or 8.                  sym = TRUE) # Is the function symmetric?   # Create a `samc-class` object with the resistance and absorption data using # the samc() function. We use the recipricol of the arithmetic mean for # calculating the transition matrix. Note, the input data here are matrices, # not RasterLayers. samc_obj <- samc(res_data, abs_data, model = rw_model)   # Convert the initial state data to probabilities init_prob_data <- init_data / sum(init_data, na.rm = TRUE)   # Calculate short- and long-term metrics using the analytical functions short_mort <- mortality(samc_obj, init_prob_data, time = 50) short_dist <- distribution(samc_obj, origin = 3, time = 50) long_disp <- dispersal(samc_obj, init_prob_data) #>  #> Cached diagonal not found. #> Performing setup. This can take several minutes... Complete. #> Calculating matrix inverse diagonal... #>  Computing: 48%  (~10s remaining)        Computing: 97%  (~0s remaining)        Computing: 100% (done)                          #>  Complete                                                       #> Diagonal has been cached. Continuing with metric calculation... visit <- visitation(samc_obj, dest = 4) surv <- survival(samc_obj)   # Use the map() function to turn vector results into RasterLayer objects. short_mort_map <- map(samc_obj, short_mort) short_dist_map <- map(samc_obj, short_dist) long_disp_map <- map(samc_obj, long_disp) visit_map <- map(samc_obj, visit) surv_map <- map(samc_obj, surv)"},{"path":"/reference/mat_null-class.html","id":null,"dir":"Reference","previous_headings":"","what":"samc mat_null class — mat_null-class","title":"samc mat_null class — mat_null-class","text":"Class grouping matrix NULL data types","code":""},{"path":"/reference/mortality.html","id":null,"dir":"Reference","previous_headings":"","what":"Calculate mortality metrics — mortality","title":"Calculate mortality metrics — mortality","text":"Calculates probability absorption individual transient states.","code":""},{"path":"/reference/mortality.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Calculate mortality metrics — mortality","text":"","code":"mortality(samc, init, origin, dest, time)  # S4 method for class 'samc,missing,missing,missing,numeric' mortality(samc, time)  # S4 method for class 'samc,missing,location,missing,numeric' mortality(samc, origin, time)  # S4 method for class 'samc,missing,missing,location,numeric' mortality(samc, dest, time)  # S4 method for class 'samc,missing,location,location,numeric' mortality(samc, origin, dest, time)  # S4 method for class 'samc,ANY,missing,missing,numeric' mortality(samc, init, time)  # S4 method for class 'samc,ANY,missing,location,numeric' mortality(samc, init, dest, time)  # S4 method for class 'samc,missing,missing,missing,missing' mortality(samc)  # S4 method for class 'samc,missing,location,missing,missing' mortality(samc, origin)  # S4 method for class 'samc,missing,missing,location,missing' mortality(samc, dest)  # S4 method for class 'samc,missing,location,location,missing' mortality(samc, origin, dest)  # S4 method for class 'samc,ANY,missing,missing,missing' mortality(samc, init)  # S4 method for class 'samc,ANY,missing,location,missing' mortality(samc, init, dest)"},{"path":"/reference/mortality.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Calculate mortality metrics — mortality","text":"samc samc-class object created using samc function. init Sets initial state \\(\\psi\\) transients states. Input must able pass check function compared samc-class object. Can contain positive finite values. origin positive integer character name representing transient state \\(\\mathit{}\\). Corresponds row \\(\\mathit{}\\) matrix \\(\\mathbf{P}\\) samc-class object. paired dest parameter, multiple values may provided vector. dest positive integer character name representing transient state \\(\\mathit{j}\\). Corresponds column \\(\\mathit{j}\\) matrix \\(\\mathbf{P}\\) samc-class object. paired origin parameter, multiple values may provided vector. time positive integer vector positive integers representing \\(\\mathit{t}\\) time steps. Vectors must ordered contain duplicates. Vectors may used metrics return dense matrices. maximum time step value capped 10,000 due numerical precision issues.","code":""},{"path":"/reference/mortality.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Calculate mortality metrics — mortality","text":"See Details","code":""},{"path":"/reference/mortality.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Calculate mortality metrics — mortality","text":"\\(\\tilde{B}_t = \\tilde{F} \\tilde{R}\\) mortality(samc, time) result matrix \\(M\\) \\(M_{,j}\\) probability absorption transient state \\(\\mathit{j}\\) within \\(\\mathit{t}\\) fewer steps starting transient state \\(\\mathit{}\\). returned matrix always dense optimized. Must enable override use (see samc-class). mortality(samc, origin, time) result vector \\(\\mathbf{v}\\) \\(\\mathbf{v}_j\\) probability absorption transient state \\(\\mathit{j}\\) within \\(\\mathit{t}\\) fewer steps starting transient state \\(\\mathit{}\\). multiple time steps provided vector, result ordered named list containing vector time step. samc-class object created using matrix RasterLayer maps, vector \\(\\mathbf{v}\\) can mapped RasterLayer using map function. mortality(samc, dest, time) result vector \\(\\mathbf{v}\\) \\(\\mathbf{v}_i\\) probability absorption transient state \\(\\mathit{j}\\) within \\(\\mathit{t}\\) fewer steps starting transient state \\(\\mathit{}\\). multiple time steps provided vector, result ordered named list containing vector time step. samc-class object created using matrix RasterLayer maps, vector \\(\\mathbf{v}\\) can mapped RasterLayer using map function. mortality(samc, origin, dest, time) result numeric value probability absorption transient state \\(\\mathit{j}\\) within \\(\\mathit{t}\\) fewer time steps starting transient state \\(\\mathit{}\\). multiple time steps provided vector, result ordered named list containing numeric value time step. \\(\\psi^T \\tilde{B}_t\\) mortality(samc, init, time) result vector \\(\\mathbf{v}\\) \\(\\mathbf{v}_j\\) unconditional probability absorption transient state \\(\\mathit{j}\\) within \\(\\mathit{t}\\) fewer steps given initial state \\(\\psi\\). multiple time steps provided vector, result ordered named list containing vector time step. samc-class object created using matrix RasterLayer maps, vector \\(\\mathbf{v}\\) can mapped RasterLayer using map function. \\(B = F \\tilde{R}\\) mortality(samc) result matrix \\(M\\) \\(M_{,j}\\) probability absorption transient state \\(\\mathit{j}\\) starting transient state \\(\\mathit{}\\). returned matrix always dense optimized. Must enable override use (see samc-class). mortality(samc, origin) result vector \\(\\mathbf{v}\\) \\(\\mathbf{v}_j\\) probability absorption transient state \\(\\mathit{j}\\) starting transient state \\(\\mathit{}\\). samc-class object created using matrix RasterLayer maps, vector \\(\\mathbf{v}\\) can mapped RasterLayer using map function. mortality(samc, dest) result vector \\(\\mathbf{v}\\) \\(\\mathbf{v}_i\\) probability absorption transient state \\(\\mathit{j}\\) starting transient state \\(\\mathit{}\\). samc-class object created using matrix RasterLayer maps, vector \\(\\mathbf{v}\\) can mapped RasterLayer using map function. mortality(samc, origin, dest) result numeric value probability absorption transient state \\(\\mathit{j}\\) starting transient state \\(\\mathit{}\\). \\(\\psi^T B\\) mortality(samc, init) result vector \\(\\mathbf{v}\\) \\(\\mathbf{v}_j\\) unconditional probability absorption transient state \\(\\mathit{j}\\) given initial state \\(\\psi\\). samc-class object created using matrix RasterLayer maps, vector \\(\\mathbf{v}\\) can mapped RasterLayer using map function.","code":""},{"path":"/reference/mortality.html","id":"performance","dir":"Reference","previous_headings":"","what":"Performance","title":"Calculate mortality metrics — mortality","text":"relevant performance information function can found performance vignette: vignette(\"performance\", package = \"samc\")","code":""},{"path":"/reference/mortality.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Calculate mortality metrics — mortality","text":"","code":"# \"Load\" the data. In this case we are using data built into the package. # In practice, users will likely load raster data using the raster() function # from the raster package. res_data <- samc::example_split_corridor$res abs_data <- samc::example_split_corridor$abs init_data <- samc::example_split_corridor$init   # Make sure our data meets the basic input requirements of the package using # the check() function. check(res_data, abs_data) #> [1] TRUE check(res_data, init_data) #> [1] TRUE  # Setup the details for a random-walk model rw_model <- list(fun = function(x) 1/mean(x), # Function for calculating transition probabilities                  dir = 8, # Directions of the transitions. Either 4 or 8.                  sym = TRUE) # Is the function symmetric?   # Create a `samc-class` object with the resistance and absorption data using # the samc() function. We use the recipricol of the arithmetic mean for # calculating the transition matrix. Note, the input data here are matrices, # not RasterLayers. samc_obj <- samc(res_data, abs_data, model = rw_model)   # Convert the initial state data to probabilities init_prob_data <- init_data / sum(init_data, na.rm = TRUE)   # Calculate short- and long-term metrics using the analytical functions short_mort <- mortality(samc_obj, init_prob_data, time = 50) short_dist <- distribution(samc_obj, origin = 3, time = 50) long_disp <- dispersal(samc_obj, init_prob_data) #>  #> Cached diagonal not found. #> Performing setup. This can take several minutes... Complete. #> Calculating matrix inverse diagonal... #>  Computing: 49%  (~10s remaining)        Computing: 99%  (~0s remaining)        Computing: 100% (done)                          #>  Complete                                                       #> Diagonal has been cached. Continuing with metric calculation... visit <- visitation(samc_obj, dest = 4) surv <- survival(samc_obj)   # Use the map() function to turn vector results into RasterLayer objects. short_mort_map <- map(samc_obj, short_mort) short_dist_map <- map(samc_obj, short_dist) long_disp_map <- map(samc_obj, long_disp) visit_map <- map(samc_obj, visit) surv_map <- map(samc_obj, surv)"},{"path":"/reference/pairwise.html","id":null,"dir":"Reference","previous_headings":"","what":"Pairwise analyses — pairwise","title":"Pairwise analyses — pairwise","text":"Analysis pairwise combinations locations","code":""},{"path":"/reference/pairwise.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Pairwise analyses — pairwise","text":"","code":"pairwise(fun, samc, origin, dest)  # S4 method for class 'function,samc,location,location' pairwise(fun, samc, origin, dest)  # S4 method for class 'function,samc,location,missing' pairwise(fun, samc, origin)"},{"path":"/reference/pairwise.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Pairwise analyses — pairwise","text":"fun samc analytical function signature fun(samc, origin, dest) samc samc-class object origin vector locations dest vector locations. Can excluded reuse origin parameter","code":""},{"path":"/reference/pairwise.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Pairwise analyses — pairwise","text":"'long' format data.frame","code":""},{"path":"/reference/pairwise.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Pairwise analyses — pairwise","text":"providing vector inputs `origin` `dest` parameters analytical functions, package assumes users providing pairs `origin` `dest`. , `origin[1]` paired `dest[1]`, `origin[2]` paired `dest[2]`, etc. Another way think two vector inputs can treated columns dataframe. result analytical function vector length input. behavior works situation, default package. However, users may wish run analytical function pairwise combinations values input vectors. , `origin[1]` paired `dest[1]`,`dest[2]`, `dest[3]`, etc, moving next elements `origin`. approach advantage potentially reducing amount code needed analysis, results can represented pairwise matrix, suitable situations. enable second approach easily, `pairwise()` function runs combinations `origin` `dest` parameters analytical function returns results 'long' format data.frame. data.frame can reshaped pairwise matrix 'wide' format data.frame using tools like reshape2 tidyr packages. function intended used inputs `init` `time`","code":""},{"path":"/reference/pairwise.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Pairwise analyses — pairwise","text":"","code":"library(samc)  # Load example data res_data <- samc::example_split_corridor$res abs_data <- samc::example_split_corridor$abs   # Create samc-class object samc_obj <- samc(res_data, abs_data,                  model = list(fun = function(x) 1/mean(x), dir = 8, sym = TRUE))  # pairwise() example pw <- pairwise(cond_passage, samc_obj, origin = 1:4, dest = 5) print(pw) #>   origin dest   result #> 1      1    5 5402.175 #> 2      2    5 4642.001 #> 3      3    5 3600.117 #> 4      4    5 2249.220  # pairwise() example without dest pw <- pairwise(dispersal, samc_obj, origin = c(2, 7)) print(pw) #>   origin dest    result #> 1      2    2 0.7908536 #> 2      7    2 0.6243287 #> 3      2    7 0.6052441 #> 4      7    7 0.7972468"},{"path":"/reference/rasterize.html","id":null,"dir":"Reference","previous_headings":"","what":"Rasterize input — rasterize","title":"Rasterize input — rasterize","text":"Convert input SpatRaster object","code":""},{"path":"/reference/rasterize.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Rasterize input — rasterize","text":"","code":"rasterize(x)  # S4 method for class 'matrix' rasterize(x)  # S4 method for class 'RasterLayer' rasterize(x)  # S4 method for class 'SpatRaster' rasterize(x)"},{"path":"/reference/rasterize.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Rasterize input — rasterize","text":"x matrix, RasterLayer, SpatRaster","code":""},{"path":"/reference/rasterize.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Rasterize input — rasterize","text":"SpatRaster object","code":""},{"path":"/reference/rasterize.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Rasterize input — rasterize","text":"function primarily used convert input matrix raster SpatRaster object. main thing useful setting standard extent CRS converting matrices. used internally package ensure consistent results different data types maps. converting matrices, extents set match number rows columns matrix. Pixels result centered whole number coordinates (1,1) corresponding bottom left pixel. CRS set \"local\", treats Euclidean (Cartesian) plane units meters. main benefit users want easy way plot matrix data. input type samc function matrices, output map also matrices. Plotting matrices can require work simply using SpatRaster objects samc getting SpatRaster results back map. raster terra packages also rasterize function serves different purpose. either packages used directly, order package loading becomes important determine version rasterize used default.","code":""},{"path":"/reference/rasterize.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Rasterize input — rasterize","text":"","code":"# \"Load\" the data. In this case we are using data built into the package. # In practice, users will likely load raster data using the raster() function # from the raster package. res_data <- samc::example_split_corridor$res abs_data <- samc::example_split_corridor$abs init_data <- samc::example_split_corridor$init   # Make sure our data meets the basic input requirements of the package using # the check() function. check(res_data, abs_data) #> [1] TRUE check(res_data, init_data) #> [1] TRUE  # Setup the details for a random-walk model rw_model <- list(fun = function(x) 1/mean(x), # Function for calculating transition probabilities                  dir = 8, # Directions of the transitions. Either 4 or 8.                  sym = TRUE) # Is the function symmetric?   # Create a `samc-class` object with the resistance and absorption data using # the samc() function. We use the recipricol of the arithmetic mean for # calculating the transition matrix. Note, the input data here are matrices, # not RasterLayers. samc_obj <- samc(res_data, abs_data, model = rw_model)   # Convert the initial state data to probabilities init_prob_data <- init_data / sum(init_data, na.rm = TRUE)   # Calculate short- and long-term metrics using the analytical functions short_mort <- mortality(samc_obj, init_prob_data, time = 50) short_dist <- distribution(samc_obj, origin = 3, time = 50) long_disp <- dispersal(samc_obj, init_prob_data) #>  #> Cached diagonal not found. #> Performing setup. This can take several minutes... Complete. #> Calculating matrix inverse diagonal... #>  Computing: 48%  (~10s remaining)        Computing: 96%  (~0s remaining)        Computing: 100% (done)                          #>  Complete                                                       #> Diagonal has been cached. Continuing with metric calculation... visit <- visitation(samc_obj, dest = 4) surv <- survival(samc_obj)   # Use the map() function to turn vector results into RasterLayer objects. short_mort_map <- map(samc_obj, short_mort) short_dist_map <- map(samc_obj, short_dist) long_disp_map <- map(samc_obj, long_disp) visit_map <- map(samc_obj, visit) surv_map <- map(samc_obj, surv)"},{"path":"/reference/samc-class-access.html","id":null,"dir":"Reference","previous_headings":"","what":"Access samc-class components — samc-class-access","title":"Access samc-class components — samc-class-access","text":"Allows users access subset samc-class components","code":""},{"path":"/reference/samc-class-access.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Access samc-class components — samc-class-access","text":"","code":"# S4 method for class 'samc' x$name"},{"path":"/reference/samc-class-access.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Access samc-class components — samc-class-access","text":"x samc-class object name Component samc-class access","code":""},{"path":"/reference/samc-class-access.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Access samc-class components — samc-class-access","text":"Component value","code":""},{"path":"/reference/samc-class-modify.html","id":null,"dir":"Reference","previous_headings":"","what":"Modify samc-class components — samc-class-modify","title":"Modify samc-class components — samc-class-modify","text":"Allows users modify subset samc-class components","code":""},{"path":"/reference/samc-class-modify.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Modify samc-class components — samc-class-modify","text":"","code":"# S4 method for class 'samc' x$name <- value"},{"path":"/reference/samc-class-modify.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Modify samc-class components — samc-class-modify","text":"x samc-class object name Component samc-class modify value Value assign samc-class component","code":""},{"path":"/reference/samc-class-modify.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Modify samc-class components — samc-class-modify","text":"Updated samc-class object","code":""},{"path":"/reference/samc-class.html","id":null,"dir":"Reference","previous_headings":"","what":"samc class — samc-class","title":"samc class — samc-class","text":"S4 class manage SAMC data.","code":""},{"path":"/reference/samc-class.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"samc class — samc-class","text":"samc class used help ensure package used correctly minimize possibility users accidentally produce nonsensical results may obviously incorrect. class contains p matrix necessary calculations package, enforces type users less likely inadvertently alter way cause issues calculations. samc() function used create samc-class objects. samc-class slots subject change, users using @ operator access change . leads risk broken code future. Instead, relevant, $ operator can used get set components class safely. current list can accessed modified class: override analyses memory intensive potential make user's   system non-responsive crash. default, samc-class object used   analyses prevent unintentional loss work. cases, users   may wish use particular analyses, case behavior can   overridden. get current state override, use samc_obj$override.   enable use analyses, override can set TRUE using   samc_obj$override <- TRUE. enabling override, users   familiarize Performance vignette. q_matrix Advanced users may wish direct access Q matrix developing   custom calculations/analyses. Assumptions made internal   storage management P Q matrices samc-class; things   subject change future. safely access Q matrix, use   samc_obj$q_matrix. Q matrix inside samc-class   modified. p_matrix samc_obj$p_matrix can used get copy P matrix. abs_states Used attach additional absorbing states samc object.   cause P/Q matrices updated. Instead, intended provide decomposed   results mortality() absorption() metrics different sources   absorption might contributing total absorption values   used create samc object. input must form absorption inputs used samc().   Matrices passed list, rasters passed RasterStack.   Using NA input reset . solver samc_obj$solver can used change default linear algebra solver   used metrics. default value \"direct\" means direct solver   used, used previous versions package. alternative   value \"iter\" switches package iterative solver, significantly   memory efficient larger datasets, general noticeably slower   depending patterns data. threads samc_obj$threads can used get set number threads used   parallel computations. Details can found Parallel Computing   vignette.","code":""},{"path":"/reference/samc-class.html","id":"slots","dir":"Reference","previous_headings":"","what":"Slots","title":"samc class — samc-class","text":"data Data associated different components P matrix conv_cache Convolution cache model List containing model info used build samc object source Information data source P matrix nodes number nodes graph map Used verify landscape inputs mapping vector data crw_map Matrix used map location direction edges description prob_mat Matric CRW probabilities names Names transient states clumps Number discontinuous regions data override Used prevent accidental use memory intensive functions solver Controls linear solver used relevant metrics threads Used multi-threading precision \"single\" \"double\". applies convolution currently. .cache Cached data performance boosts","code":""},{"path":"/reference/samc.html","id":null,"dir":"Reference","previous_headings":"","what":"Create an samc object — samc","title":"Create an samc object — samc","text":"Create samc object contains absorbing Markov chain data","code":""},{"path":"/reference/samc.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Create an samc object — samc","text":"","code":"samc(data, absorption, fidelity, model, options = NULL)  # S4 method for class 'SpatRaster,SpatRaster,SpatRaster,list' samc(data, absorption, fidelity, model, options = NULL)  # S4 method for class 'RasterLayer,RasterLayer,RasterLayer,list' samc(data, absorption, fidelity, model, options = NULL)  # S4 method for class 'SpatRaster,SpatRaster,missing,list' samc(data, absorption, model, options = NULL)  # S4 method for class 'RasterLayer,RasterLayer,missing,list' samc(data, absorption, model, options = NULL)  # S4 method for class 'matrix,matrix,matrix,list' samc(data, absorption, fidelity, model, options = NULL)  # S4 method for class 'matrix,matrix,missing,list' samc(data, absorption, model, options = NULL)  # S4 method for class 'dgCMatrix,missing,missing,missing' samc(data, options = NULL)  # S4 method for class 'matrix,missing,missing,missing' samc(data, options = NULL)"},{"path":"/reference/samc.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Create an samc object — samc","text":"data SpatRaster-class RasterLayer-class matrix Matrix package dgCMatrix sparse matrix. absorption SpatRaster-class RasterLayer-class matrix fidelity SpatRaster-class RasterLayer-class matrix model list args constructing transition matrix. options list options changes samc behaves computationally.","code":""},{"path":"/reference/samc.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Create an samc object — samc","text":"samc-class object","code":""},{"path":"/reference/samc.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Create an samc object — samc","text":"function used create samc-class object. multiple options creating object. Option 1: Raster Matrix Maps samc(data = matrix, absorption = matrix, fidelity = matrix, model = list()) samc(data = SpatRaster, absorption = SpatRaster, fidelity = SpatRaster, model = list()) samc(data = RasterLayer, absorption = RasterLayer, fidelity = RasterLayer, model = list()) samc-class object can created combination resistance (conductance), absorption, fidelity data. different landscape data inputs must type (matrix, SpatRaster, RasterLayer), identical properties, including dimensions, location NA cells, CRS (using raster inputs). data absorption inputs always mandatory approach. fidelity input optional. fidelity input provided, assumed site fidelity (.e., individuals always move adjacent cell time step). model parameter mandatory list following template: list(fun = `function`, dir = `numeric`, sym = `logical`). used calculating values transition matrix. fun must mathematical function taking single vector x input. x[1] contains value node x[2] contains value node j data input samc(). dir determines neighboring nodes used andmust either 4 8. symmetric optimization reduce redundant work fun communative. must either TRUE FALSE. Special cases fun exist significantly speed creation samc model. selected using specific strings value fun. Currently, \"1/mean(x)\" \"x[2]\" implemented. special cases can implemented request. using raster inputs, SpatRaster objects (terra package) recommended RasterLayer objects (raster package). Internally, samc using SpatRaster objects, means RasterLayer objects converted SpatRaster objects, source memory inefficiency. Option 2: P Matrix samc(data = matrix) samc(data = dgCMatrix) data parameter can used alone create samc-class object directly preconstructed P matrix. matrix must either base R matrix, sparse matrix (dgCMatrix format) Matrix package. must meet following requirements: number rows must equal number columns (square matrix) Total absorption must single column right-hand side matrix bottom matrix, must row filled 0's except   last element (bottom-right matrix diagonal), must set 1 Every disconnected region matrix must least one non-zero   absorbing value row must sum 1 values must range 0-1 Additionally, columns rows P matrix may named (e.g., using dimnames(), rowname(), colnames(), etc). specifying origin dest inputs metrics, names may used instead cell numbers. advantage making code analysis easier read interpret, may also help eliminate unintentional mistakes. two requirements naming rows/cols P matrix. First, since P matrix represents pairwise matrix, row column names must . Second, must duplicate names. exception rules last column last row P matrix. Since part pairwise transition matrix, may whatever names user prefers. Additional Options Additional options can passed samc(..., options) list. several possible options: list(method = `character`, threads = `numeric`, override = `logical`, precision = `character`). use options varies depending inputs. options can changed model creation (see samc-class documentation). can omitted default behaviors. method controls type mathematical algorithm used model. can either \"direct\" (default), \"iter\", \"conv\". See Computation Methods vignette details. threads positive integer (default 1) enables parallelization certain limited cases. See Parallel Computing vignette details. override logical value (default: FALSE) enables certain memory intensive calculations. applies \"direct\" \"iter\" methods. See samc-class reference details. precision controls numerical precision calculations. can either \"double\" (~15 digits precision; default) \"double\" (~7 digits precision). Choosing lower precision level can lead significant speed improvements, reduces memory requirements approximately half. currently applies \"conv\" method. Additional Information Depending data used construct samc-class object, metrics may cause crashes. result underlying P matrix specific properties make equations unsolvable. One known case P matrix represents disconnected graph, can lead cond_passage() function crashing. terms raster/matrix inputs, disconnected graph occurs one pixels/cells unreachable pixels/cells due presence full barrier made NA values. raster, may obvious islands can inconspicuous rogue isolated pixel. may currently unknown situations lead unsolvable metrics. Future work planned towards identifying issues creation samc-class object handling appropriately prevent inadvertent crashes. Version 3 Changes Support creating samc-class objects TransitionLayer objects removed package dependent gdistance. Version 2 Changes Version 1.5.0 officially removed support deprecated resistance, tr_fun, directions, p_mat, latlon, override arguments. Old code updated new samc() function structure order work.","code":""},{"path":"/reference/samc.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Create an samc object — samc","text":"","code":"# \"Load\" the data. In this case we are using data built into the package. # In practice, users will likely load raster data using the raster() function # from the raster package. res_data <- samc::example_split_corridor$res abs_data <- samc::example_split_corridor$abs init_data <- samc::example_split_corridor$init   # Make sure our data meets the basic input requirements of the package using # the check() function. check(res_data, abs_data) #> [1] TRUE check(res_data, init_data) #> [1] TRUE  # Setup the details for a random-walk model rw_model <- list(fun = function(x) 1/mean(x), # Function for calculating transition probabilities                  dir = 8, # Directions of the transitions. Either 4 or 8.                  sym = TRUE) # Is the function symmetric?   # Create a `samc-class` object with the resistance and absorption data using # the samc() function. We use the recipricol of the arithmetic mean for # calculating the transition matrix. Note, the input data here are matrices, # not RasterLayers. samc_obj <- samc(res_data, abs_data, model = rw_model)   # Convert the initial state data to probabilities init_prob_data <- init_data / sum(init_data, na.rm = TRUE)   # Calculate short- and long-term metrics using the analytical functions short_mort <- mortality(samc_obj, init_prob_data, time = 50) short_dist <- distribution(samc_obj, origin = 3, time = 50) long_disp <- dispersal(samc_obj, init_prob_data) #>  #> Cached diagonal not found. #> Performing setup. This can take several minutes... Complete. #> Calculating matrix inverse diagonal... #>  Computing: 50%  (~10s remaining)        Computing: 98%  (~0s remaining)        Computing: 100% (done)                          #>  Complete                                                       #> Diagonal has been cached. Continuing with metric calculation... visit <- visitation(samc_obj, dest = 4) surv <- survival(samc_obj)   # Use the map() function to turn vector results into RasterLayer objects. short_mort_map <- map(samc_obj, short_mort) short_dist_map <- map(samc_obj, short_dist) long_disp_map <- map(samc_obj, long_disp) visit_map <- map(samc_obj, visit) surv_map <- map(samc_obj, surv)"},{"path":"/reference/samc_data-class.html","id":null,"dir":"Reference","previous_headings":"","what":"data class — samc_data-class","title":"data class — samc_data-class","text":"Contains data fields used samc-class","code":""},{"path":"/reference/samc_data-class.html","id":"slots","dir":"Reference","previous_headings":"","what":"Slots","title":"data class — samc_data-class","text":"f F matrix t_abs Total absorption c_abs Component absorption states","code":""},{"path":"/reference/survival.html","id":null,"dir":"Reference","previous_headings":"","what":"Calculate survival metrics — survival","title":"Calculate survival metrics — survival","text":"Calculates expected time absorption","code":""},{"path":"/reference/survival.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Calculate survival metrics — survival","text":"","code":"survival(samc, init, origin)  # S4 method for class 'samc,missing,missing' survival(samc)  # S4 method for class 'samc,missing,location' survival(samc, origin)  # S4 method for class 'samc,ANY,missing' survival(samc, init)"},{"path":"/reference/survival.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Calculate survival metrics — survival","text":"samc samc-class object created using samc function. init Sets initial state \\(\\psi\\) transients states. Input must able pass check function compared samc-class object. Can contain positive finite values. origin positive integer character name representing transient state \\(\\mathit{}\\). Corresponds row \\(\\mathit{}\\) matrix \\(\\mathbf{P}\\) samc-class object. paired dest parameter, multiple values may provided vector.","code":""},{"path":"/reference/survival.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Calculate survival metrics — survival","text":"See Details","code":""},{"path":"/reference/survival.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Calculate survival metrics — survival","text":"\\(z=(-Q)^{-1}{\\cdot}1=F{\\cdot}1\\) survival(samc) result vector \\(\\mathbf{v}\\) \\(\\mathbf{v}_i\\) expected time absorption starting transient state \\(\\mathit{}\\). samc-class object created using matrix RasterLayer maps, vector \\(\\mathbf{v}\\) can mapped RasterLayer using map function. \\(\\psi^Tz\\) survival(samc, init) result numeric expected time absorption given initial state \\(\\psi\\).","code":""},{"path":"/reference/survival.html","id":"performance","dir":"Reference","previous_headings":"","what":"Performance","title":"Calculate survival metrics — survival","text":"relevant performance information function can found performance vignette: vignette(\"performance\", package = \"samc\")","code":""},{"path":"/reference/survival.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Calculate survival metrics — survival","text":"","code":"# \"Load\" the data. In this case we are using data built into the package. # In practice, users will likely load raster data using the raster() function # from the raster package. res_data <- samc::example_split_corridor$res abs_data <- samc::example_split_corridor$abs init_data <- samc::example_split_corridor$init   # Make sure our data meets the basic input requirements of the package using # the check() function. check(res_data, abs_data) #> [1] TRUE check(res_data, init_data) #> [1] TRUE  # Setup the details for a random-walk model rw_model <- list(fun = function(x) 1/mean(x), # Function for calculating transition probabilities                  dir = 8, # Directions of the transitions. Either 4 or 8.                  sym = TRUE) # Is the function symmetric?   # Create a `samc-class` object with the resistance and absorption data using # the samc() function. We use the recipricol of the arithmetic mean for # calculating the transition matrix. Note, the input data here are matrices, # not RasterLayers. samc_obj <- samc(res_data, abs_data, model = rw_model)   # Convert the initial state data to probabilities init_prob_data <- init_data / sum(init_data, na.rm = TRUE)   # Calculate short- and long-term metrics using the analytical functions short_mort <- mortality(samc_obj, init_prob_data, time = 50) short_dist <- distribution(samc_obj, origin = 3, time = 50) long_disp <- dispersal(samc_obj, init_prob_data) #>  #> Cached diagonal not found. #> Performing setup. This can take several minutes... Complete. #> Calculating matrix inverse diagonal... #>  Computing: 49%  (~10s remaining)        Computing: 96%  (~0s remaining)        Computing: 100% (done)                          #>  Complete                                                       #> Diagonal has been cached. Continuing with metric calculation... visit <- visitation(samc_obj, dest = 4) surv <- survival(samc_obj)   # Use the map() function to turn vector results into RasterLayer objects. short_mort_map <- map(samc_obj, short_mort) short_dist_map <- map(samc_obj, short_dist) long_disp_map <- map(samc_obj, long_disp) visit_map <- map(samc_obj, visit) surv_map <- map(samc_obj, surv)"},{"path":"/reference/visitation.html","id":null,"dir":"Reference","previous_headings":"","what":"Calculate visitation metrics — visitation","title":"Calculate visitation metrics — visitation","text":"Calculates number times transient states visited absorption.","code":""},{"path":"/reference/visitation.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Calculate visitation metrics — visitation","text":"","code":"visitation(samc, init, origin, dest, time)  # S4 method for class 'samc,missing,missing,missing,numeric' visitation(samc, time)  # S4 method for class 'samc,missing,location,missing,numeric' visitation(samc, origin, time)  # S4 method for class 'samc,missing,missing,location,numeric' visitation(samc, dest, time)  # S4 method for class 'samc,missing,location,location,numeric' visitation(samc, origin, dest, time)  # S4 method for class 'samc,ANY,missing,missing,numeric' visitation(samc, init, time)  # S4 method for class 'samc,missing,missing,missing,missing' visitation(samc)  # S4 method for class 'samc,missing,location,missing,missing' visitation(samc, origin)  # S4 method for class 'samc,missing,missing,location,missing' visitation(samc, dest)  # S4 method for class 'samc,missing,location,location,missing' visitation(samc, origin, dest)  # S4 method for class 'samc,ANY,missing,missing,missing' visitation(samc, init)  # S4 method for class 'samc,ANY,missing,location,missing' visitation(samc, init, dest)"},{"path":"/reference/visitation.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Calculate visitation metrics — visitation","text":"samc samc-class object created using samc function. init Sets initial state \\(\\psi\\) transients states. Input must able pass check function compared samc-class object. Can contain positive finite values. origin positive integer character name representing transient state \\(\\mathit{}\\). Corresponds row \\(\\mathit{}\\) matrix \\(\\mathbf{P}\\) samc-class object. paired dest parameter, multiple values may provided vector. dest positive integer character name representing transient state \\(\\mathit{j}\\). Corresponds column \\(\\mathit{j}\\) matrix \\(\\mathbf{P}\\) samc-class object. paired origin parameter, multiple values may provided vector. time positive integer vector positive integers representing \\(\\mathit{t}\\) time steps. Vectors must ordered contain duplicates. Vectors may used metrics return dense matrices. maximum time step value capped 10,000 due numerical precision issues.","code":""},{"path":"/reference/visitation.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Calculate visitation metrics — visitation","text":"See Details","code":""},{"path":"/reference/visitation.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Calculate visitation metrics — visitation","text":"\\(\\tilde{F}_{t} = (\\sum_{n=0}^{t-1}{Q}^n)\\) visitation(samc, time) result matrix \\(M\\) \\(M_{,j}\\) number times transient state \\(\\mathit{j}\\) visited \\(\\mathit{t}\\) time steps starting transient state \\(\\mathit{}\\). returned matrix always dense optimized. Must enable override use (see samc-class). visitation(samc, origin, time) result vector \\(\\mathbf{v}\\) \\(\\mathbf{v}_j\\) number times transient state \\(\\mathit{j}\\) visited \\(\\mathit{t}\\) time steps starting transient state \\(\\mathit{}\\). samc-class object created using matrix RasterLayer maps, vector \\(\\mathbf{v}\\) can mapped RasterLayer using map function. visitation(samc, dest, time) result vector \\(\\mathbf{v}\\) \\(\\mathbf{v}_i\\) number times transient state \\(\\mathit{j}\\) visited \\(\\mathit{t}\\) time steps starting transient state \\(\\mathit{}\\). samc-class object created using matrix RasterLayer maps, vector \\(\\mathbf{v}\\) can mapped RasterLayer using map function. visitation(samc, origin, dest, time) result numeric value number times transient state \\(\\mathit{j}\\) visited \\(\\mathit{t}\\) time steps starting transient state \\(\\mathit{}\\). \\(\\psi^T \\tilde{F}_{t}\\) visitation(samc, init, time) result vector \\(\\mathbf{v}\\) \\(\\mathbf{v}_j\\) number times transient state \\(\\mathit{j}\\) visited \\(\\mathit{t}\\) time steps absorption given initial state \\(\\psi\\). samc-class object created using matrix RasterLayer maps, vector \\(\\mathbf{v}\\) can mapped RasterLayer using map function. visitation(samc, init, dest, time) result numeric value number times transient state \\(\\mathit{j}\\) visited \\(\\mathit{t}\\) time steps given initial state \\(\\psi\\). \\(F = (-Q)^{-1}\\) visitation(samc) result matrix \\(M\\) \\(M_{,j}\\) number times transient state \\(\\mathit{j}\\) visited absorption starting transient state \\(\\mathit{}\\). returned matrix always dense optimized. Must enable override use (see samc-class). visitation(samc, origin) result vector \\(\\mathbf{v}\\) \\(\\mathbf{v}_j\\) number times transient state \\(\\mathit{j}\\) visited absorption starting transient state \\(\\mathit{}\\). samc-class object created using matrix RasterLayer maps, vector \\(\\mathbf{v}\\) can mapped RasterLayer using map function. visitation(samc, dest) result vector \\(\\mathbf{v}\\) \\(\\mathbf{v}_i\\) number times transient state \\(\\mathit{j}\\) visited absorption starting transient state \\(\\mathit{}\\). samc-class object created using matrix RasterLayer maps, vector \\(\\mathbf{v}\\) can mapped RasterLayer using map function. visitation(samc, origin, dest) result numeric value number times transient state \\(\\mathit{j}\\) visited absorption starting transient state \\(\\mathit{}\\). \\(\\psi^TF\\) visitation(samc, init) result vector \\(\\mathbf{v}\\) \\(\\mathbf{v}_j\\) number times transient state \\(\\mathit{j}\\) visited absorption given initial state \\(\\psi\\). samc-class object created using matrix RasterLayer maps, vector \\(\\mathbf{v}\\) can mapped RasterLayer using map function. visitation(samc, init, dest) result numeric value number times transient state \\(\\mathit{j}\\) visited absorption given initial state \\(\\psi\\).","code":""},{"path":"/reference/visitation.html","id":"performance","dir":"Reference","previous_headings":"","what":"Performance","title":"Calculate visitation metrics — visitation","text":"relevant performance information function can found performance vignette: vignette(\"performance\", package = \"samc\")","code":""},{"path":"/reference/visitation.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Calculate visitation metrics — visitation","text":"","code":"# \"Load\" the data. In this case we are using data built into the package. # In practice, users will likely load raster data using the raster() function # from the raster package. res_data <- samc::example_split_corridor$res abs_data <- samc::example_split_corridor$abs init_data <- samc::example_split_corridor$init   # Make sure our data meets the basic input requirements of the package using # the check() function. check(res_data, abs_data) #> [1] TRUE check(res_data, init_data) #> [1] TRUE  # Setup the details for a random-walk model rw_model <- list(fun = function(x) 1/mean(x), # Function for calculating transition probabilities                  dir = 8, # Directions of the transitions. Either 4 or 8.                  sym = TRUE) # Is the function symmetric?   # Create a `samc-class` object with the resistance and absorption data using # the samc() function. We use the recipricol of the arithmetic mean for # calculating the transition matrix. Note, the input data here are matrices, # not RasterLayers. samc_obj <- samc(res_data, abs_data, model = rw_model)   # Convert the initial state data to probabilities init_prob_data <- init_data / sum(init_data, na.rm = TRUE)   # Calculate short- and long-term metrics using the analytical functions short_mort <- mortality(samc_obj, init_prob_data, time = 50) short_dist <- distribution(samc_obj, origin = 3, time = 50) long_disp <- dispersal(samc_obj, init_prob_data) #>  #> Cached diagonal not found. #> Performing setup. This can take several minutes... Complete. #> Calculating matrix inverse diagonal... #>  Computing: 48%  (~10s remaining)        Computing: 98%  (~0s remaining)        Computing: 100% (done)                          #>  Complete                                                       #> Diagonal has been cached. Continuing with metric calculation... visit <- visitation(samc_obj, dest = 4) surv <- survival(samc_obj)   # Use the map() function to turn vector results into RasterLayer objects. short_mort_map <- map(samc_obj, short_mort) short_dist_map <- map(samc_obj, short_dist) long_disp_map <- map(samc_obj, long_disp) visit_map <- map(samc_obj, visit) surv_map <- map(samc_obj, surv)"},{"path":"/reference/visitation_net.html","id":null,"dir":"Reference","previous_headings":"","what":"Calculate net visitation — visitation_net","title":"Calculate net visitation — visitation_net","text":"Calculates net number times transient states visited absorption.","code":""},{"path":"/reference/visitation_net.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Calculate net visitation — visitation_net","text":"","code":"visitation_net(samc, init, origin, dest)  # S4 method for class 'samc,missing,location,missing' visitation_net(samc, origin)  # S4 method for class 'samc,missing,location,location' visitation_net(samc, origin, dest)  # S4 method for class 'samc,ANY,missing,missing' visitation_net(samc, init)  # S4 method for class 'samc,ANY,missing,location' visitation_net(samc, init, dest)"},{"path":"/reference/visitation_net.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Calculate net visitation — visitation_net","text":"samc samc-class object created using samc function. init Sets initial state \\(\\psi\\) transients states. Input must able pass check function compared samc-class object. Can contain positive finite values. origin positive integer character name representing transient state \\(\\mathit{}\\). Corresponds row \\(\\mathit{}\\) matrix \\(\\mathbf{P}\\) samc-class object. paired dest parameter, multiple values may provided vector. dest positive integer character name representing transient state \\(\\mathit{j}\\). Corresponds column \\(\\mathit{j}\\) matrix \\(\\mathbf{P}\\) samc-class object. paired origin parameter, multiple values may provided vector.","code":""},{"path":"/reference/visitation_net.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Calculate net visitation — visitation_net","text":"See Details","code":""},{"path":"/reference/visitation_net.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Calculate net visitation — visitation_net","text":"Add details ","code":""},{"path":"/reference/visitation_net.html","id":"performance","dir":"Reference","previous_headings":"","what":"Performance","title":"Calculate net visitation — visitation_net","text":"relevant performance information function can found performance vignette: vignette(\"performance\", package = \"samc\")","code":""},{"path":"/reference/visitation_net.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Calculate net visitation — visitation_net","text":"","code":"# \"Load\" the data. In this case we are using data built into the package. # In practice, users will likely load raster data using the raster() function # from the raster package. res_data <- samc::example_split_corridor$res abs_data <- samc::example_split_corridor$abs init_data <- samc::example_split_corridor$init   # Make sure our data meets the basic input requirements of the package using # the check() function. check(res_data, abs_data) #> [1] TRUE check(res_data, init_data) #> [1] TRUE  # Setup the details for a random-walk model rw_model <- list(fun = function(x) 1/mean(x), # Function for calculating transition probabilities                  dir = 8, # Directions of the transitions. Either 4 or 8.                  sym = TRUE) # Is the function symmetric?   # Create a `samc-class` object with the resistance and absorption data using # the samc() function. We use the recipricol of the arithmetic mean for # calculating the transition matrix. Note, the input data here are matrices, # not RasterLayers. samc_obj <- samc(res_data, abs_data, model = rw_model)   # Convert the initial state data to probabilities init_prob_data <- init_data / sum(init_data, na.rm = TRUE)   # Calculate short- and long-term metrics using the analytical functions short_mort <- mortality(samc_obj, init_prob_data, time = 50) short_dist <- distribution(samc_obj, origin = 3, time = 50) long_disp <- dispersal(samc_obj, init_prob_data) #>  #> Cached diagonal not found. #> Performing setup. This can take several minutes... Complete. #> Calculating matrix inverse diagonal... #>  Computing: 51%  (~9s remaining)        Computing: 100% (done)                          #>  Complete                                                       #> Diagonal has been cached. Continuing with metric calculation... visit <- visitation(samc_obj, dest = 4) surv <- survival(samc_obj)   # Use the map() function to turn vector results into RasterLayer objects. short_mort_map <- map(samc_obj, short_mort) short_dist_map <- map(samc_obj, short_dist) long_disp_map <- map(samc_obj, long_disp) visit_map <- map(samc_obj, visit) surv_map <- map(samc_obj, surv)"},{"path":"/news/index.html","id":"samc-400","dir":"Changelog","previous_headings":"","what":"samc 4.0.0","title":"samc 4.0.0","text":"CRAN release: 2024-10-30","code":""},{"path":"/news/index.html","id":"breaking-changes-4-0-0","dir":"Changelog","previous_headings":"","what":"Breaking changes","title":"samc 4.0.0","text":"now behaves consistently metrics returns single value representing result destination node. Previously, behaved like passage() function gdistance returned vector using origin destination node information perform correction flow values. Previously, function used mathematical implementation passage() gdistance. retrospect, final part implementation works properly specific case single start point single end point, correct input requirements passage(), quite correct multiple nodes absorption. new version properly accounts general cases involving multiple absorbing locations varying intensities absorption. change results older versions. difference two versions equivalent one half results mortality(). practice, landscapes widespread absorption see negligible difference; current large-scale examples, effect several magnitudes order less net flow value. difference may prominent dealing small number absorbing nodes.","code":""},{"path":"/news/index.html","id":"new-features-4-0-0","dir":"Changelog","previous_headings":"","what":"New features","title":"samc 4.0.0","text":"visitation_net(samc, origin) visitation_net(samc, init) visitation_net(samc, init, dest) Currently applies samc objects built convolutions. Default \"double\" provides 15-16 digits precision. previous versions. \"single\" option provides 7-8 digits precision, also reduces RAM use roughly half. ’s also slightly faster metric calculations (~20% less time one device), also scales slightly better multiple cores.","code":""},{"path":"/news/index.html","id":"other-4-0-0","dir":"Changelog","previous_headings":"","what":"Other","title":"samc 4.0.0","text":"Enabled vector inputs init parameters regardless data type used inputs samc() function. intended provide flexibility special situations, ’s recommended init inputs reflect data types used samc(). Reorganization internal functions. Improvements model options validation.","code":""},{"path":"/news/index.html","id":"bug-fixes-4-0-0","dir":"Changelog","previous_headings":"","what":"Bug fixes","title":"samc 4.0.0","text":"Fixed check() node count approach convolution. Fixed convolution short-term metrics multiple time inputs.","code":""},{"path":"/news/index.html","id":"samc-330","dir":"Changelog","previous_headings":"","what":"samc 3.3.0","title":"samc 3.3.0","text":"CRAN release: 2024-07-11","code":""},{"path":"/news/index.html","id":"new-features-3-3-0","dir":"Changelog","previous_headings":"","what":"New features","title":"samc 3.3.0","text":"cond_passage(samc, init, dest) dispersal(samc, origin, dest, time) distribution(samc, init, dest, time) mortality(samc, init, dest, time)","code":""},{"path":"/news/index.html","id":"other-3-3-0","dir":"Changelog","previous_headings":"","what":"Other","title":"samc 3.3.0","text":"Lot’s internal refactoring consolidation. Various small memory speed optimizations. Various small fixes. License update.","code":""},{"path":"/news/index.html","id":"samc-321","dir":"Changelog","previous_headings":"","what":"samc 3.2.1","title":"samc 3.2.1","text":"CRAN release: 2023-05-09","code":""},{"path":"/news/index.html","id":"bug-fix-3-2-1","dir":"Changelog","previous_headings":"","what":"Bug fix","title":"samc 3.2.1","text":"Fixed minor issue check() preventing use init parameter samc objects created directly matrix.","code":""},{"path":"/news/index.html","id":"samc-320","dir":"Changelog","previous_headings":"","what":"samc 3.2.0","title":"samc 3.2.0","text":"CRAN release: 2023-05-04","code":""},{"path":"/news/index.html","id":"new-features-3-2-0","dir":"Changelog","previous_headings":"","what":"New Features","title":"samc 3.2.0","text":"Added visitation_net() function calculating net movement flow (vs total visitation())","code":""},{"path":"/news/index.html","id":"samc-310","dir":"Changelog","previous_headings":"","what":"samc 3.1.0","title":"samc 3.1.0","text":"CRAN release: 2023-04-07","code":""},{"path":"/news/index.html","id":"new-features-3-1-0","dir":"Changelog","previous_headings":"","what":"New Features","title":"samc 3.1.0","text":"algorithm memory efficient fast, making good choice memory-constrained scenarios. currently supported metrics. supported metrics use init parameter. Long-term metrics indeterminate run times can either really fast really slow, depending data used setup model. currently support NA values landscape data. relevant creating samc-class objects raster/map data; work manually constructed transition matrices. Users generally assume CRW walk requires order magnitude memory default random-walk model. current implementation relies von Mises distribution allows users specify single global value kappa turning probability. Future versions package expand support cell specific turning probabilities directional bias. Currently supports metrics origin input. support init dest inputs. origin input CRW matrix cell number direction map() function averages results directions. change future allow flexibility.","code":""},{"path":"/news/index.html","id":"performance-3-1-0","dir":"Changelog","previous_headings":"","what":"Performance","title":"samc 3.1.0","text":"Added support built-named transition functions, results significantly faster samc-class object creation eliminating overhead associated user-defined functions. Currently, \"1/mean(x)\" supported, others can added future.","code":""},{"path":"/news/index.html","id":"other-3-1-0","dir":"Changelog","previous_headings":"","what":"Other","title":"samc 3.1.0","text":"Added toy resistance data used workshop IALE 2021 conference.","code":""},{"path":"/news/index.html","id":"samc-302","dir":"Changelog","previous_headings":"","what":"samc 3.0.2","title":"samc 3.0.2","text":"CRAN release: 2023-02-01","code":""},{"path":"/news/index.html","id":"new-features-3-0-2","dir":"Changelog","previous_headings":"","what":"New Features","title":"samc 3.0.2","text":"Added support terra package raster data. Internally, package now uses terra converts RasterLayer objects SpatRaster objects. ’s recommended users switch terra package loading preparing raster data samc. Made rasterize() function publicly available. Mainly useful converting matrices SpatRaster matches structure used internally package. Added short-term versions visitation() function. Breaking Added support setting initial state visitation() function","code":""},{"path":"/news/index.html","id":"performance-3-0-2","dir":"Changelog","previous_headings":"","what":"Performance","title":"samc 3.0.2","text":"Breaking Removed default naming cells samc objects created rasters. leads substantially smaller samc objects, especially raster inputs become larger. Overhauled samc object creation substantially memory efficient. now feasible create samc objects 100+ million transient states 32 GB RAM. However, memory efficiency comes tradeoff samc objects can take significantly longer create (~2x long based preliminary testing). Added optional support iterative solvers metrics (applicable). greatly reduces memory requirements metrics, general, take longer calculate. Initial tests indicate visitation() function feasible samc objects 50 Million cells 32 GB RAM. Details changing solver can found help documentation samc-class. rare cases, cached data reused combinations arguments metrics. can lead unexpected situational speedups depending order metrics code. Combinations metrics benefiting behavior currently documented, may future. Currently, samc object ’s cache. Creating multiple samc objects can lead high memory usage data caches. best way avoid one samc object time. future version implement single global data cache multiple samc objects lead multiple data caches consuming excess memory.","code":""},{"path":"/news/index.html","id":"website-3-0-2","dir":"Changelog","previous_headings":"","what":"Website","title":"samc 3.0.2","text":"Updated performance vignette include additional information choice linear solver. Also removed old memory consumption benchmarks due flaw testing profilers R measure memory consumption native code.","code":""},{"path":"/news/index.html","id":"other-3-0-2","dir":"Changelog","previous_headings":"","what":"Other","title":"samc 3.0.2","text":"Breaking Combined three original example data objects single list. Updated documentation accordingly. Moved maze example vignette data built-data object. Breaking Removed support TransitionLayer inputs samc() function gdistance can removed dependency. Breaking sym option creating samc object currently ignored. Breaking map() function updated output matches input types used samc() function. Breaking Rename tr_args parameter model reflect future anticipated support different types models. Current usage change assumes default random-walk model. Breaking Renamed occ parameter metrics init (short “initial state” “initialize”) Breaking Added parameter setting initial state cond_passage() function match metrics, currently used. Bumped various package version requirements.","code":""},{"path":"/news/index.html","id":"samc-201","dir":"Changelog","previous_headings":"","what":"samc 2.0.1","title":"samc 2.0.1","text":"CRAN release: 2022-06-11 Fix debian-clang build error Replace built-progress counter RcppThread progress counter Added/updated maze example vignettes Added coin flip vignette","code":""},{"path":"/news/index.html","id":"samc-200","dir":"Changelog","previous_headings":"","what":"samc 2.0.0","title":"samc 2.0.0","text":"CRAN release: 2021-10-23 Removed backward compatibility deprecated samc() function parameters. breaking change make maintaining package adding new features simpler process going forward, hopefully minor inconvenience users. warning message package load introduced v1.4.0 updated reflect new changes. Updated cond_passage() return 0 ==j vectors. fixes issue associated shifted indices cond_passage(samc, dest). also technically breaks backward compatibility dest equals origin cond_passage(samc, origin, dest). Previously, cond_passage(samc, origin, dest) return NA origin equaled dest, decision arbitrary. cond_passage() documentation explains . Added new section worked examples website. Added new example illustrating use various aspects package simple perfect maze interpret results. See Maze Part 1 vignette. Added multithreading dispersal(samc, origin/occ) function via RcppThread package. See Parallel Computing vignette details.","code":""},{"path":"/news/index.html","id":"samc-141","dir":"Changelog","previous_headings":"","what":"samc 1.4.1","title":"samc 1.4.1","text":"CRAN release: 2021-09-02 Added input check multiple absorption throws informative error list contains anything matrices Updated crs check samc(). CRS objects hidden field can vary depending system software versions, previous versions check account . lead false positives perfectly compatible rasters reported incompatible. corresponding error message also fixed report correct issue; code initially copied modified another input check, error message wasn’t updated process. Added initial vignette discussing Disconnected Data. current contents slightly modified email discussion; rewritten expanded upon future. Troubleshooting vignette error message warning message related topic added . Added Rcpp related error Troubleshooting vignette. Bumped version requirements R 3.6.0, Rcpp 1.0.5, RcppEigen 0.3.3.9.1, set C++14 standard use Makevars. Enabled Github discussions page replacement Gitter","code":""},{"path":"/news/index.html","id":"samc-140","dir":"Changelog","previous_headings":"","what":"samc 1.4.0","title":"samc 1.4.0","text":"CRAN release: 2021-06-27 Updated long/lat handling samc() use projection info built raster. Deprecated latlon parameter (longer needed). Added warning rasters non-square cells missing projection information. data parameter used pass data related transition probabilities (essentially replaces resistance p_mat parameters) tr_fun directions parameters deprecated. information now passed list tr_args. Deprecated override parameter samc() function. See samc-class documentation details set . Added support specifying transition functions symmetrical tr_args parameter list. Added ability directly input custom TransitionLayer samc() function. allows flexibility RasterLayer/matrix maps, little safer directly inputting P matrix. See samc() documentation Overview vignette full details. Added ability use $ operator accessing modifying components samc-class objects. See samc-class documentation details. Updated check() multiple rasters can inputted first argument RasterStack. eliminates need manually run check() multiple pairs rasters. Added initial support caching intermediate results calculations. currently benefits dispersal(samc, occ), now caches diag(F) calculation. means first run method still slow, subsequent runs substantially faster. feature, dispersal(samc, origin) enabled share cached information dispersal(samc, occ). Future versions expand cache options additional metrics. Added support multiple absorption. absorption parameter samc() treated total absorption (consistent previous behavior). creation samc-class object, additional absorbing states can attached samc-class object. See samc-class documentation new Multiple Absorption tutorial details. Added new absorption() metric. metric closely related mortality() metric. absorption() metric can used determine overall probability particular absorbing state reached (mortality() metric calculates individual transient states rather overall). Fix missing value short-term dispersal Overhauled Overview vignette, including adding details construction P matrix. Performance vignette update Updated documentation various analytical functions, including formal/consistent terminology. Vector outputs metric now named cells. names correspond row/column names P matrix.","code":""},{"path":"/news/index.html","id":"samc-130","dir":"Changelog","previous_headings":"","what":"samc 1.3.0","title":"samc 1.3.0","text":"CRAN release: 2021-04-01 Fixed issue check() function data contains NA’s. Fixed issue raster returned locate(samc) 0 NA cells. Improved error checking messaging check() locate() functions. Named rows columns P matrix now supported. Previously, naming rows columns cause checks fail. names manually assigned, names simply row/column numbers converted character strings. Analytical functions updated support named inputs origin dest location parameters origin dest parameter used function, inputs can paired vectors. Added pairwise() utility function Created new Locations tutorial vignette new location input options.","code":""},{"path":"/news/index.html","id":"samc-121","dir":"Changelog","previous_headings":"","what":"samc 1.2.1","title":"samc 1.2.1","text":"CRAN release: 2020-11-02 Fixed regression v1.2.0 samc() function work correctly unless matrix/raster layers contained least one NA cell Revamped automated test suite test scenarios better catch issues release Added checks samc-class creation prevent potential issues discontinuous/clumped input data. Currently, type data work cond_passage() function, future release. Reworked vignettes produce cleaner pages remove suggested dependencies (e.g. gifski, gganimate, ggplot2) package users aren’t bugged installing don’t need .","code":""},{"path":"/news/index.html","id":"samc-120","dir":"Changelog","previous_headings":"","what":"samc 1.2.0","title":"samc 1.2.0","text":"CRAN release: 2020-10-14 Added ability create samc-class objects custom P matrix using p_mat parameter samc(). See samc() documentation details Added cond_passage() function, calculates conditional mean first passage times Added locate() function, functions similarly cellFromXY() function raster package. ’s used get cell numbers xy coords, unlike cellFromXY(), properly accounts cells numbered P matrix constructed. Adjusted absorption inputs support values 0 (.e., absorption). Currently, least one cell must non-zero value Fixed issue raster/matrix inputs containing isolated cells (individual cells neighbored NA values) lead malformed P matrices.","code":""},{"path":"/news/index.html","id":"samc-110","dir":"Changelog","previous_headings":"","what":"samc 1.1.0","title":"samc 1.1.0","text":"CRAN release: 2020-05-19 vector inputs used time steps, result contained list names entries list character versions corresponding time step values Time step vectors must consist ordered positive integers duplicate values Time step vector inputs added short-term metrics return dense matrices Updated map() function support list inputs generated short-term metrics. result list RasterLayers Updated Temporal Analysis Animations vignettes incorporate time step vectors Created Gitter community package support. Gitter badges README home pages can used access . Updated package citation info refer Marx et al. (2020, DOI: 10.1111/ecog.04891)","code":""},{"path":"/news/index.html","id":"samc-104","dir":"Changelog","previous_headings":"","what":"samc 1.0.4","title":"samc 1.0.4","text":"CRAN release: 2020-01-08 Add conditional usage suggested packages vignettes Minor updates package info","code":""},{"path":"/news/index.html","id":"samc-103","dir":"Changelog","previous_headings":"","what":"samc 1.0.3","title":"samc 1.0.3","text":"CRAN release: 2019-08-21 First CRAN submission","code":""},{"path":"/news/index.html","id":"samc-100","dir":"Changelog","previous_headings":"","what":"samc 1.0.0","title":"samc 1.0.0","text":"Complete package rewrite (code dependent v0.1.0 work) samc-class managing SAMC data Utility functions creating samc-class objects, checking inputs, mapping data Utilizing sparse matrices Eigen C++ implementation via Rcpp RcppEigen Updated example data Extensive documentation Several tutorials","code":""},{"path":"/news/index.html","id":"samc-010","dir":"Changelog","previous_headings":"","what":"samc 0.1.0","title":"samc 0.1.0","text":"Created crude functions calculating metrics Fletcher et al. (2019, DOI: 10.1111/ele.13333) Included example data","code":""}]
