---
title: "Code Snippets"
author: "Andrew Marx"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Code Snippets}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r setup, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

## Introduction

This page is home to code that isn't suitable for inclusion in the samc package or dedicated vignettes, but that users may find benificial nonetheless. Some of what is included here may eventually be integrated into the package. Code here is not as thoroughly tested as the package and may not work in all situations or versions of the package.


## Pairwise inputs

When providing vector inputs for the `origin` and `dest` parameters to analytical functions, the package assumes that users are providing pairs of `origin` and `dest`. That is, `origin[1]` is paired with `dest[1]`, `origin[2]` is paired `dest[2]`, etc. Another way to think about it is that these two vector inputs can be treated as columns in the same dataframe. The result of the analytical function then is a vector of the same length as the input. This behavior works for any situation, so it is the default for the package. *Note: only the `cond_passage()` function supports vectors of data for `origin` and `dest`. In future versions of the package, other analytical functions will support vectors as well*

However, some users may wish to run an analytical function for all the pairwise combinations of the values in the input vectors. That is, `origin[1]` is paired with `dest[1]`, `dest[2]`, `dest[3]`, etc, before moving on to the next elements in `origin`. The result of this would be a pairwise matrix. This has the advantage of potentially reducing the amount of code needed to setup an analysis, but is not applicable to every situation, so it is not the default behavior of analytical functions in the package. 

The following code is a function that creates all the pairwise combinations of the inputs and then returns the results in a pairwise matrix:

```{r eval = FALSE}
pairwise_mat <- function(fun, samc, origin, dest, ...) {
  # Create all possible pairs
  df <- expand.grid(origin, dest)

  # Remove duplicates
  df <- unique(df)

  # Get cond_passage
  df$res <- NA
  for (r in 1:nrow(df)) {
    df$res[r] <- fun(P, origin = df$Var1[r], dest = df$Var2[r], ...)
  }

  # The data is in a "long" format and just needs to be converted into a "wide" format
  return(reshape2::acast(df, df$Var1 ~ df$Var2, value.var = "res"))
}
```


The `cond_passage()` function directly supports vector inputs for `origin` and `dest`, so a more optimized version is possible for it:

```{r eval = FALSE}
cond_passage_mat <- function(samc, origin, dest) {
  # Create all possible pairs
  df <- expand.grid(origin, dest)
  
  # Remove duplicates
  df <- unique(df)
  
  # Get results
  df$res <- cond_passage(samc, origin = df$Var1, dest = df$Var2)
  
  # The data is in a "long" format and just needs to be converted into a "wide" format
  return(reshape2::acast(df, df$Var1 ~ df$Var2, value.var = "res"))
}

```

In a future version of the package, vector inputs will be added for all of the analytical functions, in which case, the optimized version of the function will be modified to support all of them.
