---
title: "Maze Part 3"
author: "Andrew Marx"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Maze Part 3}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r setup, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)

required <- c("viridisLite")
if (!all(sapply(required, requireNamespace, quietly = TRUE))) {
  knitr::opts_chunk$set(eval = FALSE)
}

library(samc)
library(raster)
library(gdistance)
library(viridisLite)

maze_plot <- function(map, title, colors) {
  sf <- xyFromCell(map, c(1, length(map)))

  plot(map, main = title, col = colors, axes = FALSE, box = FALSE, asp = 1)
  plot(rasterToPolygons(map), border = 'black', lwd = 1, add = TRUE)
  points(sf, pch = c('S', 'F'), cex = 1, font = 2)
}

maze = matrix(
  c(1,0,0,0,0,1,1,1,1,1,1,0,1,0,0,0,0,1,0,1,
    1,1,1,1,0,1,0,1,0,0,1,1,1,0,1,1,0,1,1,1,
    1,0,0,1,0,1,0,1,1,0,1,0,1,0,0,1,0,0,1,0,
    1,1,0,0,0,1,0,0,0,0,0,0,1,1,0,1,0,1,1,1,
    0,1,1,1,1,1,1,1,1,1,1,0,0,0,0,1,0,0,0,1,
    1,1,0,1,0,0,0,1,0,1,0,0,1,0,1,1,1,1,0,1,
    0,0,0,0,0,1,0,0,0,1,1,0,1,1,1,0,0,1,0,1,
    1,1,0,1,1,1,1,1,0,0,1,0,0,1,0,0,1,1,1,1,
    0,1,0,1,0,0,0,1,1,1,1,1,0,1,1,0,1,0,1,0,
    1,1,0,1,0,1,0,0,0,1,0,0,0,0,0,0,1,0,1,1,
    0,1,1,1,1,1,1,1,0,1,1,1,0,1,0,1,1,0,0,1,
    1,1,0,0,1,0,0,1,0,1,0,1,1,1,0,1,0,0,1,1,
    0,1,0,1,1,1,0,0,0,0,0,0,0,0,0,1,1,0,0,1,
    0,0,0,0,1,0,0,1,1,1,0,1,0,1,1,1,0,0,1,1,
    1,1,0,1,1,1,1,1,0,1,1,1,1,1,0,0,0,1,1,0,
    1,0,0,0,0,0,0,1,0,0,1,0,0,0,0,1,0,0,1,1,
    1,1,1,1,0,1,0,0,0,1,1,0,1,1,0,1,1,1,1,0,
    0,1,0,1,0,1,1,1,0,0,0,0,0,1,0,1,0,1,0,0,
    0,0,0,1,0,0,0,1,1,1,1,1,1,1,0,0,0,1,1,1,
    1,1,1,1,1,1,1,1,0,1,0,1,0,1,1,1,1,1,0,1),
  nrow = 20, byrow = TRUE
)

maze <- raster(maze, xmn = 0.5, xmx = ncol(maze) + 0.5, ymn = 0.5, ymx = nrow(maze) + 0.5)
maze[maze==0] <- NA

#
# Get info about the shortest path through the maze using gdistance
#
lcd <- (function() {
  points <- xyFromCell(maze, c(1, 400))

  tr <- transition(maze, function(x) 1/mean(x), 4)
  tr <- geoCorrection(tr)

  list(dist = costDistance(tr, points),
       path = shortestPath(tr, points[1, ], points[2, ], output="SpatialLines"))
})()

# Setup a simple color palette
vir_col <- viridis(3)[2:3]

# End of maze
maze_finish <- maze * 0
maze_finish[20, 20] <- 1

tr <- list(fun = function(x) 1/mean(x), dir = 4, sym = TRUE)

samc_obj <- samc(maze, maze_finish, tr_args = tr)

start <- locate(samc_obj, data.frame(x = 1, y = 20))
finish <- locate(samc_obj, data.frame(x = 20, y = 1))

tolerance = sqrt(.Machine$double.eps) # Default tolerance in functions like all.equal()

# Intersections determined using a moving window function
maze_ints <- focal(maze, w = matrix(c(NA, 1, NA, 1, 1, 1, NA, 1, NA), nrow = 3, ncol = 3), fun = function(x){sum(!is.na(x)) > 3}, pad = TRUE)
maze_ints[is.na(maze)] <- NA
maze_ints <- maze_ints * 0.1

# Dead ends
maze_ends <- focal(maze, w = matrix(c(NA, 1, NA, 1, 1, 1, NA, 1, NA), nrow = 3, ncol = 3), fun = function(x){sum(!is.na(x)) == 2}, pad = TRUE)
maze_ends[is.na(maze)] <- NA
maze_ends <- maze_ends * 9 + 1
maze_ends[20, 20] <- 1

# Traps absorption layer
maze_traps <- maze * 0
maze_traps[17, 3] <- 0.2
maze_traps[1, 9] <- 0.2
maze_traps[6, 20] <- 0.2

abs_total <- maze_finish + maze_traps

samc_traps <- samc(maze, abs_total, tr_args = tr)
```


## Introduction

In the third part of the series, we take our perfect maze with only a single solution and modify it so that it now has more than one solution. We then take all of the changes introduced in the series and combine them into a single complex example.


## Setup

This example reuses the [libraries](example-maze-part1.html#libraries1), [setup](example-maze-part1.html#setup1), and original [samc object](example-maze-part1.html#create-the-samc-object-1) code from Part 1. Later, we will reuse the various modifications introduced in [Part 2](example-maze-part2.html).


## Shortcut

We will start with modifying our maze so that it has a new cell bridging previously existing cells. The location was chosen so that it effectively acts as a shortcut to the previous solution. To make things interesting, we will model it as a secret passage by giving it a high resistance value so that it is only rarely utilized. This is effectively the same method used to model dead end avoidance in Part 2, but here the interpretation is different because of where the high resistance is located.

```{r, fig.show='hold', fig.width=7, fig.height=5, fig.align='center'}
# Create a copy and add a shortcut
maze2 <- maze
maze2[16, 6] <- 10

# Get info about the shortest path through the new maze using gdistance
lcd2 <- (function() {
  points <- xyFromCell(maze2, c(1, 400))

  tr <- transition(maze2, function(x) 1/mean(x), 4)
  tr <- geoCorrection(tr)

  list(dist = costDistance(tr, points),
       path = shortestPath(tr, points[1, ], points[2, ], output="SpatialLines"))
})()

maze_plot(maze2, "Maze 2", vir_col)
lines(lcd2$path, col = vir_col[2], lw = 3)
```

Let's quickly verify the change in distance for the shortest solution:

```{r}
# Let's see what the difference in distance is
lcd2$dist - lcd$dist
```

Create a new samc object:
```{r}
# Our old absorption layer does not quite match our new resistance layer, so make a new one
maze2_finish <- maze2 * 0
maze2_finish[20, 20] <- 1

samc_maze2 <- samc(maze2, maze2_finish, tr_args = tr)

# Important: we have to rerun locate()
start_maze2 <- locate(samc_maze2, data.frame(x = 1, y = 20))
finish_maze2 <- locate(samc_maze2, data.frame(x = 20, y = 1))
```

An important thing to keep in mind: we modified where `NA` and non-`NA` cells are located in the map. This means that previous results from `locate()` are no longer guaranteed to be valid. In this case, `start` is technically the same, but `finish` actually is not and will return incorrect results, or in special cases cause a crash.

With that, we can begin exploring the different metric and compare them to the results from Part 1. Let's start with `survival()`:
```{r, fig.show='hold', fig.width=7, fig.height=5, fig.align='center'}
surv_maze2 <- survival(samc_maze2)

maze_plot(map(samc_maze2, surv_maze2), "Expected time to finish (Maze 2)", viridis(256))
```

There are two noticeable changes. First, the expected time to finish is drastically decreased for our starting point:
```{r}
# Expected time to finish from the start
surv_maze2[start]

# The difference from our original maze
surv_maze2[start] - survive[start]
```

The second change is the overall increase in expected time to finish when the individual is in the bottom left region of the maze because the shortcut can actually lead them away from the finish point when they are in this region. If the shortcut was asymmetric (i.e., one way), we would still see a drastic decrease in the time to finish for the starting point, but then the bottom left region would remain unchanged from our original example. This type of model setup is possible with the package, but not without directly providing the P matrix. Graph support in the future will make more complex scenarios like a one-way shortcut easier to setup.

In Part 2, we saw that the inclusion of additional absorbing states changed the relationship between `survival()` and `cond_passage()`. Since we're back to a single absorbing state at the finish point, this relationship is restored:
```{r}
cond_maze2 <- cond_passage(samc_maze2, dest = finish_maze2)
cond_maze2[start]
```

In Part 2, we also saw that including additional absorbing states affected the probability of cells being visited. Modifying the maze to have multiple routes also has significant ramifications:
```{r, fig.show='hold', fig.width=7, fig.height=5, fig.align='center'}
disp_maze2 <- dispersal(samc_maze2, origin = start_maze2)

maze_plot(map(samc_maze2, disp_maze2), "Probability of Visit (Maze 2)", viridis(256))
```

Notably, we again can no longer easily discern the optimal route through the maze by looking for cells with a probability of 1. But we can still get a partial path like Part 2:
```{r, fig.show='hold', fig.width=7, fig.height=5, fig.align='center'}
# Ideally, we would just use `as.numeric(disp == 1)`, but we have floating point precision issues here, so we will approximate it
disp_maze2_sol <- as.numeric(abs(disp_maze2 - 1) < tolerance)

maze_plot(map(samc_maze2, disp_maze2_sol), "Partial solution (Maze 2)", vir_col)
```

In this case, we're getting the solution for the regions outside of the loop created by the shortcut.


## Combined Example

Here we will combine the various changes we've made throughout the series into one final example maze.

```{r, fig.show='hold', fig.width=7, fig.height=5, fig.align='center'}
# Combine our previous resistance layers
maze_all <- max(stack(maze2, maze_ints, maze_ends), na.rm = TRUE)

# For absorption, all we need is an updated version of our traps raster
maze_all_traps <- maze_traps
maze_all_traps[16, 6] <- 0

# Total absorption
abs_all_total <- maze2_finish + maze_all_traps


# If we had more variety in our resistance values we would want more colors
maze_plot(maze_all, "Final Maze", vir_col)

# Plot the traps raster
maze_plot(maze_all_traps, "Final Maze Traps", vir_col)
```

There is an unusual artifact present in our new resistance raster: our shortcut leads into a former dead end, and the dead end resistance value will increase the probability of the individual turning around in the shortcut even though, from the perspective of the shortcut, it is not a dead end. However, when approaching from the bottom, the dead end still exists if we assume the shortcut is hidden. This is a case where having asymmetric transition probabilities would be a more ideal solution, but for simplicity, we will leave things as they are.

Create the new samc object:
```{r}
samc_all <- samc(maze_all, abs_all_total, tr_args = tr)

# We can actually reuse the maze2 locations in this case, but let's make new ones anyway
start_maze_all <- locate(samc_all, data.frame(x = 1, y = 20))
finish_maze_all <- locate(samc_all, data.frame(x = 20, y = 1))
```

As usual, we will start with looking at expected time to absorption:
```{r, fig.show='hold', fig.width=7, fig.height=5, fig.align='center'}
surv_all <- survival(samc_all)

# Note the updated title from part 1
maze_plot(map(samc_all, surv_all), "Expected Time to Absorption", viridis(256))
```

Similar to Part 2, the presence of additional absorbing states (the traps), drastically changes the result and interpretation of the `survival()` metric. The results are actually very similar to part 2, but the presence of a shortcut does increase access to both the bottom left trap and the finish point. The relative role of each isn't clear, but it does overall seem to do decrease the time to absorption. 

Next is a complete overview of the difference results for `survival()` and `cond_passage()`:
```{r}
# Our original results from Part 1
cat("Original\n")
survival(samc_obj)[start]
cond_passage(samc_obj, start, finish)

# Our results with traps
cat("\nTraps\n")
survival(samc_traps)[start]
cond_passage(samc_traps, start, finish)

# Our results with a shortcut
cat("\nShortcut\n")
survival(samc_maze2)[start_maze2]
cond_passage(samc_maze2, start_maze2, finish_maze2)

# Results with everything
cat("\nEverything\n")
survival(samc_all)[start_maze_all]
cond_passage(samc_all, start_maze_all, finish_maze_all)
```

The presence of both the traps and the shortcut have a cumulative effect on both metrics; the time to absorption decreases, as does the time to conditional first passage (the time to finish assuming the individual is not absorbed elsewhere).

We can compare the traps-only version of the maze to our cumulative maze using the mortality() metric to see how introducing the shortcut affects the probability of finishing the maze vs being absorbed in the traps:
```{r}
mort_traps[mort_traps > 0]

mort_all <- mortality(samc_all, origin = start_maze_all)
mort_all[mort_all > 0]
```

With the introduction of the shortcut, we see that the probability of absorption into the two top traps is reduced because less time is spent in the top portion of the maze relative to the now more accessible bottom portion. We also see the probability of absorption into the bottom left trap has increased by more than an order of magnitude, accounting for most of the decrease in the top two traps. Finally, we see that the individual is somewhat more likely to survive and finish the maze. Note that the numeric index for the later two points are shifted by one; this is due to changing a `NA` cell to non-`NA` for the shortcut, and it is related to why we have to have to rerun `locate()` when the structure of the input to `samc()` changes.

By now, the process of exploring the different metrics for these examples should be clear. For this example we highlighted a few key metrics leave it to the user to explore the remaining metrics if they are interested in doing so.

## Future Work

Parts of this series may be rewritten, further expanded on, and/or reorganized in the future. Additionally, when igraph support is added to the package, the series will be expanded with an example illustrating construction of a maze using a graph.
